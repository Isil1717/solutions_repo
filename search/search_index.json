{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Technical setup Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft) Useful links Python Miniconda Documentation Google Colab How to use this repository Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW Where can I find the problems? Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Introduction"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#technical-setup","text":"Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft)","title":"Technical setup"},{"location":"#useful-links","text":"Python Miniconda Documentation Google Colab","title":"Useful links"},{"location":"#how-to-use-this-repository","text":"Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW","title":"How to use this repository"},{"location":"#where-can-i-find-the-problems","text":"Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Where can I find the problems?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/","text":"\u2699\ufe0f Mechanics \u2013 Problem 1 \ud83e\udde0 Mechanics Problem 1: Investigating the Range as a Function of the Angle of Projection \ud83c\udfaf Problem Overview We study the dependence of the horizontal range of a projectile on the launch angle \\( \\theta \\) , taking into account physical parameters such as: Initial velocity \\( v_0 \\) Gravitational acceleration \\( g \\) Air resistance (optional) Launch height \\( h \\) Inclined terrain \ud83d\udcd0 1. Ideal Projectile Motion (No Air Resistance) Coordinate System We decompose the motion into horizontal and vertical components. Equations of Motion: Initial velocity components: \\[ v_{0x} = v_0 \\cos(\\theta), \\quad v_{0y} = v_0 \\sin(\\theta) \\] Displacements: \\[ x(t) = v_0 \\cos(\\theta) \\cdot t \\] \\[ y(t) = v_0 \\sin(\\theta) \\cdot t - \\frac{1}{2} g t^2 \\] Time of flight (when \\( y = 0 \\) ): \\[ T = \\frac{2v_0 \\sin(\\theta)}{g} \\] Range: \\[ R(\\theta) = x(T) = \\frac{v_0^2 \\sin(2\\theta)}{g} \\] \ud83e\uddee 2. Python Implementation (Ideal Case) import numpy as np import matplotlib.pyplot as plt g = 9.81 # gravity [m/s^2] angles_deg = np.linspace(0, 90, 500) angles_rad = np.radians(angles_deg) def ideal_range(v0, theta): return (v0**2 * np.sin(2 * theta)) / g v0_values = [10, 20, 30] plt.figure(figsize=(10, 6)) for v0 in v0_values: R = ideal_range(v0, angles_rad) plt.plot(angles_deg, R, label=f\"$v_0 = {v0}$ m/s\") plt.title(\"Range vs Angle (Ideal Case)\") plt.xlabel(\"Launch Angle (degrees)\") plt.ylabel(\"Range (meters)\") plt.legend() plt.grid(True) plt.savefig(\"ideal_range.png\") plt.show() \ud83c\udfd4\ufe0f 3. Uneven Terrain (Inclined Plane) Let the ground be inclined by angle \\( \\alpha \\) . The effective launch angle becomes \\( \\theta - \\alpha \\) , and time of flight changes accordingly. Time to impact (from projectile to slope): \\[ T = \\frac{2 v_0 \\sin(\\theta - \\alpha)}{g \\cos(\\alpha)} \\] Modified range on inclined plane: \\[ R = \\frac{v_0^2 \\sin(2(\\theta - \\alpha))}{g \\cos(\\alpha)} \\] This is derived assuming a symmetrical trajectory in the slope frame. \ud83c\udf2c\ufe0f 4. Air Resistance (Linear Drag) When air resistance is considered, the force becomes: \\[ \\vec{F}_{\\text{drag}} = -k \\vec{v} \\] Where \\( k \\) is the drag coefficient. Equations of motion: \\[ \\frac{d v_x}{dt} = -\\frac{k}{m} v_x, \\quad \\frac{d v_y}{dt} = -g - \\frac{k}{m} v_y \\] Solutions: \\[ v_x(t) = v_{0x} e^{-kt/m}, \\quad v_y(t) = \\left(v_{0y} + \\frac{mg}{k} \\right) e^{-kt/m} - \\frac{mg}{k} \\] Position functions (after integration): \\[ x(t) = \\frac{m v_{0x}}{k} \\left(1 - e^{-kt/m} \\right) \\] \\[ y(t) = \\left(v_{0y} + \\frac{mg}{k} \\right) \\cdot \\frac{m}{k} \\left(1 - e^{-kt/m} \\right) - \\frac{mg}{k} \\cdot t \\] These equations require numerical solutions for time of flight and range.","title":"\u2699\ufe0f Mechanics \u2013 Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#mechanics-problem-1","text":"","title":"\u2699\ufe0f Mechanics \u2013 Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#mechanics-problem-1-investigating-the-range-as-a-function-of-the-angle-of-projection","text":"","title":"\ud83e\udde0 Mechanics Problem 1: Investigating the Range as a Function of the Angle of Projection"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#problem-overview","text":"We study the dependence of the horizontal range of a projectile on the launch angle \\( \\theta \\) , taking into account physical parameters such as: Initial velocity \\( v_0 \\) Gravitational acceleration \\( g \\) Air resistance (optional) Launch height \\( h \\) Inclined terrain","title":"\ud83c\udfaf Problem Overview"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#1-ideal-projectile-motion-no-air-resistance","text":"","title":"\ud83d\udcd0 1. Ideal Projectile Motion (No Air Resistance)"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#coordinate-system","text":"We decompose the motion into horizontal and vertical components.","title":"Coordinate System"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#equations-of-motion","text":"Initial velocity components: \\[ v_{0x} = v_0 \\cos(\\theta), \\quad v_{0y} = v_0 \\sin(\\theta) \\] Displacements: \\[ x(t) = v_0 \\cos(\\theta) \\cdot t \\] \\[ y(t) = v_0 \\sin(\\theta) \\cdot t - \\frac{1}{2} g t^2 \\] Time of flight (when \\( y = 0 \\) ): \\[ T = \\frac{2v_0 \\sin(\\theta)}{g} \\] Range: \\[ R(\\theta) = x(T) = \\frac{v_0^2 \\sin(2\\theta)}{g} \\]","title":"Equations of Motion:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#2-python-implementation-ideal-case","text":"import numpy as np import matplotlib.pyplot as plt g = 9.81 # gravity [m/s^2] angles_deg = np.linspace(0, 90, 500) angles_rad = np.radians(angles_deg) def ideal_range(v0, theta): return (v0**2 * np.sin(2 * theta)) / g v0_values = [10, 20, 30] plt.figure(figsize=(10, 6)) for v0 in v0_values: R = ideal_range(v0, angles_rad) plt.plot(angles_deg, R, label=f\"$v_0 = {v0}$ m/s\") plt.title(\"Range vs Angle (Ideal Case)\") plt.xlabel(\"Launch Angle (degrees)\") plt.ylabel(\"Range (meters)\") plt.legend() plt.grid(True) plt.savefig(\"ideal_range.png\") plt.show()","title":"\ud83e\uddee 2. Python Implementation (Ideal Case)"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#3-uneven-terrain-inclined-plane","text":"Let the ground be inclined by angle \\( \\alpha \\) . The effective launch angle becomes \\( \\theta - \\alpha \\) , and time of flight changes accordingly.","title":"\ud83c\udfd4\ufe0f 3. Uneven Terrain (Inclined Plane)"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#time-to-impact-from-projectile-to-slope","text":"\\[ T = \\frac{2 v_0 \\sin(\\theta - \\alpha)}{g \\cos(\\alpha)} \\]","title":"Time to impact (from projectile to slope):"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#modified-range-on-inclined-plane","text":"\\[ R = \\frac{v_0^2 \\sin(2(\\theta - \\alpha))}{g \\cos(\\alpha)} \\] This is derived assuming a symmetrical trajectory in the slope frame.","title":"Modified range on inclined plane:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#4-air-resistance-linear-drag","text":"When air resistance is considered, the force becomes: \\[ \\vec{F}_{\\text{drag}} = -k \\vec{v} \\] Where \\( k \\) is the drag coefficient.","title":"\ud83c\udf2c\ufe0f 4. Air Resistance (Linear Drag)"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#equations-of-motion_1","text":"\\[ \\frac{d v_x}{dt} = -\\frac{k}{m} v_x, \\quad \\frac{d v_y}{dt} = -g - \\frac{k}{m} v_y \\]","title":"Equations of motion:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#solutions","text":"\\[ v_x(t) = v_{0x} e^{-kt/m}, \\quad v_y(t) = \\left(v_{0y} + \\frac{mg}{k} \\right) e^{-kt/m} - \\frac{mg}{k} \\]","title":"Solutions:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#position-functions-after-integration","text":"\\[ x(t) = \\frac{m v_{0x}}{k} \\left(1 - e^{-kt/m} \\right) \\] \\[ y(t) = \\left(v_{0y} + \\frac{mg}{k} \\right) \\cdot \\frac{m}{k} \\left(1 - e^{-kt/m} \\right) - \\frac{mg}{k} \\cdot t \\] These equations require numerical solutions for time of flight and range.","title":"Position functions (after integration):"},{"location":"1%20Physics/1%20Mechanics/Problem_2/","text":"Problem 2 Investigating the Dynamics of a Forced Damped Pendulum Introduction The forced damped pendulum is a classic example of a non-linear oscillatory system. The system demonstrates a rich variety of behaviors, including resonance, chaos, and quasiperiodic motion, depending on the interplay between damping, restoring forces, and external driving forces. The dynamics of this system are governed by the second-order differential equation: \\[ \\frac{d^2 \\theta}{dt^2} + b \\frac{d\\theta}{dt} + \\frac{g}{L} \\sin(\\theta) = A \\cos(\\omega t) \\] Where: - \\( \\theta(t) \\) is the angular displacement, - \\( b \\) is the damping coefficient, - \\( g \\) is the gravitational acceleration, - \\( L \\) is the length of the pendulum, - \\( A \\) is the amplitude of the external driving force, - \\( \\omega \\) is the angular frequency of the external force. Small-Angle Approximation For small oscillations, we use the approximation \\( \\sin(\\theta) \\approx \\theta \\) , leading to a linearized form of the equation: \\[ \\frac{d^2 \\theta}{dt^2} + b \\frac{d \\theta}{dt} + \\frac{g}{L} \\theta = A \\cos(\\omega t) \\] This approximation simplifies the analysis, and the system behaves similarly to a driven damped harmonic oscillator. The natural frequency of the undamped system is: \\[ \\omega_0 = \\sqrt{\\frac{g}{L}} \\] At resonance, when the driving frequency \\( \\omega \\) matches the natural frequency \\( \\omega_0 \\) , the amplitude of oscillations can increase dramatically. This condition is given by: \\[ \\omega_{\\text{res}} = \\sqrt{\\frac{g}{L}} \\] Numerical Simulation To simulate the dynamics of the forced damped pendulum, we rewrite the second-order differential equation as a system of first-order equations: Let: - \\( \\theta_1 = \\theta \\) , - \\( \\theta_2 = \\frac{d \\theta}{dt} \\) . The system becomes: \\[ \\frac{d \\theta_1}{dt} = \\theta_2 \\] \\[ \\frac{d \\theta_2}{dt} = -b \\theta_2 - \\frac{g}{L} \\sin(\\theta_1) + A \\cos(\\omega t) \\] This system can be solved numerically using methods like the Runge-Kutta algorithm to obtain the time evolution of \\( \\theta_1(t) \\) and \\( \\theta_2(t) \\) . Effects of Damping and Driving Forces Damping Coefficient \\( b \\) The damping coefficient \\( b \\) controls the rate at which the oscillations decay. As \\( b \\) increases, the system loses energy more rapidly, causing the amplitude of oscillations to decrease. When \\( b \\) is large enough, the system eventually reaches a steady state with no oscillations. For small damping \\( b \\) , resonance phenomena occur, and the system can exhibit large oscillations if the driving frequency \\( \\omega \\) is close to the natural frequency of the system. The modified equation for damping is: \\[ \\frac{d^2 \\theta}{dt^2} + b \\frac{d \\theta}{dt} + \\frac{g}{L} \\theta = A \\cos(\\omega t) \\] Driving Force Amplitude \\( A \\) The amplitude of the driving force \\( A \\) determines how much energy is supplied to the system. As \\( A \\) increases, the amplitude of oscillations increases. If \\( A \\) is large enough and \\( \\omega \\) is close to \\( \\omega_{\\text{res}} \\) , the system enters a state of large amplitude oscillations, potentially leading to resonance. Driving Frequency \\( \\omega \\) The driving frequency \\( \\omega \\) plays a crucial role in determining the behavior of the system. At resonance, when \\( \\omega = \\omega_{\\text{res}} \\) , the system's response is maximal, and the oscillations grow significantly. The system exhibits a peak in amplitude at this frequency. For frequencies far from resonance, the oscillations have much smaller amplitudes. Chaos and Bifurcations As the parameters \\( A \\) (driving amplitude) and \\( \\omega \\) (driving frequency) are varied, the system can undergo bifurcations, where small changes in parameters lead to large changes in the system\u2019s behavior. The bifurcation diagram can reveal transitions from periodic to chaotic motion. In a bifurcation diagram, as \\( A \\) or \\( \\omega \\) increases, the system may exhibit a sudden transition to chaotic behavior. This is due to sensitive dependence on initial conditions, a hallmark of chaos. Lyapunov Exponent The Lyapunov exponent measures the rate at which nearby trajectories in phase space diverge, and is a key indicator of chaos. A positive Lyapunov exponent indicates chaotic behavior, while a negative value suggests stable periodic motion. It is defined as: \\[ \\lambda = \\lim_{t \\to \\infty} \\frac{1}{t} \\ln \\left( \\frac{|\\delta(t)|}{|\\delta(0)|} \\right) \\] Where: - \\( \\delta(t) \\) is the separation between two nearby trajectories at time \\( t \\) , - \\( \\delta(0) \\) is the initial separation. A positive Lyapunov exponent means that the system is chaotic and exhibits exponential divergence of nearby trajectories. Conclusion The dynamics of the forced damped pendulum provide a rich example of nonlinear behavior, including resonance, chaos, and periodic motion. By varying the damping coefficient, driving amplitude, and driving frequency, we observe a variety of dynamic responses, from stable oscillations to chaotic motion. Numerical simulations and analytical techniques such as the Lyapunov exponent and bifurcation diagrams allow for a deeper understanding of these behaviors, with applications in engineering, biomechanics, and electronics. import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # --- Physical parameters --- g = 9.81 # gravitational acceleration (m/s^2) L = 1.0 # pendulum length (m) b = 0.5 # damping coefficient A = 1.2 # amplitude of the driving force omega = 2.0 # angular frequency of the driving force # --- Time settings --- t_start = 0.0 t_end = 50.0 dt = 0.01 t_eval = np.arange(t_start, t_end, dt) # --- Initial conditions --- theta0 = 0.2 # initial angle (radians) theta_dot0 = 0.0 # initial angular velocity (rad/s) initial_state = [theta0, theta_dot0] # --- Differential equations --- def forced_damped_pendulum(t, y): theta, theta_dot = y dtheta_dt = theta_dot dtheta_dot_dt = -b * theta_dot - (g / L) * np.sin(theta) + A * np.cos(omega * t) return [dtheta_dt, dtheta_dot_dt] # --- Solve the system --- sol = solve_ivp( fun=forced_damped_pendulum, t_span=(t_start, t_end), y0=initial_state, t_eval=t_eval, method='RK45' ) # --- Plot the results --- plt.figure(figsize=(10, 5)) plt.plot(sol.t, sol.y[0], label='\u03b8(t) [rad]', color='darkblue') plt.xlabel('Time [s]') plt.ylabel('Angle \u03b8 [rad]') plt.title('Forced Damped Pendulum Simulation') plt.grid(True) plt.legend() plt.tight_layout() plt.show()","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#investigating-the-dynamics-of-a-forced-damped-pendulum","text":"","title":"Investigating the Dynamics of a Forced Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#introduction","text":"The forced damped pendulum is a classic example of a non-linear oscillatory system. The system demonstrates a rich variety of behaviors, including resonance, chaos, and quasiperiodic motion, depending on the interplay between damping, restoring forces, and external driving forces. The dynamics of this system are governed by the second-order differential equation: \\[ \\frac{d^2 \\theta}{dt^2} + b \\frac{d\\theta}{dt} + \\frac{g}{L} \\sin(\\theta) = A \\cos(\\omega t) \\] Where: - \\( \\theta(t) \\) is the angular displacement, - \\( b \\) is the damping coefficient, - \\( g \\) is the gravitational acceleration, - \\( L \\) is the length of the pendulum, - \\( A \\) is the amplitude of the external driving force, - \\( \\omega \\) is the angular frequency of the external force.","title":"Introduction"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#small-angle-approximation","text":"For small oscillations, we use the approximation \\( \\sin(\\theta) \\approx \\theta \\) , leading to a linearized form of the equation: \\[ \\frac{d^2 \\theta}{dt^2} + b \\frac{d \\theta}{dt} + \\frac{g}{L} \\theta = A \\cos(\\omega t) \\] This approximation simplifies the analysis, and the system behaves similarly to a driven damped harmonic oscillator. The natural frequency of the undamped system is: \\[ \\omega_0 = \\sqrt{\\frac{g}{L}} \\] At resonance, when the driving frequency \\( \\omega \\) matches the natural frequency \\( \\omega_0 \\) , the amplitude of oscillations can increase dramatically. This condition is given by: \\[ \\omega_{\\text{res}} = \\sqrt{\\frac{g}{L}} \\]","title":"Small-Angle Approximation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#numerical-simulation","text":"To simulate the dynamics of the forced damped pendulum, we rewrite the second-order differential equation as a system of first-order equations: Let: - \\( \\theta_1 = \\theta \\) , - \\( \\theta_2 = \\frac{d \\theta}{dt} \\) . The system becomes: \\[ \\frac{d \\theta_1}{dt} = \\theta_2 \\] \\[ \\frac{d \\theta_2}{dt} = -b \\theta_2 - \\frac{g}{L} \\sin(\\theta_1) + A \\cos(\\omega t) \\] This system can be solved numerically using methods like the Runge-Kutta algorithm to obtain the time evolution of \\( \\theta_1(t) \\) and \\( \\theta_2(t) \\) .","title":"Numerical Simulation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#effects-of-damping-and-driving-forces","text":"","title":"Effects of Damping and Driving Forces"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#damping-coefficient-b","text":"The damping coefficient \\( b \\) controls the rate at which the oscillations decay. As \\( b \\) increases, the system loses energy more rapidly, causing the amplitude of oscillations to decrease. When \\( b \\) is large enough, the system eventually reaches a steady state with no oscillations. For small damping \\( b \\) , resonance phenomena occur, and the system can exhibit large oscillations if the driving frequency \\( \\omega \\) is close to the natural frequency of the system. The modified equation for damping is: \\[ \\frac{d^2 \\theta}{dt^2} + b \\frac{d \\theta}{dt} + \\frac{g}{L} \\theta = A \\cos(\\omega t) \\]","title":"Damping Coefficient \\( b \\)"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#driving-force-amplitude-a","text":"The amplitude of the driving force \\( A \\) determines how much energy is supplied to the system. As \\( A \\) increases, the amplitude of oscillations increases. If \\( A \\) is large enough and \\( \\omega \\) is close to \\( \\omega_{\\text{res}} \\) , the system enters a state of large amplitude oscillations, potentially leading to resonance.","title":"Driving Force Amplitude \\( A \\)"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#driving-frequency-omega","text":"The driving frequency \\( \\omega \\) plays a crucial role in determining the behavior of the system. At resonance, when \\( \\omega = \\omega_{\\text{res}} \\) , the system's response is maximal, and the oscillations grow significantly. The system exhibits a peak in amplitude at this frequency. For frequencies far from resonance, the oscillations have much smaller amplitudes.","title":"Driving Frequency \\( \\omega \\)"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#chaos-and-bifurcations","text":"As the parameters \\( A \\) (driving amplitude) and \\( \\omega \\) (driving frequency) are varied, the system can undergo bifurcations, where small changes in parameters lead to large changes in the system\u2019s behavior. The bifurcation diagram can reveal transitions from periodic to chaotic motion. In a bifurcation diagram, as \\( A \\) or \\( \\omega \\) increases, the system may exhibit a sudden transition to chaotic behavior. This is due to sensitive dependence on initial conditions, a hallmark of chaos.","title":"Chaos and Bifurcations"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#lyapunov-exponent","text":"The Lyapunov exponent measures the rate at which nearby trajectories in phase space diverge, and is a key indicator of chaos. A positive Lyapunov exponent indicates chaotic behavior, while a negative value suggests stable periodic motion. It is defined as: \\[ \\lambda = \\lim_{t \\to \\infty} \\frac{1}{t} \\ln \\left( \\frac{|\\delta(t)|}{|\\delta(0)|} \\right) \\] Where: - \\( \\delta(t) \\) is the separation between two nearby trajectories at time \\( t \\) , - \\( \\delta(0) \\) is the initial separation. A positive Lyapunov exponent means that the system is chaotic and exhibits exponential divergence of nearby trajectories.","title":"Lyapunov Exponent"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#conclusion","text":"The dynamics of the forced damped pendulum provide a rich example of nonlinear behavior, including resonance, chaos, and periodic motion. By varying the damping coefficient, driving amplitude, and driving frequency, we observe a variety of dynamic responses, from stable oscillations to chaotic motion. Numerical simulations and analytical techniques such as the Lyapunov exponent and bifurcation diagrams allow for a deeper understanding of these behaviors, with applications in engineering, biomechanics, and electronics. import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # --- Physical parameters --- g = 9.81 # gravitational acceleration (m/s^2) L = 1.0 # pendulum length (m) b = 0.5 # damping coefficient A = 1.2 # amplitude of the driving force omega = 2.0 # angular frequency of the driving force # --- Time settings --- t_start = 0.0 t_end = 50.0 dt = 0.01 t_eval = np.arange(t_start, t_end, dt) # --- Initial conditions --- theta0 = 0.2 # initial angle (radians) theta_dot0 = 0.0 # initial angular velocity (rad/s) initial_state = [theta0, theta_dot0] # --- Differential equations --- def forced_damped_pendulum(t, y): theta, theta_dot = y dtheta_dt = theta_dot dtheta_dot_dt = -b * theta_dot - (g / L) * np.sin(theta) + A * np.cos(omega * t) return [dtheta_dt, dtheta_dot_dt] # --- Solve the system --- sol = solve_ivp( fun=forced_damped_pendulum, t_span=(t_start, t_end), y0=initial_state, t_eval=t_eval, method='RK45' ) # --- Plot the results --- plt.figure(figsize=(10, 5)) plt.plot(sol.t, sol.y[0], label='\u03b8(t) [rad]', color='darkblue') plt.xlabel('Time [s]') plt.ylabel('Angle \u03b8 [rad]') plt.title('Forced Damped Pendulum Simulation') plt.grid(True) plt.legend() plt.tight_layout() plt.show()","title":"Conclusion"},{"location":"1%20Physics/2%20Gravity/Problem_1/","text":"Problem 1 Kepler's Third Law: Orbital Period and Radius Motivation In celestial mechanics, Kepler's Third Law describes a fundamental connection between the orbital period and the orbital radius of a body moving around a central mass. This law allows us to estimate the structure and scale of planetary systems, including our own Solar System. Kepler discovered this empirical law from observations, and later Newton derived it from the law of universal gravitation. It is one of the most elegant and powerful tools in astrophysics. Derivation from Newtonian Mechanics Let a small mass \\( m \\) orbit a massive central body of mass \\( M \\) (e.g., the Earth around the Sun) in a circular orbit of radius \\( r \\) . The gravitational force provides the centripetal acceleration : \\[ F_{\\text{gravity}} = \\frac{G M m}{r^2}, \\quad F_{\\text{centripetal}} = \\frac{m v^2}{r} \\] Equating the two forces: \\[ \\frac{G M m}{r^2} = \\frac{m v^2}{r} \\] Simplifying and solving for orbital speed \\( v \\) : \\[ v^2 = \\frac{G M}{r} \\] The orbital period \\( T \\) is the time to complete one full orbit, which is the circumference divided by speed: \\[ T = \\frac{2\\pi r}{v} \\] Substitute the expression for \\( v \\) : \\[ T = 2\\pi r \\sqrt{\\frac{r}{G M}} = 2\\pi \\sqrt{\\frac{r^3}{G M}} \\] Now squaring both sides: \\[ T^2 = \\frac{4\\pi^2}{G M} \\cdot r^3 \\] This is the mathematical form of Kepler's Third Law : \\[ T^2 \\propto r^3 \\] The proportionality constant depends only on the mass \\( M \\) of the central object. Implications of Kepler's Law Universal Relationship : All bodies orbiting the same central mass follow the same \\( T^2/r^3 \\) ratio. Comparative Analysis : Knowing \\( T \\) and \\( r \\) for one object allows us to predict them for another. Mass Estimation : Rearranging the equation allows for calculating the mass of a star or planet: \\[ M = \\frac{4\\pi^2 r^3}{G T^2} \\] Real-World Examples Example 1: The Moon's Orbit Around Earth Radius: \\( r = 3.84 \\times 10^8 \\) m Period: \\( T = 27.3 \\) days \\( \\approx 2.36 \\times 10^6 \\) s Using Kepler's Law: \\[ T^2 = \\frac{4\\pi^2 r^3}{G M_{\\text{Earth}}} \\] This checks out when we use Earth\u2019s mass \\( M = 5.97 \\times 10^{24} \\, \\text{kg} \\) . \u2609 Example 2: Planets Around the Sun Planet \\( r \\) (AU) \\( T \\) (years) \\( T^2 \\) \\( r^3 \\) Mercury 0.39 0.24 0.0576 0.0593 Earth 1.00 1.00 1.0000 1.0000 Jupiter 5.20 11.86 140.7 140.6 We observe: \\[ \\frac{T^2}{r^3} \\approx \\text{constant} \\] Python Simulation: Numerical Verification import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # m^3 kg^-1 s^-2 M_sun = 1.989e30 # kg # Generate orbital radii from 0.1 AU to 5 AU (converted to meters) AU = 1.496e11 # meters radii = np.linspace(0.1 * AU, 5 * AU, 100) T_squared = (4 * np.pi**2 * radii**3) / (G * M_sun) T_days = np.sqrt(T_squared) / (60 * 60 * 24) # Plot T^2 vs r^3 plt.figure(figsize=(8,6)) plt.plot(radii**3, T_squared, label=r\"$T^2$ vs $r^3$\", color='blue') plt.xlabel(r\"Orbital Radius Cubed ($r^3$) [$\\mathrm{m}^3$]\") plt.ylabel(r\"Orbital Period Squared ($T^2$) [$\\mathrm{s}^2$]\") plt.title(\"Kepler's Third Law Simulation\") plt.grid(True) plt.legend() plt.tight_layout() plt.show() Visualization & Analysis The plot above shows a linear relationship between \\( T^2 \\) and \\( r^3 \\) , confirming the theoretical expectation from Kepler\u2019s Third Law. To quantify: from scipy.stats import linregress slope, intercept, r_value, _, _ = linregress(radii**3, T_squared) print(\"Slope:\", slope) print(\"R^2:\", r_value**2) An \\( R^2 \\) value near 1 confirms an excellent fit. Extension to Elliptical Orbits Kepler originally formulated his third law for elliptical orbits , using the semi-major axis \\( a \\) instead of radius \\( r \\) : \\[ T^2 = \\frac{4\\pi^2 a^3}{G M} \\] This form still holds for non-circular , but bound orbits like those of comets, satellites, and binary stars. The key is to replace radius with semi-major axis . Summary We derived Kepler's Third Law from Newton's gravitation. We confirmed the relationship numerically using Python. We discussed real-world systems where the law is applicable. The law is essential for orbital mechanics , space missions , and planetary astronomy . Further Exploration Model elliptical orbits and test the same law using the semi-major axis. Include perturbations (e.g., other planets' gravity). Explore relativistic corrections (e.g., Mercury\u2019s precession).","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#problem-1","text":"Kepler's Third Law: Orbital Period and Radius","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#motivation","text":"In celestial mechanics, Kepler's Third Law describes a fundamental connection between the orbital period and the orbital radius of a body moving around a central mass. This law allows us to estimate the structure and scale of planetary systems, including our own Solar System. Kepler discovered this empirical law from observations, and later Newton derived it from the law of universal gravitation. It is one of the most elegant and powerful tools in astrophysics.","title":"Motivation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#derivation-from-newtonian-mechanics","text":"Let a small mass \\( m \\) orbit a massive central body of mass \\( M \\) (e.g., the Earth around the Sun) in a circular orbit of radius \\( r \\) . The gravitational force provides the centripetal acceleration : \\[ F_{\\text{gravity}} = \\frac{G M m}{r^2}, \\quad F_{\\text{centripetal}} = \\frac{m v^2}{r} \\] Equating the two forces: \\[ \\frac{G M m}{r^2} = \\frac{m v^2}{r} \\] Simplifying and solving for orbital speed \\( v \\) : \\[ v^2 = \\frac{G M}{r} \\] The orbital period \\( T \\) is the time to complete one full orbit, which is the circumference divided by speed: \\[ T = \\frac{2\\pi r}{v} \\] Substitute the expression for \\( v \\) : \\[ T = 2\\pi r \\sqrt{\\frac{r}{G M}} = 2\\pi \\sqrt{\\frac{r^3}{G M}} \\] Now squaring both sides: \\[ T^2 = \\frac{4\\pi^2}{G M} \\cdot r^3 \\] This is the mathematical form of Kepler's Third Law : \\[ T^2 \\propto r^3 \\] The proportionality constant depends only on the mass \\( M \\) of the central object.","title":"Derivation from Newtonian Mechanics"},{"location":"1%20Physics/2%20Gravity/Problem_1/#implications-of-keplers-law","text":"Universal Relationship : All bodies orbiting the same central mass follow the same \\( T^2/r^3 \\) ratio. Comparative Analysis : Knowing \\( T \\) and \\( r \\) for one object allows us to predict them for another. Mass Estimation : Rearranging the equation allows for calculating the mass of a star or planet: \\[ M = \\frac{4\\pi^2 r^3}{G T^2} \\]","title":"Implications of Kepler's Law"},{"location":"1%20Physics/2%20Gravity/Problem_1/#real-world-examples","text":"","title":"Real-World Examples"},{"location":"1%20Physics/2%20Gravity/Problem_1/#example-1-the-moons-orbit-around-earth","text":"Radius: \\( r = 3.84 \\times 10^8 \\) m Period: \\( T = 27.3 \\) days \\( \\approx 2.36 \\times 10^6 \\) s Using Kepler's Law: \\[ T^2 = \\frac{4\\pi^2 r^3}{G M_{\\text{Earth}}} \\] This checks out when we use Earth\u2019s mass \\( M = 5.97 \\times 10^{24} \\, \\text{kg} \\) .","title":"Example 1: The Moon's Orbit Around Earth"},{"location":"1%20Physics/2%20Gravity/Problem_1/#example-2-planets-around-the-sun","text":"Planet \\( r \\) (AU) \\( T \\) (years) \\( T^2 \\) \\( r^3 \\) Mercury 0.39 0.24 0.0576 0.0593 Earth 1.00 1.00 1.0000 1.0000 Jupiter 5.20 11.86 140.7 140.6 We observe: \\[ \\frac{T^2}{r^3} \\approx \\text{constant} \\]","title":"\u2609 Example 2: Planets Around the Sun"},{"location":"1%20Physics/2%20Gravity/Problem_1/#python-simulation-numerical-verification","text":"import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # m^3 kg^-1 s^-2 M_sun = 1.989e30 # kg # Generate orbital radii from 0.1 AU to 5 AU (converted to meters) AU = 1.496e11 # meters radii = np.linspace(0.1 * AU, 5 * AU, 100) T_squared = (4 * np.pi**2 * radii**3) / (G * M_sun) T_days = np.sqrt(T_squared) / (60 * 60 * 24) # Plot T^2 vs r^3 plt.figure(figsize=(8,6)) plt.plot(radii**3, T_squared, label=r\"$T^2$ vs $r^3$\", color='blue') plt.xlabel(r\"Orbital Radius Cubed ($r^3$) [$\\mathrm{m}^3$]\") plt.ylabel(r\"Orbital Period Squared ($T^2$) [$\\mathrm{s}^2$]\") plt.title(\"Kepler's Third Law Simulation\") plt.grid(True) plt.legend() plt.tight_layout() plt.show()","title":"Python Simulation: Numerical Verification"},{"location":"1%20Physics/2%20Gravity/Problem_1/#visualization-analysis","text":"The plot above shows a linear relationship between \\( T^2 \\) and \\( r^3 \\) , confirming the theoretical expectation from Kepler\u2019s Third Law. To quantify: from scipy.stats import linregress slope, intercept, r_value, _, _ = linregress(radii**3, T_squared) print(\"Slope:\", slope) print(\"R^2:\", r_value**2) An \\( R^2 \\) value near 1 confirms an excellent fit.","title":"Visualization &amp; Analysis"},{"location":"1%20Physics/2%20Gravity/Problem_1/#extension-to-elliptical-orbits","text":"Kepler originally formulated his third law for elliptical orbits , using the semi-major axis \\( a \\) instead of radius \\( r \\) : \\[ T^2 = \\frac{4\\pi^2 a^3}{G M} \\] This form still holds for non-circular , but bound orbits like those of comets, satellites, and binary stars. The key is to replace radius with semi-major axis .","title":"Extension to Elliptical Orbits"},{"location":"1%20Physics/2%20Gravity/Problem_1/#summary","text":"We derived Kepler's Third Law from Newton's gravitation. We confirmed the relationship numerically using Python. We discussed real-world systems where the law is applicable. The law is essential for orbital mechanics , space missions , and planetary astronomy .","title":"Summary"},{"location":"1%20Physics/2%20Gravity/Problem_1/#further-exploration","text":"Model elliptical orbits and test the same law using the semi-major axis. Include perturbations (e.g., other planets' gravity). Explore relativistic corrections (e.g., Mercury\u2019s precession).","title":"Further Exploration"},{"location":"1%20Physics/2%20Gravity/Problem_2/","text":"Problem 2 Cosmic Velocities: Theory, Implementation & Visualizations This project calculates the first , second , and third cosmic velocities for Earth , Mars , and Jupiter , including mathematical derivations , Python code , and visualizations . 1. \ud83c\udf0c Theoretical Background 1.1 First Cosmic Velocity The first cosmic velocity is the minimum speed required to enter orbit around a celestial body. This is based on the balance between centripetal force and gravitational force . Mathematically, it is derived from the following relation: \\[ F_{\\text{centripetal}} = F_{\\text{gravitational}} \\] Where: \\[ \\frac{m v_1^2}{R} = \\frac{G M m}{R^2} \\] Simplifying for \\( v_1 \\) , we get the first cosmic velocity : \\[ v_1 = \\sqrt{\\frac{GM}{R}} \\] Where: - \\( G \\) = Gravitational constant \\( 6.67430 \\times 10^{-11} \\ \\text{m}^3 \\text{kg}^{-1} \\text{s}^{-2} \\) - \\( M \\) = Mass of the celestial body (kg) - \\( R \\) = Radius of the celestial body (m) 1.2 Second Cosmic Velocity The second cosmic velocity is the escape velocity , the speed needed to escape the gravitational pull of the celestial body. This can be derived from the energy conservation between kinetic energy and gravitational potential energy: \\[ E_{\\text{total}} = E_{\\text{kinetic}} + E_{\\text{potential}} \\] Where: \\[ E_{\\text{kinetic}} = \\frac{1}{2} m v^2 \\quad \\text{and} \\quad E_{\\text{potential}} = - \\frac{G M m}{R} \\] Setting total energy to zero for escape: \\[ \\frac{1}{2} m v_2^2 = \\frac{G M m}{R} \\] Simplifying, we find the second cosmic velocity : \\[ v_2 = \\sqrt{\\frac{2GM}{R}} = \\sqrt{2} \\times v_1 \\] 1.3 Third Cosmic Velocity The third cosmic velocity is the speed required to escape the gravitational influence of the solar system , i.e., to escape the Sun\u2019s gravitational pull. This can be determined using the escape velocity from the Sun at a given distance \\( r \\) from the Sun: \\[ v_3 = \\sqrt{v_2^2 + v_{\\text{solar escape}}^2} \\] Where \\( v_{\\text{solar escape}} \\) is the escape velocity from the Sun at the object\u2019s distance: \\[ v_{\\text{solar escape}} = \\sqrt{\\frac{2 G M_{\\text{Sun}}}{r_{\\text{sun}}}} \\] Where: - \\( r_{\\text{sun}} \\) is the distance from the Sun in meters. 2. \ud83d\udcda Constants and Parameters 2.1 Gravitational and Astronomical Constants Parameter Value Description \\( G \\) \\( 6.67430 \\times 10^{-11} \\ \\text{m}^3 \\text{kg}^{-1} \\text{s}^{-2} \\) Gravitational constant \\( M_{\\text{Sun}} \\) \\( 1.989 \\times 10^{30} \\ \\text{kg} \\) Mass of the Sun 1 AU \\( 1.496 \\times 10^{11} \\ \\text{m} \\) Astronomical unit 2.2 Planetary Data Planet Mass \\( M \\) (kg) Radius \\( R \\) (m) Distance to Sun (AU) Earth \\( 5.972 \\times 10^{24} \\) \\( 6.371 \\times 10^6 \\) 1.0 Mars \\( 6.39 \\times 10^{23} \\) \\( 3.3895 \\times 10^6 \\) 1.524 Jupiter \\( 1.898 \\times 10^{27} \\) \\( 6.9911 \\times 10^7 \\) 5.204 3. \ud83e\udde0 Python Code Implementations import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # Gravitational constant (m^3 kg^-1 s^-2) sun_mass = 1.989e30 # Mass of the Sun (kg) AU = 1.496e11 # Astronomical Unit (m) # Planetary data (Mass, Radius, Distance to Sun in AU) bodies = { \"Earth\": (5.972e24, 6.371e6, 1.0), \"Mars\": (6.39e23, 3.3895e6, 1.524), \"Jupiter\": (1.898e27, 6.9911e7, 5.204) } # Function to calculate velocities (v1, v2, v3) def calculate_velocities(mass, radius, distance_to_sun_AU): v1 = np.sqrt(G * mass / radius) v2 = np.sqrt(2) * v1 distance_to_sun = distance_to_sun_AU * AU v_sun_escape = np.sqrt(2 * G * sun_mass / distance_to_sun) v3 = np.sqrt(v2**2 + v_sun_escape**2) return v1, v2, v3 # Results results = {body: calculate_velocities(mass, radius, distance) for body, (mass, radius, distance) in bodies.items()} # Output Results for body, (v1, v2, v3) in results.items(): print(f\"{body}: v1 = {v1/1000:.2f} km/s, v2 = {v2/1000:.2f} km/s, v3 = {v3/1000:.2f} km/s\") # Visualization labels = list(results.keys()) v1_vals = [results[b][0] / 1000 for b in labels] v2_vals = [results[b][1] / 1000 for b in labels] v3_vals = [results[b][2] / 1000 for b in labels] x = np.arange(len(labels)) width = 0.25 fig, ax = plt.subplots(figsize=(8,5)) ax.bar(x - width, v1_vals, width, label='First Cosmic Velocity (v1)') ax.bar(x, v2_vals, width, label='Second Cosmic Velocity (v2)') ax.bar(x + width, v3_vals, width, label='Third Cosmic Velocity (v3)') ax.set_ylabel('Velocity (km/s)') ax.set_title('Cosmic Velocities for Planets') ax.set_xticks(x) ax.set_xticklabels(labels) ax.legend() ax.grid(True) plt.tight_layout() plt.show() Planet First Cosmic Velocity (v1) [km/s] Second Cosmic Velocity (v2) [km/s] Third Cosmic Velocity (v3) [km/s] Earth 7.91 11.18 42.13 Mars 5.03 7.11 34.38 Jupiter 42.12 59.55 66.69","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#cosmic-velocities-theory-implementation-visualizations","text":"This project calculates the first , second , and third cosmic velocities for Earth , Mars , and Jupiter , including mathematical derivations , Python code , and visualizations .","title":"Cosmic Velocities: Theory, Implementation &amp; Visualizations"},{"location":"1%20Physics/2%20Gravity/Problem_2/#1-theoretical-background","text":"","title":"1. \ud83c\udf0c Theoretical Background"},{"location":"1%20Physics/2%20Gravity/Problem_2/#11-first-cosmic-velocity","text":"The first cosmic velocity is the minimum speed required to enter orbit around a celestial body. This is based on the balance between centripetal force and gravitational force . Mathematically, it is derived from the following relation: \\[ F_{\\text{centripetal}} = F_{\\text{gravitational}} \\] Where: \\[ \\frac{m v_1^2}{R} = \\frac{G M m}{R^2} \\] Simplifying for \\( v_1 \\) , we get the first cosmic velocity : \\[ v_1 = \\sqrt{\\frac{GM}{R}} \\] Where: - \\( G \\) = Gravitational constant \\( 6.67430 \\times 10^{-11} \\ \\text{m}^3 \\text{kg}^{-1} \\text{s}^{-2} \\) - \\( M \\) = Mass of the celestial body (kg) - \\( R \\) = Radius of the celestial body (m)","title":"1.1 First Cosmic Velocity"},{"location":"1%20Physics/2%20Gravity/Problem_2/#12-second-cosmic-velocity","text":"The second cosmic velocity is the escape velocity , the speed needed to escape the gravitational pull of the celestial body. This can be derived from the energy conservation between kinetic energy and gravitational potential energy: \\[ E_{\\text{total}} = E_{\\text{kinetic}} + E_{\\text{potential}} \\] Where: \\[ E_{\\text{kinetic}} = \\frac{1}{2} m v^2 \\quad \\text{and} \\quad E_{\\text{potential}} = - \\frac{G M m}{R} \\] Setting total energy to zero for escape: \\[ \\frac{1}{2} m v_2^2 = \\frac{G M m}{R} \\] Simplifying, we find the second cosmic velocity : \\[ v_2 = \\sqrt{\\frac{2GM}{R}} = \\sqrt{2} \\times v_1 \\]","title":"1.2 Second Cosmic Velocity"},{"location":"1%20Physics/2%20Gravity/Problem_2/#13-third-cosmic-velocity","text":"The third cosmic velocity is the speed required to escape the gravitational influence of the solar system , i.e., to escape the Sun\u2019s gravitational pull. This can be determined using the escape velocity from the Sun at a given distance \\( r \\) from the Sun: \\[ v_3 = \\sqrt{v_2^2 + v_{\\text{solar escape}}^2} \\] Where \\( v_{\\text{solar escape}} \\) is the escape velocity from the Sun at the object\u2019s distance: \\[ v_{\\text{solar escape}} = \\sqrt{\\frac{2 G M_{\\text{Sun}}}{r_{\\text{sun}}}} \\] Where: - \\( r_{\\text{sun}} \\) is the distance from the Sun in meters.","title":"1.3 Third Cosmic Velocity"},{"location":"1%20Physics/2%20Gravity/Problem_2/#2-constants-and-parameters","text":"","title":"2. \ud83d\udcda Constants and Parameters"},{"location":"1%20Physics/2%20Gravity/Problem_2/#21-gravitational-and-astronomical-constants","text":"Parameter Value Description \\( G \\) \\( 6.67430 \\times 10^{-11} \\ \\text{m}^3 \\text{kg}^{-1} \\text{s}^{-2} \\) Gravitational constant \\( M_{\\text{Sun}} \\) \\( 1.989 \\times 10^{30} \\ \\text{kg} \\) Mass of the Sun 1 AU \\( 1.496 \\times 10^{11} \\ \\text{m} \\) Astronomical unit","title":"2.1 Gravitational and Astronomical Constants"},{"location":"1%20Physics/2%20Gravity/Problem_2/#22-planetary-data","text":"Planet Mass \\( M \\) (kg) Radius \\( R \\) (m) Distance to Sun (AU) Earth \\( 5.972 \\times 10^{24} \\) \\( 6.371 \\times 10^6 \\) 1.0 Mars \\( 6.39 \\times 10^{23} \\) \\( 3.3895 \\times 10^6 \\) 1.524 Jupiter \\( 1.898 \\times 10^{27} \\) \\( 6.9911 \\times 10^7 \\) 5.204","title":"2.2 Planetary Data"},{"location":"1%20Physics/2%20Gravity/Problem_2/#3-python-code-implementations","text":"import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # Gravitational constant (m^3 kg^-1 s^-2) sun_mass = 1.989e30 # Mass of the Sun (kg) AU = 1.496e11 # Astronomical Unit (m) # Planetary data (Mass, Radius, Distance to Sun in AU) bodies = { \"Earth\": (5.972e24, 6.371e6, 1.0), \"Mars\": (6.39e23, 3.3895e6, 1.524), \"Jupiter\": (1.898e27, 6.9911e7, 5.204) } # Function to calculate velocities (v1, v2, v3) def calculate_velocities(mass, radius, distance_to_sun_AU): v1 = np.sqrt(G * mass / radius) v2 = np.sqrt(2) * v1 distance_to_sun = distance_to_sun_AU * AU v_sun_escape = np.sqrt(2 * G * sun_mass / distance_to_sun) v3 = np.sqrt(v2**2 + v_sun_escape**2) return v1, v2, v3 # Results results = {body: calculate_velocities(mass, radius, distance) for body, (mass, radius, distance) in bodies.items()} # Output Results for body, (v1, v2, v3) in results.items(): print(f\"{body}: v1 = {v1/1000:.2f} km/s, v2 = {v2/1000:.2f} km/s, v3 = {v3/1000:.2f} km/s\") # Visualization labels = list(results.keys()) v1_vals = [results[b][0] / 1000 for b in labels] v2_vals = [results[b][1] / 1000 for b in labels] v3_vals = [results[b][2] / 1000 for b in labels] x = np.arange(len(labels)) width = 0.25 fig, ax = plt.subplots(figsize=(8,5)) ax.bar(x - width, v1_vals, width, label='First Cosmic Velocity (v1)') ax.bar(x, v2_vals, width, label='Second Cosmic Velocity (v2)') ax.bar(x + width, v3_vals, width, label='Third Cosmic Velocity (v3)') ax.set_ylabel('Velocity (km/s)') ax.set_title('Cosmic Velocities for Planets') ax.set_xticks(x) ax.set_xticklabels(labels) ax.legend() ax.grid(True) plt.tight_layout() plt.show() Planet First Cosmic Velocity (v1) [km/s] Second Cosmic Velocity (v2) [km/s] Third Cosmic Velocity (v3) [km/s] Earth 7.91 11.18 42.13 Mars 5.03 7.11 34.38 Jupiter 42.12 59.55 66.69","title":"3. \ud83e\udde0 Python Code Implementations"},{"location":"1%20Physics/2%20Gravity/Problem_3/","text":"# Problem 3 # Trajectories of a Freely Released Payload Near Earth Motivation When a payload is released from a spacecraft near Earth, its trajectory depends on the initial velocity, position, and the gravitational forces acting on it. These trajectories are crucial for understanding how objects behave in space and for planning satellite deployments, reentry missions, and escape scenarios. Physics Concepts Newton's Law of Gravitation The gravitational force acting on a payload is given by the following equation: \\[ \\vec{F} = -G \\frac{M m}{r^2} \\hat{r} \\] Where: - \\( G = 6.674 \\times 10^{-11} \\, \\text{Nm}^2/\\text{kg}^2 \\) \u2014 Gravitational constant - \\( M \\) \u2014 Earth's mass - \\( m \\) \u2014 Payload's mass - \\( r \\) \u2014 Distance from Earth's center - \\( \\hat{r} \\) \u2014 Unit vector pointing from Earth to the payload Escape Velocity The escape velocity is the minimum velocity needed to break free from Earth's gravitational field: \\[ v_{\\text{esc}} = \\sqrt{\\frac{2GM}{r}} \\] At Earth's surface, the escape velocity is approximately 11.2 km/s . Numerical Simulation in Python Imports and Constants We begin by importing necessary libraries and defining key constants. import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # Gravitational constant [m^3 kg^-1 s^-2] M = 5.972e24 # Mass of Earth [kg] R_earth = 6.371e6 # Radius of Earth [m] # Initial Conditions In this section, we define the initial conditions for the payload, which includes its altitude, initial position, and initial velocity. # Initial conditions altitude = 300e3 # Altitude from Earth's surface (300 km) r0 = np.array([R_earth + altitude, 0]) # Initial position vector (x, y) v0 = np.array([0, 7700]) # Initial velocity vector (vx, vy) in m/s Time Settings In this section, we define the time settings for the simulation, including the time step ( dt ) and the total simulation time ( T ). # Time settings dt = 1 # Time step (seconds) T = 10000 # Total simulation time (seconds) steps = int(T / dt) # Number of time steps Simulation Function Now, let\u2019s implement the Euler method to numerically integrate the equations of motion and simulate the trajectory of the payload. # Simulation function def simulate(r0, v0, dt, steps): r = np.zeros((steps, 2)) # Position array v = np.zeros((steps, 2)) # Velocity array r[0] = r0 # Set initial position v[0] = v0 # Set initial velocity for i in range(steps - 1): distance = np.linalg.norm(r[i]) # Calculate distance from Earth\u2019s center # Check if the payload has hit the Earth's surface if distance < R_earth: print(f\"Impact with Earth at step {i}, time {i * dt} s\") return r[:i+1] # Calculate the acceleration due to gravity a = -G * M * r[i] / distance**3 v[i + 1] = v[i] + a * dt # Update velocity r[i + 1] = r[i] + v[i + 1] * dt # Update position return r # Return the trajectory Visualization Now, we will run the simulation and plot the resulting trajectory of the payload. # Run the simulation trajectory = simulate(r0, v0, dt, steps) # Plotting the trajectory plt.figure(figsize=(8, 8)) plt.plot(trajectory[:, 0], trajectory[:, 1], label=\"Payload Trajectory\") # Draw Earth earth = plt.Circle((0, 0), R_earth, color='blue', alpha=0.5, label=\"Earth\") plt.gca().add_artist(earth) # Plot formatting plt.xlabel(\"x [m]\") plt.ylabel(\"y [m]\") plt.title(\"Trajectory of a Freely Released Payload\") plt.axis(\"equal\") plt.grid(True) plt.legend() plt.show() Trajectory Types Based on Initial Speed Initial Speed (m/s) Outcome < 7000 Falls back to Earth \u2248 7670 Circular orbit 7000\u201311000 Elliptical orbit \u2248 11200 Parabolic escape > 11200 Hyperbolic escape Conclusion In this project, we modeled the gravitational motion of a payload near Earth and simulated its trajectory using the Euler method . The key takeaways include: Simulation : We calculated the trajectory of a freely released payload, starting at a specific altitude with a given initial velocity. We used the Euler method for numerical integration of the motion under Earth's gravity. Trajectory Types : Based on the initial velocity, we observed different types of trajectories: If the velocity is too low, the payload falls back to Earth. If the velocity is high enough, the payload enters a stable orbit or escapes Earth's gravity. The payload's path could be parabolic, elliptical, or hyperbolic depending on its initial conditions. Visualization : Using matplotlib , we visualized the trajectory of the payload, showing its path relative to Earth\u2019s surface. The simulation results provide a clear understanding of how initial conditions like altitude and velocity affect the trajectory. Real-World Applications : This model can be applied to space missions, satellite deployments, or reentry predictions. Understanding the physics behind these trajectories is vital for designing successful space missions and ensuring the safety of payloads.","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#motivation","text":"When a payload is released from a spacecraft near Earth, its trajectory depends on the initial velocity, position, and the gravitational forces acting on it. These trajectories are crucial for understanding how objects behave in space and for planning satellite deployments, reentry missions, and escape scenarios.","title":"Motivation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#physics-concepts","text":"","title":"Physics Concepts"},{"location":"1%20Physics/2%20Gravity/Problem_3/#newtons-law-of-gravitation","text":"The gravitational force acting on a payload is given by the following equation: \\[ \\vec{F} = -G \\frac{M m}{r^2} \\hat{r} \\] Where: - \\( G = 6.674 \\times 10^{-11} \\, \\text{Nm}^2/\\text{kg}^2 \\) \u2014 Gravitational constant - \\( M \\) \u2014 Earth's mass - \\( m \\) \u2014 Payload's mass - \\( r \\) \u2014 Distance from Earth's center - \\( \\hat{r} \\) \u2014 Unit vector pointing from Earth to the payload","title":"Newton's Law of Gravitation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#escape-velocity","text":"The escape velocity is the minimum velocity needed to break free from Earth's gravitational field: \\[ v_{\\text{esc}} = \\sqrt{\\frac{2GM}{r}} \\] At Earth's surface, the escape velocity is approximately 11.2 km/s .","title":"Escape Velocity"},{"location":"1%20Physics/2%20Gravity/Problem_3/#numerical-simulation-in-python","text":"","title":"Numerical Simulation in Python"},{"location":"1%20Physics/2%20Gravity/Problem_3/#imports-and-constants","text":"We begin by importing necessary libraries and defining key constants. import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # Gravitational constant [m^3 kg^-1 s^-2] M = 5.972e24 # Mass of Earth [kg] R_earth = 6.371e6 # Radius of Earth [m] # Initial Conditions In this section, we define the initial conditions for the payload, which includes its altitude, initial position, and initial velocity. # Initial conditions altitude = 300e3 # Altitude from Earth's surface (300 km) r0 = np.array([R_earth + altitude, 0]) # Initial position vector (x, y) v0 = np.array([0, 7700]) # Initial velocity vector (vx, vy) in m/s","title":"Imports and Constants"},{"location":"1%20Physics/2%20Gravity/Problem_3/#time-settings","text":"In this section, we define the time settings for the simulation, including the time step ( dt ) and the total simulation time ( T ). # Time settings dt = 1 # Time step (seconds) T = 10000 # Total simulation time (seconds) steps = int(T / dt) # Number of time steps","title":"Time Settings"},{"location":"1%20Physics/2%20Gravity/Problem_3/#simulation-function","text":"Now, let\u2019s implement the Euler method to numerically integrate the equations of motion and simulate the trajectory of the payload. # Simulation function def simulate(r0, v0, dt, steps): r = np.zeros((steps, 2)) # Position array v = np.zeros((steps, 2)) # Velocity array r[0] = r0 # Set initial position v[0] = v0 # Set initial velocity for i in range(steps - 1): distance = np.linalg.norm(r[i]) # Calculate distance from Earth\u2019s center # Check if the payload has hit the Earth's surface if distance < R_earth: print(f\"Impact with Earth at step {i}, time {i * dt} s\") return r[:i+1] # Calculate the acceleration due to gravity a = -G * M * r[i] / distance**3 v[i + 1] = v[i] + a * dt # Update velocity r[i + 1] = r[i] + v[i + 1] * dt # Update position return r # Return the trajectory","title":"Simulation Function"},{"location":"1%20Physics/2%20Gravity/Problem_3/#visualization","text":"Now, we will run the simulation and plot the resulting trajectory of the payload. # Run the simulation trajectory = simulate(r0, v0, dt, steps) # Plotting the trajectory plt.figure(figsize=(8, 8)) plt.plot(trajectory[:, 0], trajectory[:, 1], label=\"Payload Trajectory\") # Draw Earth earth = plt.Circle((0, 0), R_earth, color='blue', alpha=0.5, label=\"Earth\") plt.gca().add_artist(earth) # Plot formatting plt.xlabel(\"x [m]\") plt.ylabel(\"y [m]\") plt.title(\"Trajectory of a Freely Released Payload\") plt.axis(\"equal\") plt.grid(True) plt.legend() plt.show()","title":"Visualization"},{"location":"1%20Physics/2%20Gravity/Problem_3/#trajectory-types-based-on-initial-speed","text":"Initial Speed (m/s) Outcome < 7000 Falls back to Earth \u2248 7670 Circular orbit 7000\u201311000 Elliptical orbit \u2248 11200 Parabolic escape > 11200 Hyperbolic escape","title":"Trajectory Types Based on Initial Speed"},{"location":"1%20Physics/2%20Gravity/Problem_3/#conclusion","text":"In this project, we modeled the gravitational motion of a payload near Earth and simulated its trajectory using the Euler method . The key takeaways include: Simulation : We calculated the trajectory of a freely released payload, starting at a specific altitude with a given initial velocity. We used the Euler method for numerical integration of the motion under Earth's gravity. Trajectory Types : Based on the initial velocity, we observed different types of trajectories: If the velocity is too low, the payload falls back to Earth. If the velocity is high enough, the payload enters a stable orbit or escapes Earth's gravity. The payload's path could be parabolic, elliptical, or hyperbolic depending on its initial conditions. Visualization : Using matplotlib , we visualized the trajectory of the payload, showing its path relative to Earth\u2019s surface. The simulation results provide a clear understanding of how initial conditions like altitude and velocity affect the trajectory. Real-World Applications : This model can be applied to space missions, satellite deployments, or reentry predictions. Understanding the physics behind these trajectories is vital for designing successful space missions and ensuring the safety of payloads.","title":"Conclusion"},{"location":"1%20Physics/3%20Waves/Problem_1/","text":"Problem 1 Interference of Circular Waves from Square-Arranged Point Sources A Theoretical and Computational Study in 2D Water Wave Superposition 1. Introduction Wave interference lies at the heart of wave physics. It refers to the phenomenon where two or more wavefronts overlap and combine to form a new wave pattern. On a water surface, circular waves from multiple point sources can interact in visually striking ways\u2014forming alternating patterns of constructive and destructive interference . This document investigates the superposition of water waves emitted from four identical, coherent sources arranged in a square configuration . Using the wave equation in cylindrical coordinates and Python-based simulation, we model, visualize, and analyze the resulting interference pattern . 2. Theoretical Background 2.1 Wave from a Single Point Source The displacement \\( \\eta \\) of a water surface at time \\( t \\) and position \\( (x, y) \\) , due to a wave originating from a point source at \\( (x_0, y_0) \\) , is given by: \\[ \\eta(x, y, t) = \\frac{A}{r} \\cos(kr - \\omega t + \\phi) \\] Where: \\( A \\) : amplitude of the wave, \\( r = \\sqrt{(x - x_0)^2 + (y - y_0)^2} \\) : radial distance to source, \\( k = \\frac{2\\pi}{\\lambda} \\) : wave number (with \\( \\lambda \\) wavelength), \\( \\omega = 2\\pi f \\) : angular frequency (with \\( f \\) frequency), \\( \\phi \\) : phase constant, \\( t \\) : time. Note: The \\( \\frac{A}{r} \\) term models radial energy dispersion on a 2D surface. This simulates the realistic drop in amplitude with distance. 2.2 Superposition of Multiple Sources If there are \\( N \\) identical sources located at positions \\( (x_i, y_i) \\) , the total displacement is: \\[ \\eta_{\\text{total}}(x, y, t) = \\sum_{i=1}^{N} \\frac{A}{r_i} \\cos(kr_i - \\omega t + \\phi) \\] Where each \\( r_i = \\sqrt{(x - x_i)^2 + (y - y_i)^2} \\) is the distance from point \\( (x, y) \\) to source \\( i \\) . The interference pattern is determined by the phase differences between these cosine terms: Constructive interference : \\( kr_i - kr_j = 2\\pi n \\) Destructive interference : \\( kr_i - kr_j = (2n+1)\\pi \\) for integer \\( n \\) . 2.3 Phase Matching & Interference Zones For two waves: \\[ \\eta_1 = \\frac{A}{r_1} \\cos(kr_1 - \\omega t), \\quad \\eta_2 = \\frac{A}{r_2} \\cos(kr_2 - \\omega t) \\] The total displacement: \\[ \\eta = \\eta_1 + \\eta_2 = \\frac{A}{r_1} \\cos(kr_1 - \\omega t) + \\frac{A}{r_2} \\cos(kr_2 - \\omega t) \\] Using the trigonometric identity: \\[ \\cos \\alpha + \\cos \\beta = 2 \\cos\\left(\\frac{\\alpha + \\beta}{2}\\right) \\cos\\left(\\frac{\\alpha - \\beta}{2}\\right) \\] We obtain an interference envelope : \\[ \\eta = 2A_{\\text{eff}} \\cos\\left(\\frac{k(r_1 - r_2)}{2} \\right) \\cdot \\cos\\left( \\frac{k(r_1 + r_2)}{2} - \\omega t \\right) \\] Which reveals oscillating interference fringes governed by the path difference \\( r_1 - r_2 \\) . 3. Geometry of the Setup We use a square of side length \\( L = 2 \\) , centered at the origin. The sources are located at: \\( S_1 = (-1, -1) \\) \\( S_2 = (-1, +1) \\) \\( S_3 = (+1, -1) \\) \\( S_4 = (+1, +1) \\) These sources are: Coherent (same frequency), In-phase (same \\( \\phi = 0 \\) ), Identical in amplitude and wavelength. 4. Python Simulation Code import numpy as np import matplotlib.pyplot as plt # --- Parameters --- A = 1.0 wavelength = 1.0 frequency = 1.0 phi = 0 k = 2 * np.pi / wavelength omega = 2 * np.pi * frequency t = 0 # --- Grid --- x = np.linspace(-5, 5, 500) y = np.linspace(-5, 5, 500) X, Y = np.meshgrid(x, y) # --- Source Positions (Square) --- L = 2.0 sources = [(-1, -1), (-1, 1), (1, -1), (1, 1)] # --- Superposition of Waves --- eta_total = np.zeros_like(X) for (x0, y0) in sources: R = np.sqrt((X - x0)**2 + (Y - y0)**2) + 1e-6 # Avoid singularity at R=0 eta = (A / R) * np.cos(k * R - omega * t + phi) eta_total += eta # --- Plot --- plt.figure(figsize=(10, 8)) plt.pcolormesh(X, Y, eta_total, shading='auto', cmap='seismic') plt.colorbar(label='Surface Displacement \u03b7') plt.title(\"Interference of 4 Point Sources (Square)\") plt.xlabel(\"x position\") plt.ylabel(\"y position\") plt.axis('equal') plt.tight_layout() plt.show() 5. Analysis of Results Constructive Interference Occurs when the path difference from any two sources is an integer multiple of \\( \\lambda \\) : \\[ \\Delta r = n \\lambda \\] Produces bright fringes in the plot. Destructive Interference Occurs when: \\[ \\Delta r = (n + \\frac{1}{2}) \\lambda \\] These appear as dark regions . Symmetry The interference pattern exhibits 4-fold rotational symmetry due to the square geometry. Patterns are stationary since all sources oscillate in phase. 6. Experimental Extensions Time Evolution To animate the pattern over time, iterate over t : for t in np.linspace(0, 2*np.pi, 100): ... Other Polygons Equilateral triangle : Use 3 points at \\( 120^\\circ \\) intervals. Pentagon : Use polar coordinates: N = 5 R = 2 sources = [(R * np.cos(2*np.pi*i/N), R * np.sin(2*np.pi*i/N)) for i in range(N)] Arbitrary Phases Vary \\( \\phi \\) per source to simulate phase delays or non-coherent waves . 7. Generalization The method above can be generalized to any N sources located at arbitrary positions \\( (x_i, y_i) \\) , possibly with varying phase offsets \\( \\phi_i \\) : \\[ \\eta(x, y, t) = \\sum_{i=1}^{N} \\frac{A}{r_i} \\cos(kr_i - \\omega t + \\phi_i) \\] This enables modeling of more complex systems, including: Laser interference, Sound field simulations, Quantum wavefunction interference. 8. Suggested Folder Structure wave_simulation_square/ \u251c\u2500\u2500 interference_square.md \u251c\u2500\u2500 simulation_square.py \u251c\u2500\u2500 images/ \u2502 \u2514\u2500\u2500 pattern_snapshot.png \u251c\u2500\u2500 animation/ \u2502 \u2514\u2500\u2500 gif_frames/ \u2514\u2500\u2500 README.md 9. Conclusion In this study, we investigated the interference of circular water waves emitted from four coherent sources positioned at the vertices of a square. By employing the principle of superposition , we derived and simulated the resulting surface displacement: \\[ \\eta_{\\text{total}}(x, y, t) = \\sum_{i=1}^{N} \\frac{A}{r_i} \\cos(k r_i - \\omega t + \\phi_i) \\] where each \\( r_i \\) is the distance from the \\(i^{th}\\) source to the point \\( (x, y) \\) , and all sources share common amplitude \\( A \\) , wave number \\( k \\) , frequency \\( \\omega \\) , and coherent phase differences. Key Findings: The interference pattern exhibits high symmetry , due to the square configuration. Constructive interference appears when the path differences between sources align to integer multiples of the wavelength \\( \\lambda \\) . Destructive interference results from phase differences of odd multiples of \\( \\pi \\) , forming nodal lines (regions of cancellation). The amplitude decays with distance \\( \\left(\\propto \\frac{1}{r}\\right) \\) , modeling physical energy dissipation in water. The overall displacement field is spatially complex but temporally periodic , governed by the cosine term involving time \\( t \\) . Physical Implications: This simulation reinforces key wave physics concepts such as: The superposition principle in linear systems, The effects of phase coherence and source arrangement, The formation of nodal and antinodal lines , Realistic amplitude decay over space. Potential Extensions: Varying the number of sources or changing the polygon (triangle, pentagon, etc.) Introducing initial phase differences between emitters Adding obstacles or barriers to study reflection and diffraction Extending the model to simulate optical , acoustic , or quantum interference phenomena Ultimately, this project demonstrates the effectiveness of combining analytical wave modeling with computational visualization to explore fundamental physical behaviors in wave systems.","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#interference-of-circular-waves-from-square-arranged-point-sources","text":"","title":"Interference of Circular Waves from Square-Arranged Point Sources"},{"location":"1%20Physics/3%20Waves/Problem_1/#a-theoretical-and-computational-study-in-2d-water-wave-superposition","text":"","title":"A Theoretical and Computational Study in 2D Water Wave Superposition"},{"location":"1%20Physics/3%20Waves/Problem_1/#1-introduction","text":"Wave interference lies at the heart of wave physics. It refers to the phenomenon where two or more wavefronts overlap and combine to form a new wave pattern. On a water surface, circular waves from multiple point sources can interact in visually striking ways\u2014forming alternating patterns of constructive and destructive interference . This document investigates the superposition of water waves emitted from four identical, coherent sources arranged in a square configuration . Using the wave equation in cylindrical coordinates and Python-based simulation, we model, visualize, and analyze the resulting interference pattern .","title":"1. Introduction"},{"location":"1%20Physics/3%20Waves/Problem_1/#2-theoretical-background","text":"","title":"2. Theoretical Background"},{"location":"1%20Physics/3%20Waves/Problem_1/#21-wave-from-a-single-point-source","text":"The displacement \\( \\eta \\) of a water surface at time \\( t \\) and position \\( (x, y) \\) , due to a wave originating from a point source at \\( (x_0, y_0) \\) , is given by: \\[ \\eta(x, y, t) = \\frac{A}{r} \\cos(kr - \\omega t + \\phi) \\] Where: \\( A \\) : amplitude of the wave, \\( r = \\sqrt{(x - x_0)^2 + (y - y_0)^2} \\) : radial distance to source, \\( k = \\frac{2\\pi}{\\lambda} \\) : wave number (with \\( \\lambda \\) wavelength), \\( \\omega = 2\\pi f \\) : angular frequency (with \\( f \\) frequency), \\( \\phi \\) : phase constant, \\( t \\) : time. Note: The \\( \\frac{A}{r} \\) term models radial energy dispersion on a 2D surface. This simulates the realistic drop in amplitude with distance.","title":"2.1 Wave from a Single Point Source"},{"location":"1%20Physics/3%20Waves/Problem_1/#22-superposition-of-multiple-sources","text":"If there are \\( N \\) identical sources located at positions \\( (x_i, y_i) \\) , the total displacement is: \\[ \\eta_{\\text{total}}(x, y, t) = \\sum_{i=1}^{N} \\frac{A}{r_i} \\cos(kr_i - \\omega t + \\phi) \\] Where each \\( r_i = \\sqrt{(x - x_i)^2 + (y - y_i)^2} \\) is the distance from point \\( (x, y) \\) to source \\( i \\) . The interference pattern is determined by the phase differences between these cosine terms: Constructive interference : \\( kr_i - kr_j = 2\\pi n \\) Destructive interference : \\( kr_i - kr_j = (2n+1)\\pi \\) for integer \\( n \\) .","title":"2.2 Superposition of Multiple Sources"},{"location":"1%20Physics/3%20Waves/Problem_1/#23-phase-matching-interference-zones","text":"For two waves: \\[ \\eta_1 = \\frac{A}{r_1} \\cos(kr_1 - \\omega t), \\quad \\eta_2 = \\frac{A}{r_2} \\cos(kr_2 - \\omega t) \\] The total displacement: \\[ \\eta = \\eta_1 + \\eta_2 = \\frac{A}{r_1} \\cos(kr_1 - \\omega t) + \\frac{A}{r_2} \\cos(kr_2 - \\omega t) \\] Using the trigonometric identity: \\[ \\cos \\alpha + \\cos \\beta = 2 \\cos\\left(\\frac{\\alpha + \\beta}{2}\\right) \\cos\\left(\\frac{\\alpha - \\beta}{2}\\right) \\] We obtain an interference envelope : \\[ \\eta = 2A_{\\text{eff}} \\cos\\left(\\frac{k(r_1 - r_2)}{2} \\right) \\cdot \\cos\\left( \\frac{k(r_1 + r_2)}{2} - \\omega t \\right) \\] Which reveals oscillating interference fringes governed by the path difference \\( r_1 - r_2 \\) .","title":"2.3 Phase Matching &amp; Interference Zones"},{"location":"1%20Physics/3%20Waves/Problem_1/#3-geometry-of-the-setup","text":"We use a square of side length \\( L = 2 \\) , centered at the origin. The sources are located at: \\( S_1 = (-1, -1) \\) \\( S_2 = (-1, +1) \\) \\( S_3 = (+1, -1) \\) \\( S_4 = (+1, +1) \\) These sources are: Coherent (same frequency), In-phase (same \\( \\phi = 0 \\) ), Identical in amplitude and wavelength.","title":"3. Geometry of the Setup"},{"location":"1%20Physics/3%20Waves/Problem_1/#4-python-simulation-code","text":"import numpy as np import matplotlib.pyplot as plt # --- Parameters --- A = 1.0 wavelength = 1.0 frequency = 1.0 phi = 0 k = 2 * np.pi / wavelength omega = 2 * np.pi * frequency t = 0 # --- Grid --- x = np.linspace(-5, 5, 500) y = np.linspace(-5, 5, 500) X, Y = np.meshgrid(x, y) # --- Source Positions (Square) --- L = 2.0 sources = [(-1, -1), (-1, 1), (1, -1), (1, 1)] # --- Superposition of Waves --- eta_total = np.zeros_like(X) for (x0, y0) in sources: R = np.sqrt((X - x0)**2 + (Y - y0)**2) + 1e-6 # Avoid singularity at R=0 eta = (A / R) * np.cos(k * R - omega * t + phi) eta_total += eta # --- Plot --- plt.figure(figsize=(10, 8)) plt.pcolormesh(X, Y, eta_total, shading='auto', cmap='seismic') plt.colorbar(label='Surface Displacement \u03b7') plt.title(\"Interference of 4 Point Sources (Square)\") plt.xlabel(\"x position\") plt.ylabel(\"y position\") plt.axis('equal') plt.tight_layout() plt.show()","title":"4. Python Simulation Code"},{"location":"1%20Physics/3%20Waves/Problem_1/#5-analysis-of-results","text":"","title":"5. Analysis of Results"},{"location":"1%20Physics/3%20Waves/Problem_1/#constructive-interference","text":"Occurs when the path difference from any two sources is an integer multiple of \\( \\lambda \\) : \\[ \\Delta r = n \\lambda \\] Produces bright fringes in the plot.","title":"Constructive Interference"},{"location":"1%20Physics/3%20Waves/Problem_1/#destructive-interference","text":"Occurs when: \\[ \\Delta r = (n + \\frac{1}{2}) \\lambda \\] These appear as dark regions .","title":"Destructive Interference"},{"location":"1%20Physics/3%20Waves/Problem_1/#symmetry","text":"The interference pattern exhibits 4-fold rotational symmetry due to the square geometry. Patterns are stationary since all sources oscillate in phase.","title":"Symmetry"},{"location":"1%20Physics/3%20Waves/Problem_1/#6-experimental-extensions","text":"","title":"6. Experimental Extensions"},{"location":"1%20Physics/3%20Waves/Problem_1/#time-evolution","text":"To animate the pattern over time, iterate over t : for t in np.linspace(0, 2*np.pi, 100): ...","title":"Time Evolution"},{"location":"1%20Physics/3%20Waves/Problem_1/#other-polygons","text":"Equilateral triangle : Use 3 points at \\( 120^\\circ \\) intervals. Pentagon : Use polar coordinates: N = 5 R = 2 sources = [(R * np.cos(2*np.pi*i/N), R * np.sin(2*np.pi*i/N)) for i in range(N)]","title":"Other Polygons"},{"location":"1%20Physics/3%20Waves/Problem_1/#arbitrary-phases","text":"Vary \\( \\phi \\) per source to simulate phase delays or non-coherent waves .","title":"Arbitrary Phases"},{"location":"1%20Physics/3%20Waves/Problem_1/#7-generalization","text":"The method above can be generalized to any N sources located at arbitrary positions \\( (x_i, y_i) \\) , possibly with varying phase offsets \\( \\phi_i \\) : \\[ \\eta(x, y, t) = \\sum_{i=1}^{N} \\frac{A}{r_i} \\cos(kr_i - \\omega t + \\phi_i) \\] This enables modeling of more complex systems, including: Laser interference, Sound field simulations, Quantum wavefunction interference.","title":"7. Generalization"},{"location":"1%20Physics/3%20Waves/Problem_1/#8-suggested-folder-structure","text":"wave_simulation_square/ \u251c\u2500\u2500 interference_square.md \u251c\u2500\u2500 simulation_square.py \u251c\u2500\u2500 images/ \u2502 \u2514\u2500\u2500 pattern_snapshot.png \u251c\u2500\u2500 animation/ \u2502 \u2514\u2500\u2500 gif_frames/ \u2514\u2500\u2500 README.md","title":"8. Suggested Folder Structure"},{"location":"1%20Physics/3%20Waves/Problem_1/#9-conclusion","text":"In this study, we investigated the interference of circular water waves emitted from four coherent sources positioned at the vertices of a square. By employing the principle of superposition , we derived and simulated the resulting surface displacement: \\[ \\eta_{\\text{total}}(x, y, t) = \\sum_{i=1}^{N} \\frac{A}{r_i} \\cos(k r_i - \\omega t + \\phi_i) \\] where each \\( r_i \\) is the distance from the \\(i^{th}\\) source to the point \\( (x, y) \\) , and all sources share common amplitude \\( A \\) , wave number \\( k \\) , frequency \\( \\omega \\) , and coherent phase differences.","title":"9. Conclusion"},{"location":"1%20Physics/3%20Waves/Problem_1/#key-findings","text":"The interference pattern exhibits high symmetry , due to the square configuration. Constructive interference appears when the path differences between sources align to integer multiples of the wavelength \\( \\lambda \\) . Destructive interference results from phase differences of odd multiples of \\( \\pi \\) , forming nodal lines (regions of cancellation). The amplitude decays with distance \\( \\left(\\propto \\frac{1}{r}\\right) \\) , modeling physical energy dissipation in water. The overall displacement field is spatially complex but temporally periodic , governed by the cosine term involving time \\( t \\) .","title":"Key Findings:"},{"location":"1%20Physics/3%20Waves/Problem_1/#physical-implications","text":"This simulation reinforces key wave physics concepts such as: The superposition principle in linear systems, The effects of phase coherence and source arrangement, The formation of nodal and antinodal lines , Realistic amplitude decay over space.","title":"Physical Implications:"},{"location":"1%20Physics/3%20Waves/Problem_1/#potential-extensions","text":"Varying the number of sources or changing the polygon (triangle, pentagon, etc.) Introducing initial phase differences between emitters Adding obstacles or barriers to study reflection and diffraction Extending the model to simulate optical , acoustic , or quantum interference phenomena Ultimately, this project demonstrates the effectiveness of combining analytical wave modeling with computational visualization to explore fundamental physical behaviors in wave systems.","title":"Potential Extensions:"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/","text":"Problem 1 Electromagnetism: Lorentz Force \u2014 Theory and Simulation Motivation The Lorentz force governs how charged particles move under electric and magnetic fields. This concept is foundational in: Plasma physics (e.g., fusion reactors) Particle accelerators (e.g., cyclotrons) Astrophysics (e.g., solar winds, cosmic rays) Mass spectrometry Simulating this force allows us to understand real-world applications and visualize intricate particle trajectories. This document explores applications, mathematical modeling, and numerical simulation of the Lorentz force using Python. Fundamental Formula The Lorentz force is the total electromagnetic force acting on a charged particle: \\[ \\vec{F} = q\\vec{E} + q\\vec{v} \\times \\vec{B} \\] Where: \\(\\vec{F}\\) : Force (N) \\(q\\) : Charge (C) \\(\\vec{E}\\) : Electric field (V/m) \\(\\vec{v}\\) : Velocity (m/s) \\(\\vec{B}\\) : Magnetic field (T) The first term represents the electric force, and the second term is the magnetic force. If \\(\\vec{E} = 0\\) , the motion is purely influenced by the magnetic field. Applications of Lorentz Force System Role of Lorentz Force Particle Accelerators Provides centripetal force for circular particle motion Mass Spectrometers Differentiates ions by mass-to-charge ratio \\(\\frac{m}{q}\\) Magnetic Traps (Penning Traps) Confinement of charged particles in small regions Astrophysics Affects charged particles in cosmic and solar environments These systems rely on our ability to control particle paths using electric and magnetic fields. Useful Derived Quantities Larmor Radius : $$ r_L = \\frac{mv_\\perp}{qB} $$ Describes the radius of circular motion perpendicular to a magnetic field. Cyclotron Frequency : $$ \\omega_c = \\frac{qB}{m} $$ The angular frequency of a particle's circular motion in a uniform magnetic field. Drift Velocity in Crossed Fields : $$ \\vec{v}_d = \\frac{\\vec{E} \\times \\vec{B}}{B^2} $$ Indicates how particles drift when electric and magnetic fields are perpendicular. Example 1: Circular Motion in a Magnetic Field Let a particle have: \\(q = 1.6 \\times 10^{-19} \\ \\mathrm{C}\\) \\(m = 9.1 \\times 10^{-31} \\ \\mathrm{kg}\\) \\(\\vec{v} = (1 \\times 10^6, 0, 0) \\ \\mathrm{m/s}\\) \\(\\vec{B} = (0, 0, 1) \\ \\mathrm{T}\\) Then: Larmor radius: $$ r_L = \\frac{(9.1 \\times 10^{-31}) (1 \\times 10^6)}{(1.6 \\times 10^{-19})(1)} \\approx 5.7 \\times 10^{-3} \\ \\mathrm{m} $$ Cyclotron frequency: $$ \\omega_c = \\frac{1.6 \\times 10^{-19} \\times 1}{9.1 \\times 10^{-31}} \\approx 1.76 \\times 10^{11} \\ \\mathrm{rad/s} $$ The motion is circular in the plane perpendicular to the magnetic field, with radius \\(r_L\\) and angular speed \\(\\omega_c\\) . Task 2: Crossed Electric and Magnetic Fields For \\(\\vec{E} \\perp \\vec{B}\\) , the charged particle experiences a steady drift: \\[ \\vec{v}_d = \\frac{\\vec{E} \\times \\vec{B}}{B^2} \\] The motion includes: Cyclotron motion about the field line Superimposed drift in the \\(\\vec{E} \\times \\vec{B}\\) direction This phenomenon is exploited in devices like velocity selectors and magnetrons. Task 3: Parameter Exploration (with Slider) import ipywidgets as widgets from IPython.display import display @widgets.interact(B_strength=(0.1, 5.0, 0.1)) def simulate(B_strength=1.0): q = 1.6e-19 m = 9.1e-31 E = np.array([0, 0, 0]) B = np.array([0, 0, B_strength]) v = np.array([1e6, 0, 1e6]) r = np.array([0.0, 0.0, 0.0]) dt = 1e-11 steps = 1000 traj = [] for _ in range(steps): F = q * (E + np.cross(v, B)) a = F / m v += a * dt r += v * dt traj.append(r.copy()) traj = np.array(traj) plt.figure(figsize=(6,6)) plt.plot(traj[:,0], traj[:,1]) plt.title(f\"Trajectory for B = {B_strength} T\") plt.xlabel(\"x (m)\") plt.ylabel(\"y (m)\") plt.axis('equal') plt.grid() plt.show() Task 4: 3D Helical Motion Visualization from mpl_toolkits.mplot3d import Axes3D fig = plt.figure() ax = fig.add_subplot(111, projection='3d') ax.plot(positions[:,0], positions[:,1], positions[:,2]) ax.set_title(\"3D Helical Motion in Magnetic Field\") ax.set_xlabel(\"x (m)\") ax.set_ylabel(\"y (m)\") ax.set_zlabel(\"z (m)\") plt.show() Practical Implications Cyclotrons use uniform \\(\\vec{B}\\) to accelerate particles in circular orbits. Plasma confinement in tokamaks relies on helical paths and drift velocities. Velocity selectors use crossed \\(\\vec{E}\\) and \\(\\vec{B}\\) fields to isolate particles with specific speeds. Conclusion The Lorentz force provides a unified framework for understanding how electric and magnetic fields influence the motion of charged particles. Through analytical formulas, numerical simulations, and visualizations, we explored fundamental behaviors such as circular and helical trajectories, as well as drift in crossed fields. These concepts are not only critical in academic studies but are directly applied in advanced technologies like particle accelerators, plasma confinement devices, and astrophysical models. By adjusting parameters and simulating trajectories in Colab, students gain an intuitive and visual understanding of electromagnetic forces. The concepts covered here form a solid foundation for more advanced topics like non-uniform fields, relativistic dynamics, and electromagnetic wave-particle interactions.","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#electromagnetism-lorentz-force-theory-and-simulation","text":"","title":"Electromagnetism: Lorentz Force \u2014 Theory and Simulation"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#motivation","text":"The Lorentz force governs how charged particles move under electric and magnetic fields. This concept is foundational in: Plasma physics (e.g., fusion reactors) Particle accelerators (e.g., cyclotrons) Astrophysics (e.g., solar winds, cosmic rays) Mass spectrometry Simulating this force allows us to understand real-world applications and visualize intricate particle trajectories. This document explores applications, mathematical modeling, and numerical simulation of the Lorentz force using Python.","title":"Motivation"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#fundamental-formula","text":"The Lorentz force is the total electromagnetic force acting on a charged particle: \\[ \\vec{F} = q\\vec{E} + q\\vec{v} \\times \\vec{B} \\] Where: \\(\\vec{F}\\) : Force (N) \\(q\\) : Charge (C) \\(\\vec{E}\\) : Electric field (V/m) \\(\\vec{v}\\) : Velocity (m/s) \\(\\vec{B}\\) : Magnetic field (T) The first term represents the electric force, and the second term is the magnetic force. If \\(\\vec{E} = 0\\) , the motion is purely influenced by the magnetic field.","title":"Fundamental Formula"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#applications-of-lorentz-force","text":"System Role of Lorentz Force Particle Accelerators Provides centripetal force for circular particle motion Mass Spectrometers Differentiates ions by mass-to-charge ratio \\(\\frac{m}{q}\\) Magnetic Traps (Penning Traps) Confinement of charged particles in small regions Astrophysics Affects charged particles in cosmic and solar environments These systems rely on our ability to control particle paths using electric and magnetic fields.","title":"Applications of Lorentz Force"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#useful-derived-quantities","text":"Larmor Radius : $$ r_L = \\frac{mv_\\perp}{qB} $$ Describes the radius of circular motion perpendicular to a magnetic field. Cyclotron Frequency : $$ \\omega_c = \\frac{qB}{m} $$ The angular frequency of a particle's circular motion in a uniform magnetic field. Drift Velocity in Crossed Fields : $$ \\vec{v}_d = \\frac{\\vec{E} \\times \\vec{B}}{B^2} $$ Indicates how particles drift when electric and magnetic fields are perpendicular.","title":"Useful Derived Quantities"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#example-1-circular-motion-in-a-magnetic-field","text":"Let a particle have: \\(q = 1.6 \\times 10^{-19} \\ \\mathrm{C}\\) \\(m = 9.1 \\times 10^{-31} \\ \\mathrm{kg}\\) \\(\\vec{v} = (1 \\times 10^6, 0, 0) \\ \\mathrm{m/s}\\) \\(\\vec{B} = (0, 0, 1) \\ \\mathrm{T}\\) Then: Larmor radius: $$ r_L = \\frac{(9.1 \\times 10^{-31}) (1 \\times 10^6)}{(1.6 \\times 10^{-19})(1)} \\approx 5.7 \\times 10^{-3} \\ \\mathrm{m} $$ Cyclotron frequency: $$ \\omega_c = \\frac{1.6 \\times 10^{-19} \\times 1}{9.1 \\times 10^{-31}} \\approx 1.76 \\times 10^{11} \\ \\mathrm{rad/s} $$ The motion is circular in the plane perpendicular to the magnetic field, with radius \\(r_L\\) and angular speed \\(\\omega_c\\) .","title":"Example 1: Circular Motion in a Magnetic Field"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#task-2-crossed-electric-and-magnetic-fields","text":"For \\(\\vec{E} \\perp \\vec{B}\\) , the charged particle experiences a steady drift: \\[ \\vec{v}_d = \\frac{\\vec{E} \\times \\vec{B}}{B^2} \\] The motion includes: Cyclotron motion about the field line Superimposed drift in the \\(\\vec{E} \\times \\vec{B}\\) direction This phenomenon is exploited in devices like velocity selectors and magnetrons.","title":"Task 2: Crossed Electric and Magnetic Fields"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#task-3-parameter-exploration-with-slider","text":"import ipywidgets as widgets from IPython.display import display @widgets.interact(B_strength=(0.1, 5.0, 0.1)) def simulate(B_strength=1.0): q = 1.6e-19 m = 9.1e-31 E = np.array([0, 0, 0]) B = np.array([0, 0, B_strength]) v = np.array([1e6, 0, 1e6]) r = np.array([0.0, 0.0, 0.0]) dt = 1e-11 steps = 1000 traj = [] for _ in range(steps): F = q * (E + np.cross(v, B)) a = F / m v += a * dt r += v * dt traj.append(r.copy()) traj = np.array(traj) plt.figure(figsize=(6,6)) plt.plot(traj[:,0], traj[:,1]) plt.title(f\"Trajectory for B = {B_strength} T\") plt.xlabel(\"x (m)\") plt.ylabel(\"y (m)\") plt.axis('equal') plt.grid() plt.show()","title":"Task 3: Parameter Exploration (with Slider)"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#task-4-3d-helical-motion-visualization","text":"from mpl_toolkits.mplot3d import Axes3D fig = plt.figure() ax = fig.add_subplot(111, projection='3d') ax.plot(positions[:,0], positions[:,1], positions[:,2]) ax.set_title(\"3D Helical Motion in Magnetic Field\") ax.set_xlabel(\"x (m)\") ax.set_ylabel(\"y (m)\") ax.set_zlabel(\"z (m)\") plt.show()","title":"Task 4: 3D Helical Motion Visualization"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#practical-implications","text":"Cyclotrons use uniform \\(\\vec{B}\\) to accelerate particles in circular orbits. Plasma confinement in tokamaks relies on helical paths and drift velocities. Velocity selectors use crossed \\(\\vec{E}\\) and \\(\\vec{B}\\) fields to isolate particles with specific speeds.","title":"Practical Implications"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#conclusion","text":"The Lorentz force provides a unified framework for understanding how electric and magnetic fields influence the motion of charged particles. Through analytical formulas, numerical simulations, and visualizations, we explored fundamental behaviors such as circular and helical trajectories, as well as drift in crossed fields. These concepts are not only critical in academic studies but are directly applied in advanced technologies like particle accelerators, plasma confinement devices, and astrophysical models. By adjusting parameters and simulating trajectories in Colab, students gain an intuitive and visual understanding of electromagnetic forces. The concepts covered here form a solid foundation for more advanced topics like non-uniform fields, relativistic dynamics, and electromagnetic wave-particle interactions.","title":"Conclusion"},{"location":"1%20Physics/5%20Circuits/Problem_1/","text":"Problem 1 Equivalent Resistance Using Graph Theory Motivation Calculating equivalent resistance is fundamental in circuit analysis. Traditional methods rely on identifying series and parallel combinations. However, for complex networks , this approach becomes inefficient and error-prone. Graph theory provides a structured, algorithmic method to analyze circuits: Nodes represent junctions. Edges represent resistors (with weights equal to resistance). Using graph reduction and traversal algorithms, we can compute the total equivalent resistance even for intricate networks. Theoretical Foundation A resistor network can be modeled as an undirected weighted graph : Each node represents a connection point. Each edge connects two nodes and carries a resistance . We aim to compute the total resistance between two terminals (e.g., node A and B), regardless of how resistors are connected (series, parallel, nested). Mathematical Background Ohm's Law: \\[ V = IR \\] Kirchhoff\u2019s Laws: KCL (Node Law) : The sum of currents into a node is zero. KVL (Loop Law) : The sum of voltages in a closed loop is zero. Using these laws, a circuit graph can be converted into a system of equations. Algorithm Description Goal Given a resistor network (graph), reduce it to a single equivalent resistance between two nodes. Key Steps Identify simple structures : Series connections Parallel connections Iteratively reduce the graph: Merge series resistors: If nodes A\u2013B\u2013C form a chain: $$ R_{eq} = R_{AB} + R_{BC} $$ Merge parallel resistors: If multiple edges between A and B: $$ \\frac{1}{R_{eq}} = \\sum \\frac{1}{R_i} $$ Repeat until only two nodes remain (the terminals), connected by one edge (the equivalent resistance). Handling Nested Structures Nested combinations are reduced layer by layer: Use DFS or BFS to find: Chains : For series reduction. Cycles : For parallel reduction. After each reduction, update the graph and repeat traversal. Pseudocode function calculate_equivalent_resistance(graph, terminalA, terminalB): while graph has more than two nodes: for each node in graph: if node is not terminal and degree == 2: neighbors = get_neighbors(node) if not is_cycle(neighbors + node): reduce_series(node) for each pair of nodes: if multiple edges exist: reduce_parallel(pair) return weight of edge(terminalA, terminalB) Implementation in Python (Using networkx ) import networkx as nx def reduce_series(G): changed = True while changed: changed = False for node in list(G.nodes()): if G.degree(node) == 2 and node not in ('A', 'B'): u, v = list(G.neighbors(node)) if G.number_of_edges(u, node) == 1 and G.number_of_edges(node, v) == 1: R1 = G[u][node]['resistance'] R2 = G[node][v]['resistance'] G.add_edge(u, v, resistance=R1 + R2) G.remove_node(node) changed = True break def reduce_parallel(G): for u, v in list(G.edges()): parallel_edges = [d['resistance'] for key, d in G.get_edge_data(u, v).items()] if len(parallel_edges) > 1: Req_inv = sum(1/r for r in parallel_edges) G.remove_edges_from(list(G.edges(u, v))) G.add_edge(u, v, resistance=1 / Req_inv) def equivalent_resistance(G, start, end): reduce_series(G) reduce_parallel(G) return G[start][end]['resistance'] Example Inputs 1. Simple Series A\u20141\u03a9\u2014B\u20142\u03a9\u2014C Find resistance between A and C: \\[ R_{eq} = 1 + 2 = 3\\ \\Omega \\] 2. Simple Parallel A\u20141\u03a9\u2014B A\u20142\u03a9\u2014B Parallel: \\[ \\frac{1}{R_{eq}} = \\frac{1}{1} + \\frac{1}{2} = \\frac{3}{2} \\Rightarrow R_{eq} = \\frac{2}{3}\\ \\Omega \\] 3. Nested Combination \u250c\u2500\u2500 3\u03a9 \u2500\u2500\u2510 A \u2500\u2500\u2500\u2524 \u251c\u2500\u2500\u2500 C \u2514\u2500\u2500 6\u03a9 \u2500\u2500\u2518 Parallel branch between A and C: \\[ \\frac{1}{R_{eq}} = \\frac{1}{3} + \\frac{1}{6} = \\frac{1}{2} \\Rightarrow R_{eq} = 2\\ \\Omega \\] Complexity & Efficiency Series and Parallel reductions are linear in the number of nodes and edges. Worst-case: \\( O(n^2) \\) due to repeated traversals and updates. Can be improved using: Union-Find structure for disjoint sets. Smart cycle detection to skip unnecessary checks. Extensions and Applications Works for resistors, conductance, or even capacitors (in frequency domain). Basis for circuit simulators (like SPICE). Extensible to mesh and nodal analysis . --- Conclusion Graph theory offers a powerful and elegant framework for analyzing electrical circuits, especially when dealing with complex or nested resistor networks. By representing circuits as weighted graphs, we can abstract away physical layouts and focus purely on the structural relationships between components. This method enables: Automated simplification of resistor networks. Scalability to large and intricate topologies. Cross-domain applications , blending electrical engineering with computer science and discrete mathematics. While traditional series-parallel reduction is intuitive for small circuits, graph-based approaches generalize the process and open the door for advanced algorithmic techniques. As modern engineering increasingly relies on simulation and automation, such graph-theoretic methods become not just helpful\u2014but essential. In conclusion, viewing circuits through the lens of graph theory enriches both the understanding and capability of circuit analysis, making it a vital tool in the modern electrical engineer\u2019s toolkit.","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#equivalent-resistance-using-graph-theory","text":"","title":"Equivalent Resistance Using Graph Theory"},{"location":"1%20Physics/5%20Circuits/Problem_1/#motivation","text":"Calculating equivalent resistance is fundamental in circuit analysis. Traditional methods rely on identifying series and parallel combinations. However, for complex networks , this approach becomes inefficient and error-prone. Graph theory provides a structured, algorithmic method to analyze circuits: Nodes represent junctions. Edges represent resistors (with weights equal to resistance). Using graph reduction and traversal algorithms, we can compute the total equivalent resistance even for intricate networks.","title":"Motivation"},{"location":"1%20Physics/5%20Circuits/Problem_1/#theoretical-foundation","text":"A resistor network can be modeled as an undirected weighted graph : Each node represents a connection point. Each edge connects two nodes and carries a resistance . We aim to compute the total resistance between two terminals (e.g., node A and B), regardless of how resistors are connected (series, parallel, nested).","title":"Theoretical Foundation"},{"location":"1%20Physics/5%20Circuits/Problem_1/#mathematical-background","text":"","title":"Mathematical Background"},{"location":"1%20Physics/5%20Circuits/Problem_1/#ohms-law","text":"\\[ V = IR \\]","title":"Ohm's Law:"},{"location":"1%20Physics/5%20Circuits/Problem_1/#kirchhoffs-laws","text":"KCL (Node Law) : The sum of currents into a node is zero. KVL (Loop Law) : The sum of voltages in a closed loop is zero. Using these laws, a circuit graph can be converted into a system of equations.","title":"Kirchhoff\u2019s Laws:"},{"location":"1%20Physics/5%20Circuits/Problem_1/#algorithm-description","text":"","title":"Algorithm Description"},{"location":"1%20Physics/5%20Circuits/Problem_1/#goal","text":"Given a resistor network (graph), reduce it to a single equivalent resistance between two nodes.","title":"Goal"},{"location":"1%20Physics/5%20Circuits/Problem_1/#key-steps","text":"Identify simple structures : Series connections Parallel connections Iteratively reduce the graph: Merge series resistors: If nodes A\u2013B\u2013C form a chain: $$ R_{eq} = R_{AB} + R_{BC} $$ Merge parallel resistors: If multiple edges between A and B: $$ \\frac{1}{R_{eq}} = \\sum \\frac{1}{R_i} $$ Repeat until only two nodes remain (the terminals), connected by one edge (the equivalent resistance).","title":"Key Steps"},{"location":"1%20Physics/5%20Circuits/Problem_1/#handling-nested-structures","text":"Nested combinations are reduced layer by layer: Use DFS or BFS to find: Chains : For series reduction. Cycles : For parallel reduction. After each reduction, update the graph and repeat traversal.","title":"Handling Nested Structures"},{"location":"1%20Physics/5%20Circuits/Problem_1/#pseudocode","text":"function calculate_equivalent_resistance(graph, terminalA, terminalB): while graph has more than two nodes: for each node in graph: if node is not terminal and degree == 2: neighbors = get_neighbors(node) if not is_cycle(neighbors + node): reduce_series(node) for each pair of nodes: if multiple edges exist: reduce_parallel(pair) return weight of edge(terminalA, terminalB)","title":"Pseudocode"},{"location":"1%20Physics/5%20Circuits/Problem_1/#implementation-in-python-using-networkx","text":"import networkx as nx def reduce_series(G): changed = True while changed: changed = False for node in list(G.nodes()): if G.degree(node) == 2 and node not in ('A', 'B'): u, v = list(G.neighbors(node)) if G.number_of_edges(u, node) == 1 and G.number_of_edges(node, v) == 1: R1 = G[u][node]['resistance'] R2 = G[node][v]['resistance'] G.add_edge(u, v, resistance=R1 + R2) G.remove_node(node) changed = True break def reduce_parallel(G): for u, v in list(G.edges()): parallel_edges = [d['resistance'] for key, d in G.get_edge_data(u, v).items()] if len(parallel_edges) > 1: Req_inv = sum(1/r for r in parallel_edges) G.remove_edges_from(list(G.edges(u, v))) G.add_edge(u, v, resistance=1 / Req_inv) def equivalent_resistance(G, start, end): reduce_series(G) reduce_parallel(G) return G[start][end]['resistance']","title":"Implementation in Python (Using networkx)"},{"location":"1%20Physics/5%20Circuits/Problem_1/#example-inputs","text":"","title":"Example Inputs"},{"location":"1%20Physics/5%20Circuits/Problem_1/#1-simple-series","text":"A\u20141\u03a9\u2014B\u20142\u03a9\u2014C Find resistance between A and C: \\[ R_{eq} = 1 + 2 = 3\\ \\Omega \\]","title":"1. Simple Series"},{"location":"1%20Physics/5%20Circuits/Problem_1/#2-simple-parallel","text":"A\u20141\u03a9\u2014B A\u20142\u03a9\u2014B Parallel: \\[ \\frac{1}{R_{eq}} = \\frac{1}{1} + \\frac{1}{2} = \\frac{3}{2} \\Rightarrow R_{eq} = \\frac{2}{3}\\ \\Omega \\]","title":"2. Simple Parallel"},{"location":"1%20Physics/5%20Circuits/Problem_1/#3-nested-combination","text":"\u250c\u2500\u2500 3\u03a9 \u2500\u2500\u2510 A \u2500\u2500\u2500\u2524 \u251c\u2500\u2500\u2500 C \u2514\u2500\u2500 6\u03a9 \u2500\u2500\u2518 Parallel branch between A and C: \\[ \\frac{1}{R_{eq}} = \\frac{1}{3} + \\frac{1}{6} = \\frac{1}{2} \\Rightarrow R_{eq} = 2\\ \\Omega \\]","title":"3. Nested Combination"},{"location":"1%20Physics/5%20Circuits/Problem_1/#complexity-efficiency","text":"Series and Parallel reductions are linear in the number of nodes and edges. Worst-case: \\( O(n^2) \\) due to repeated traversals and updates. Can be improved using: Union-Find structure for disjoint sets. Smart cycle detection to skip unnecessary checks.","title":"Complexity &amp; Efficiency"},{"location":"1%20Physics/5%20Circuits/Problem_1/#extensions-and-applications","text":"Works for resistors, conductance, or even capacitors (in frequency domain). Basis for circuit simulators (like SPICE). Extensible to mesh and nodal analysis .","title":"Extensions and Applications"},{"location":"1%20Physics/5%20Circuits/Problem_1/#-","text":"","title":"---"},{"location":"1%20Physics/5%20Circuits/Problem_1/#conclusion","text":"Graph theory offers a powerful and elegant framework for analyzing electrical circuits, especially when dealing with complex or nested resistor networks. By representing circuits as weighted graphs, we can abstract away physical layouts and focus purely on the structural relationships between components. This method enables: Automated simplification of resistor networks. Scalability to large and intricate topologies. Cross-domain applications , blending electrical engineering with computer science and discrete mathematics. While traditional series-parallel reduction is intuitive for small circuits, graph-based approaches generalize the process and open the door for advanced algorithmic techniques. As modern engineering increasingly relies on simulation and automation, such graph-theoretic methods become not just helpful\u2014but essential. In conclusion, viewing circuits through the lens of graph theory enriches both the understanding and capability of circuit analysis, making it a vital tool in the modern electrical engineer\u2019s toolkit.","title":"Conclusion"},{"location":"1%20Physics/6%20Statistics/Problem_1/","text":"Problem 1 Central Limit Theorem (CLT) Exploration through Simulation Motivation The Central Limit Theorem (CLT) is a cornerstone of probability theory and inferential statistics. It explains why the normal distribution appears so frequently in the natural and social sciences. The theorem provides a powerful justification for using normal models in hypothesis testing, confidence intervals, and quality control\u2014even when the data does not initially appear normal. In this notebook, we aim to: Explore the CLT by simulating sampling distributions from different population distributions. Understand how and why the sample mean becomes approximately normal. Investigate the influence of sample size and population variance on the distribution of sample means. This approach helps bridge theory and practice, illustrating why the CLT is fundamental to real-world data analysis. Definitions and Fundamental Concepts Population The full set of items or individuals under study. Denoted by the capital letter $X$. Sample A subset of the population selected randomly to make statistical inferences. Random Variable A variable that represents outcomes of a random phenomenon. It can be discrete or continuous. Sample Mean ($\\bar{X}$) The average of a sample of $n$ observations: \\[ \\bar{X} = \\frac{1}{n} \\sum_{i=1}^{n} X_i \\] Population Mean ($\\mu$) The true mean of the population: \\[ \\mu = \\mathbb{E}[X] = \\lim_{n \\to \\infty} \\frac{1}{n} \\sum_{i=1}^{n} X_i \\] Variance ($\\sigma^2$) and Standard Deviation ($\\sigma$) Variance is the expected squared deviation from the mean: \\[ \\sigma^2 = \\mathbb{E}[(X - \\mu)^2] \\] Standard deviation is the square root of variance. Standard Error (SE) The standard deviation of the sample mean: \\[ SE = \\frac{\\sigma}{\\sqrt{n}} \\] This measures the spread of the sampling distribution of the mean. Central Limit Theorem: Formal Statement Let $X_1, X_2, \\dots, X_n$ be i.i.d. (independent and identically distributed) random variables with mean $\\mu$ and variance $\\sigma^2$. Then, as $n \\to \\infty$: \\[ \\frac{\\bar{X} - \\mu}{\\sigma/\\sqrt{n}} \\xrightarrow{d} \\mathcal{N}(0, 1) \\] In words, the distribution of the sample mean becomes approximately normal as the sample size increases, regardless of the original distribution. Simulating the CLT with Different Distributions We consider three population distributions: 1. Uniform Distribution $U(0,1)$ Continuous, bounded, symmetric. Easy to visualize convergence. 2. Exponential Distribution $\\text{Exp}(\\lambda=1)$ Continuous, right-skewed, unbounded. Requires larger sample sizes for normal approximation. 3. Binomial Distribution $\\text{Bin}(n=10, p=0.5)$ Discrete, symmetric for $p=0.5$. Demonstrates CLT even in non-continuous distributions. For each distribution: Simulate a large population (e.g., 100,000 values). Randomly sample with sizes $n = 5, 10, 30, 50, 100$. Repeat sampling (e.g., 1,000 times) and compute sample means. Visualize distributions of sample means with histograms. Visualization and Intuition We expect the following patterns: Small $n$: Histograms resemble the original distribution. Medium $n$ (30+): The shape of the histogram smooths out. Large $n$ (50+): The histogram becomes bell-shaped. Table: Convergence Behavior Distribution Shape CLT Speed Notes Uniform(0,1) Symmetric Fast Smooth and bounded Exponential(1) Skewed Slow Requires larger $n$ Binomial(10, 0.5) Discrete Moderate Symmetry helps convergence Key Properties of Sampling Distributions Mean of the sample means equals the population mean ($\\mu$). Standard deviation of the sample means equals $\\sigma / \\sqrt{n}$. Shape approaches normality as $n$ increases. This explains why sampling distributions of statistics like $\\bar{X}$ can be approximated with normal models\u2014even if the underlying data is non-normal. Applications of the Central Limit Theorem Confidence Intervals The CLT enables construction of confidence intervals: \\[ \\bar{X} \\pm z_{\\alpha/2} \\cdot \\frac{\\sigma}{\\sqrt{n}} \\] Where $z_{\\alpha/2}$ is the standard normal quantile (e.g., 1.96 for 95% CI). Hypothesis Testing CLT validates the use of $z$- and $t$-tests by approximating the distribution of the test statistic. Quality Control Control charts track sample means. CLT ensures the chart limits are based on the normal distribution. Financial Modeling Sum of returns over time behaves normally, helping model portfolio risk and forecast future prices.--- Further Exploration Test the CLT with other distributions: Poisson, Beta, Log-normal. Try non-i.i.d. data and see how convergence fails. Compare sample means to medians or variances. Explore CLT in the context of bootstrap resampling. Summary and Key Takeaways The CLT shows that sample means become normally distributed as sample size increases. The sampling distribution\u2019s spread decreases as $n$ increases. Even skewed or discrete data produces normal-looking sample means at large $n$. The CLT underlies confidence intervals, hypothesis tests, and many practical tools in statistics. Understanding the Central Limit Theorem not only provides theoretical insight\u2014it\u2019s essential for applying statistics in the real world.","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#central-limit-theorem-clt-exploration-through-simulation","text":"","title":"Central Limit Theorem (CLT) Exploration through Simulation"},{"location":"1%20Physics/6%20Statistics/Problem_1/#motivation","text":"The Central Limit Theorem (CLT) is a cornerstone of probability theory and inferential statistics. It explains why the normal distribution appears so frequently in the natural and social sciences. The theorem provides a powerful justification for using normal models in hypothesis testing, confidence intervals, and quality control\u2014even when the data does not initially appear normal. In this notebook, we aim to: Explore the CLT by simulating sampling distributions from different population distributions. Understand how and why the sample mean becomes approximately normal. Investigate the influence of sample size and population variance on the distribution of sample means. This approach helps bridge theory and practice, illustrating why the CLT is fundamental to real-world data analysis.","title":"Motivation"},{"location":"1%20Physics/6%20Statistics/Problem_1/#definitions-and-fundamental-concepts","text":"","title":"Definitions and Fundamental Concepts"},{"location":"1%20Physics/6%20Statistics/Problem_1/#population","text":"The full set of items or individuals under study. Denoted by the capital letter $X$.","title":"Population"},{"location":"1%20Physics/6%20Statistics/Problem_1/#sample","text":"A subset of the population selected randomly to make statistical inferences.","title":"Sample"},{"location":"1%20Physics/6%20Statistics/Problem_1/#random-variable","text":"A variable that represents outcomes of a random phenomenon. It can be discrete or continuous.","title":"Random Variable"},{"location":"1%20Physics/6%20Statistics/Problem_1/#sample-mean-barx","text":"The average of a sample of $n$ observations: \\[ \\bar{X} = \\frac{1}{n} \\sum_{i=1}^{n} X_i \\]","title":"Sample Mean ($\\bar{X}$)"},{"location":"1%20Physics/6%20Statistics/Problem_1/#population-mean-mu","text":"The true mean of the population: \\[ \\mu = \\mathbb{E}[X] = \\lim_{n \\to \\infty} \\frac{1}{n} \\sum_{i=1}^{n} X_i \\]","title":"Population Mean ($\\mu$)"},{"location":"1%20Physics/6%20Statistics/Problem_1/#variance-sigma2-and-standard-deviation-sigma","text":"Variance is the expected squared deviation from the mean: \\[ \\sigma^2 = \\mathbb{E}[(X - \\mu)^2] \\] Standard deviation is the square root of variance.","title":"Variance ($\\sigma^2$) and Standard Deviation ($\\sigma$)"},{"location":"1%20Physics/6%20Statistics/Problem_1/#standard-error-se","text":"The standard deviation of the sample mean: \\[ SE = \\frac{\\sigma}{\\sqrt{n}} \\] This measures the spread of the sampling distribution of the mean.","title":"Standard Error (SE)"},{"location":"1%20Physics/6%20Statistics/Problem_1/#central-limit-theorem-formal-statement","text":"Let $X_1, X_2, \\dots, X_n$ be i.i.d. (independent and identically distributed) random variables with mean $\\mu$ and variance $\\sigma^2$. Then, as $n \\to \\infty$: \\[ \\frac{\\bar{X} - \\mu}{\\sigma/\\sqrt{n}} \\xrightarrow{d} \\mathcal{N}(0, 1) \\] In words, the distribution of the sample mean becomes approximately normal as the sample size increases, regardless of the original distribution.","title":"Central Limit Theorem: Formal Statement"},{"location":"1%20Physics/6%20Statistics/Problem_1/#simulating-the-clt-with-different-distributions","text":"We consider three population distributions:","title":"Simulating the CLT with Different Distributions"},{"location":"1%20Physics/6%20Statistics/Problem_1/#1-uniform-distribution-u01","text":"Continuous, bounded, symmetric. Easy to visualize convergence.","title":"1. Uniform Distribution $U(0,1)$"},{"location":"1%20Physics/6%20Statistics/Problem_1/#2-exponential-distribution-textexplambda1","text":"Continuous, right-skewed, unbounded. Requires larger sample sizes for normal approximation.","title":"2. Exponential Distribution $\\text{Exp}(\\lambda=1)$"},{"location":"1%20Physics/6%20Statistics/Problem_1/#3-binomial-distribution-textbinn10-p05","text":"Discrete, symmetric for $p=0.5$. Demonstrates CLT even in non-continuous distributions. For each distribution: Simulate a large population (e.g., 100,000 values). Randomly sample with sizes $n = 5, 10, 30, 50, 100$. Repeat sampling (e.g., 1,000 times) and compute sample means. Visualize distributions of sample means with histograms.","title":"3. Binomial Distribution $\\text{Bin}(n=10, p=0.5)$"},{"location":"1%20Physics/6%20Statistics/Problem_1/#visualization-and-intuition","text":"We expect the following patterns: Small $n$: Histograms resemble the original distribution. Medium $n$ (30+): The shape of the histogram smooths out. Large $n$ (50+): The histogram becomes bell-shaped.","title":"Visualization and Intuition"},{"location":"1%20Physics/6%20Statistics/Problem_1/#table-convergence-behavior","text":"Distribution Shape CLT Speed Notes Uniform(0,1) Symmetric Fast Smooth and bounded Exponential(1) Skewed Slow Requires larger $n$ Binomial(10, 0.5) Discrete Moderate Symmetry helps convergence","title":"Table: Convergence Behavior"},{"location":"1%20Physics/6%20Statistics/Problem_1/#key-properties-of-sampling-distributions","text":"Mean of the sample means equals the population mean ($\\mu$). Standard deviation of the sample means equals $\\sigma / \\sqrt{n}$. Shape approaches normality as $n$ increases. This explains why sampling distributions of statistics like $\\bar{X}$ can be approximated with normal models\u2014even if the underlying data is non-normal.","title":"Key Properties of Sampling Distributions"},{"location":"1%20Physics/6%20Statistics/Problem_1/#applications-of-the-central-limit-theorem","text":"","title":"Applications of the Central Limit Theorem"},{"location":"1%20Physics/6%20Statistics/Problem_1/#confidence-intervals","text":"The CLT enables construction of confidence intervals: \\[ \\bar{X} \\pm z_{\\alpha/2} \\cdot \\frac{\\sigma}{\\sqrt{n}} \\] Where $z_{\\alpha/2}$ is the standard normal quantile (e.g., 1.96 for 95% CI).","title":"Confidence Intervals"},{"location":"1%20Physics/6%20Statistics/Problem_1/#hypothesis-testing","text":"CLT validates the use of $z$- and $t$-tests by approximating the distribution of the test statistic.","title":"Hypothesis Testing"},{"location":"1%20Physics/6%20Statistics/Problem_1/#quality-control","text":"Control charts track sample means. CLT ensures the chart limits are based on the normal distribution.","title":"Quality Control"},{"location":"1%20Physics/6%20Statistics/Problem_1/#financial-modeling","text":"Sum of returns over time behaves normally, helping model portfolio risk and forecast future prices.---","title":"Financial Modeling"},{"location":"1%20Physics/6%20Statistics/Problem_1/#further-exploration","text":"Test the CLT with other distributions: Poisson, Beta, Log-normal. Try non-i.i.d. data and see how convergence fails. Compare sample means to medians or variances. Explore CLT in the context of bootstrap resampling.","title":"Further Exploration"},{"location":"1%20Physics/6%20Statistics/Problem_1/#summary-and-key-takeaways","text":"The CLT shows that sample means become normally distributed as sample size increases. The sampling distribution\u2019s spread decreases as $n$ increases. Even skewed or discrete data produces normal-looking sample means at large $n$. The CLT underlies confidence intervals, hypothesis tests, and many practical tools in statistics. Understanding the Central Limit Theorem not only provides theoretical insight\u2014it\u2019s essential for applying statistics in the real world.","title":"Summary and Key Takeaways"},{"location":"1%20Physics/6%20Statistics/Problem_2/","text":"Problem 2 Estimating $\\pi$ Using Monte Carlo Methods Monte Carlo simulations are a class of computational algorithms that rely on repeated random sampling to obtain numerical results. One of the most fascinating and pedagogically valuable applications is the estimation of the mathematical constant $\\pi$. This document explores two classical Monte Carlo methods to approximate $\\pi$: Method 1 : Random point generation inside a square enclosing a circle. Method 2 : Buffon\u2019s Needle experiment involving probabilistic geometry. Motivation Understanding how randomness and probability can help solve deterministic problems provides profound insights into both theoretical and applied mathematics. Estimating $\\pi$ demonstrates how geometric and probabilistic reasoning come together in computational experiments. These methods: Serve as excellent educational tools. Illustrate convergence behavior and error analysis. Connect to real-world applications in statistics, physics, and finance. Part 1: Estimating $\\pi$ Using a Circle Theoretical Foundation Let\u2019s consider a unit circle centered at the origin $(0,0)$ and inscribed within a square that spans from $[-1, 1]$ on both axes. The area of the circle is: \\[ A_{\\text{circle}} = \\pi r^2 = \\pi \\cdot 1^2 = \\pi \\] The area of the enclosing square is: \\[ A_{\\text{square}} = (2r)^2 = 4 \\] The probability that a randomly chosen point from the square also falls inside the circle is: \\[ P = \\frac{A_{\\text{circle}}}{A_{\\text{square}}} = \\frac{\\pi}{4} \\] Hence, to estimate $\\pi$: \\[ \\pi \\approx 4 \\cdot \\frac{M}{N} \\] Where: $N$ = Total number of points sampled $M$ = Number of points that fall inside the circle Geometric Insight A point $(x, y)$ lies within the circle if: \\[ x^2 + y^2 \\leq 1 \\] Since we are sampling uniformly in the square $[-1, 1] \\times [-1, 1]$, this inequality gives a natural boundary to separate 'in-circle' vs 'out-of-circle' points. Experimental Setup To implement this method: Generate $N$ random points $(x_i, y_i)$ such that $x_i, y_i \\in [-1, 1]$. Count how many points satisfy $x_i^2 + y_i^2 \\leq 1$. Multiply the resulting fraction by 4. Convergence Analysis As we increase the number of randomly generated points $N$, the ratio $\\frac{M}{N}$ should converge to $\\frac{\\pi}{4}$. Error and Convergence The variance of the estimator decreases proportionally to $\\frac{1}{N}$. The standard error decreases as: \\[ \\text{Standard Error} \\sim \\frac{1}{\\sqrt{N}} \\] This implies that for more accurate results, exponentially more points are needed. Example Table Points (N) Points in Circle (M) Estimated $\\pi$ Absolute Error 100 78 3.12 0.02 1,000 789 3.156 0.014 10,000 7854 3.1416 0.0000 \ud83e\uddf7 Part 2: Estimating $\\pi$ Using Buffon\u2019s Needle Theoretical Foundation Buffon's Needle problem provides a probabilistic method to estimate $\\pi$. Problem Statement Drop a needle of length $l$ onto a plane with equally spaced parallel lines $d$ units apart ($l \\leq d$). What's the probability $P$ that the needle crosses a line? Formula Derivation It can be shown: \\[ P = \\frac{2l}{\\pi d} \\Rightarrow \\pi \\approx \\frac{2lN}{dC} \\] Where: $N$: total number of needle drops $C$: number of times the needle crosses a line Probability Distribution For a single throw, the probability involves two random variables: $\\theta \\in [0, \\pi]$: angle between the needle and the lines $x \\in [0, d/2]$: distance from needle center to closest line A crossing occurs when: \\[ \\frac{l}{2} \\sin \\theta \\geq x \\] Convergence & Comparison Just like the circle method, this approach suffers from slow convergence. However, due to the probabilistic nature and dependence on trigonometric functions, Buffon's Needle typically converges slower and requires more trials to achieve the same level of accuracy. Experimental Convergence Table Drops (N) Crosses (C) Estimated $\\pi$ Absolute Error 1,000 636 3.144 0.0024 10,000 6362 3.1415 0.0001 Comparison of Methods Method Formula Accuracy Convergence Rate Implementation Difficulty Circle Sampling $4 \\cdot \\frac{\\text{inside}}{N}$ High with large $N$ $\\sim 1/\\sqrt{N}$ Simple Buffon\u2019s Needle $\\frac{2lN}{dC}$ Medium Slower Moderate (geometry + trig) Summary of Useful Formulas Circle method: \\(\\pi \\approx 4 \\cdot \\frac{\\text{# inside circle}}{\\text{total samples}}\\) Buffon\u2019s needle: \\(\\pi \\approx \\frac{2 \\cdot l \\cdot N}{d \\cdot C}\\) Further Exploration Ideas How do different random sampling strategies affect convergence? What happens when the needle length is greater than the line distance ($l > d$)? Can we reduce variance using stratified or importance sampling? Try visualizing all samples in 2D for better geometric intuition. Analyze the speed/accuracy trade-off in both methods. Conclusion Monte Carlo methods provide intuitive and powerful ways to estimate quantities like $\\pi$. These simulations: Reinforce understanding of probability and geometry. Illustrate convergence behavior. Offer a gateway into stochastic modeling and scientific computing. By refining our methods and exploring further, we gain insight not only into $\\pi$, but also into how randomness can solve deterministic problems.","title":"Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#estimating-pi-using-monte-carlo-methods","text":"Monte Carlo simulations are a class of computational algorithms that rely on repeated random sampling to obtain numerical results. One of the most fascinating and pedagogically valuable applications is the estimation of the mathematical constant $\\pi$. This document explores two classical Monte Carlo methods to approximate $\\pi$: Method 1 : Random point generation inside a square enclosing a circle. Method 2 : Buffon\u2019s Needle experiment involving probabilistic geometry.","title":"Estimating $\\pi$ Using Monte Carlo Methods"},{"location":"1%20Physics/6%20Statistics/Problem_2/#motivation","text":"Understanding how randomness and probability can help solve deterministic problems provides profound insights into both theoretical and applied mathematics. Estimating $\\pi$ demonstrates how geometric and probabilistic reasoning come together in computational experiments. These methods: Serve as excellent educational tools. Illustrate convergence behavior and error analysis. Connect to real-world applications in statistics, physics, and finance.","title":"Motivation"},{"location":"1%20Physics/6%20Statistics/Problem_2/#part-1-estimating-pi-using-a-circle","text":"","title":"Part 1: Estimating $\\pi$ Using a Circle"},{"location":"1%20Physics/6%20Statistics/Problem_2/#theoretical-foundation","text":"Let\u2019s consider a unit circle centered at the origin $(0,0)$ and inscribed within a square that spans from $[-1, 1]$ on both axes. The area of the circle is: \\[ A_{\\text{circle}} = \\pi r^2 = \\pi \\cdot 1^2 = \\pi \\] The area of the enclosing square is: \\[ A_{\\text{square}} = (2r)^2 = 4 \\] The probability that a randomly chosen point from the square also falls inside the circle is: \\[ P = \\frac{A_{\\text{circle}}}{A_{\\text{square}}} = \\frac{\\pi}{4} \\] Hence, to estimate $\\pi$: \\[ \\pi \\approx 4 \\cdot \\frac{M}{N} \\] Where: $N$ = Total number of points sampled $M$ = Number of points that fall inside the circle","title":"Theoretical Foundation"},{"location":"1%20Physics/6%20Statistics/Problem_2/#geometric-insight","text":"A point $(x, y)$ lies within the circle if: \\[ x^2 + y^2 \\leq 1 \\] Since we are sampling uniformly in the square $[-1, 1] \\times [-1, 1]$, this inequality gives a natural boundary to separate 'in-circle' vs 'out-of-circle' points.","title":"Geometric Insight"},{"location":"1%20Physics/6%20Statistics/Problem_2/#experimental-setup","text":"To implement this method: Generate $N$ random points $(x_i, y_i)$ such that $x_i, y_i \\in [-1, 1]$. Count how many points satisfy $x_i^2 + y_i^2 \\leq 1$. Multiply the resulting fraction by 4.","title":"Experimental Setup"},{"location":"1%20Physics/6%20Statistics/Problem_2/#convergence-analysis","text":"As we increase the number of randomly generated points $N$, the ratio $\\frac{M}{N}$ should converge to $\\frac{\\pi}{4}$.","title":"Convergence Analysis"},{"location":"1%20Physics/6%20Statistics/Problem_2/#error-and-convergence","text":"The variance of the estimator decreases proportionally to $\\frac{1}{N}$. The standard error decreases as: \\[ \\text{Standard Error} \\sim \\frac{1}{\\sqrt{N}} \\] This implies that for more accurate results, exponentially more points are needed.","title":"Error and Convergence"},{"location":"1%20Physics/6%20Statistics/Problem_2/#example-table","text":"Points (N) Points in Circle (M) Estimated $\\pi$ Absolute Error 100 78 3.12 0.02 1,000 789 3.156 0.014 10,000 7854 3.1416 0.0000","title":"Example Table"},{"location":"1%20Physics/6%20Statistics/Problem_2/#part-2-estimating-pi-using-buffons-needle","text":"","title":"\ud83e\uddf7 Part 2: Estimating $\\pi$ Using Buffon\u2019s Needle"},{"location":"1%20Physics/6%20Statistics/Problem_2/#theoretical-foundation_1","text":"Buffon's Needle problem provides a probabilistic method to estimate $\\pi$.","title":"Theoretical Foundation"},{"location":"1%20Physics/6%20Statistics/Problem_2/#problem-statement","text":"Drop a needle of length $l$ onto a plane with equally spaced parallel lines $d$ units apart ($l \\leq d$). What's the probability $P$ that the needle crosses a line?","title":"Problem Statement"},{"location":"1%20Physics/6%20Statistics/Problem_2/#formula-derivation","text":"It can be shown: \\[ P = \\frac{2l}{\\pi d} \\Rightarrow \\pi \\approx \\frac{2lN}{dC} \\] Where: $N$: total number of needle drops $C$: number of times the needle crosses a line","title":"Formula Derivation"},{"location":"1%20Physics/6%20Statistics/Problem_2/#probability-distribution","text":"For a single throw, the probability involves two random variables: $\\theta \\in [0, \\pi]$: angle between the needle and the lines $x \\in [0, d/2]$: distance from needle center to closest line A crossing occurs when: \\[ \\frac{l}{2} \\sin \\theta \\geq x \\]","title":"Probability Distribution"},{"location":"1%20Physics/6%20Statistics/Problem_2/#convergence-comparison","text":"Just like the circle method, this approach suffers from slow convergence. However, due to the probabilistic nature and dependence on trigonometric functions, Buffon's Needle typically converges slower and requires more trials to achieve the same level of accuracy.","title":"Convergence &amp; Comparison"},{"location":"1%20Physics/6%20Statistics/Problem_2/#experimental-convergence-table","text":"Drops (N) Crosses (C) Estimated $\\pi$ Absolute Error 1,000 636 3.144 0.0024 10,000 6362 3.1415 0.0001","title":"Experimental Convergence Table"},{"location":"1%20Physics/6%20Statistics/Problem_2/#comparison-of-methods","text":"Method Formula Accuracy Convergence Rate Implementation Difficulty Circle Sampling $4 \\cdot \\frac{\\text{inside}}{N}$ High with large $N$ $\\sim 1/\\sqrt{N}$ Simple Buffon\u2019s Needle $\\frac{2lN}{dC}$ Medium Slower Moderate (geometry + trig)","title":"Comparison of Methods"},{"location":"1%20Physics/6%20Statistics/Problem_2/#summary-of-useful-formulas","text":"Circle method: \\(\\pi \\approx 4 \\cdot \\frac{\\text{# inside circle}}{\\text{total samples}}\\) Buffon\u2019s needle: \\(\\pi \\approx \\frac{2 \\cdot l \\cdot N}{d \\cdot C}\\)","title":"Summary of Useful Formulas"},{"location":"1%20Physics/6%20Statistics/Problem_2/#further-exploration-ideas","text":"How do different random sampling strategies affect convergence? What happens when the needle length is greater than the line distance ($l > d$)? Can we reduce variance using stratified or importance sampling? Try visualizing all samples in 2D for better geometric intuition. Analyze the speed/accuracy trade-off in both methods.","title":"Further Exploration Ideas"},{"location":"1%20Physics/6%20Statistics/Problem_2/#conclusion","text":"Monte Carlo methods provide intuitive and powerful ways to estimate quantities like $\\pi$. These simulations: Reinforce understanding of probability and geometry. Illustrate convergence behavior. Offer a gateway into stochastic modeling and scientific computing. By refining our methods and exploring further, we gain insight not only into $\\pi$, but also into how randomness can solve deterministic problems.","title":"Conclusion"},{"location":"1%20Physics/7%20Measurements/Problem_1/","text":"Problem 1 Measuring Earth's Gravitational Acceleration Using a Simple Pendulum Objective To determine the local value of the acceleration due to gravity, \\( \\(g\\) \\) , by measuring the period of a simple pendulum. This experiment highlights rigorous scientific measurement practices and detailed uncertainty analysis. Theoretical Background What is a Simple Pendulum? A simple pendulum consists of a mass (called the bob) suspended by a light, inextensible string from a fixed point so that it can swing freely. For small angular displacements (less than 15\u00b0), the restoring force is proportional to the displacement, resulting in simple harmonic motion. Period of a Simple Pendulum The time it takes for the pendulum to complete one full back-and-forth swing is the period \\( \\(T\\) \\) , given by: \\[ T = 2\\pi \\sqrt{\\frac{L}{g}} \\] \\( \\(T\\) \\) = Period of oscillation (s) \\( \\(L\\) \\) = Length from pivot to center of mass (m) \\( \\(g\\) \\) = Gravitational acceleration (m/s\u00b2) By rearranging the formula, we can solve for \\( \\(g\\) \\) : \\[ g = \\frac{4\\pi^2 L}{T^2} \\] This provides a practical method for measuring \\( \\(g\\) \\) using a pendulum. Materials A string (1.0 to 1.5 m) A small mass (e.g., metal washer, keychain) Stopwatch or smartphone with timer Ruler or measuring tape (preferably mm precision) Support stand or a fixed hook Experimental Setup Fix one end of the string to a sturdy support. Attach the bob at the other end. Measure the length \\( \\(L\\) \\) from the point of suspension to the center of mass of the bob. Estimate the measurement resolution. For example, a standard ruler has a resolution of 0.01 m, so: $$ \\Delta L = \\frac{0.01}{2} = 0.005 \\, \\text{m} $$ Data Collection Procedure Displace the pendulum by less than 15\u00b0 and release it without pushing. Use a stopwatch to measure the time for 10 full oscillations . Repeat this process 10 times . Record all measurements of \\( \\(T_{10}\\) \\) (time for 10 oscillations). Calculate: The mean time: \\( \\(\\overline{T_{10}}\\) \\) The standard deviation : \\( \\(\\sigma_T\\) \\) The uncertainty in the mean : $$ \\Delta T_{10} = \\frac{\\sigma_T}{\\sqrt{n}} \\quad \\text{where } n = 10 $$ Convert time for 10 oscillations into single-period time: $$ T = \\frac{\\overline{T_{10}}}{10}, \\quad \\Delta T = \\frac{\\Delta T_{10}}{10} $$ Sample Data Table Trial \\( \\(T_{10}\\) \\) (s) 1 20.31 2 20.28 3 20.35 4 20.29 5 20.33 6 20.27 7 20.30 8 20.34 9 20.31 10 20.29 \\[\\overline{T_{10}} = 20.307 \\, \\text{s}\\] \\[\\sigma_T = 0.025 \\, \\text{s}\\] \\[\\Delta T_{10} = \\frac{0.025}{\\sqrt{10}} = 0.0079 \\, \\text{s}\\] \\[T = \\frac{20.307}{10} = 2.031 \\, \\text{s}\\] \\[\\Delta T = \\frac{0.0079}{10} = 0.00079 \\, \\text{s}\\] Final Calculations 1. Calculating \\( \\(g\\) \\) : Using \\( \\(L = 1.000 \\, \\text{m}\\) \\) : \\[ g = \\frac{4\\pi^2 \\cdot 1.000}{(2.031)^2} \\approx 9.56 \\, \\text{m/s}^2 \\] 2. Propagation of Uncertainties: \\[ \\Delta g = g \\cdot \\sqrt{ \\left( \\frac{\\Delta L}{L} \\right)^2 + \\left( 2 \\cdot \\frac{\\Delta T}{T} \\right)^2 } \\] Substituting the known values: \\[ \\Delta g = 9.56 \\cdot \\sqrt{ \\left( \\frac{0.005}{1.000} \\right)^2 + \\left( 2 \\cdot \\frac{0.00079}{2.031} \\right)^2 } \\approx 0.05 \\, \\text{m/s}^2 \\] Results Summary Quantity Value Length \\( \\(L\\) \\) 1.000 m Uncertainty \\( \\(\\Delta L\\) \\) 0.005 m Period \\( \\(T\\) \\) 2.031 s Uncertainty \\( \\(\\Delta T\\) \\) 0.00079 s Gravity \\( \\(g\\) \\) 9.56 m/s\u00b2 Uncertainty \\( \\(\\Delta g\\) \\) \u00b10.05 m/s\u00b2 Standard \\( \\(g\\) \\) 9.81 m/s\u00b2 Analysis and Discussion Comparison with Standard Value Measured: \\( \\(g = 9.56 \\pm 0.05 \\, \\text{m/s}^2\\) \\) Standard: \\( \\(9.81 \\, \\text{m/s}^2\\) \\) Difference is within ~2.6%, which is acceptable for an experiment with basic tools. Measurement Uncertainty Impact Length ( ( \\(\\Delta L\\) \\) ) : Dominated by the resolution of the ruler. Using a more precise tool or taking multiple measurements and averaging can reduce uncertainty. Timing ( ( \\(\\Delta T\\) \\) ) : Human reaction time introduces variability. Averaging multiple trials and measuring multiple oscillations helps mitigate this. Other Assumptions : Small angle approximation is valid only for \\( \\(\\theta < 15^\\circ\\) \\) . Neglects air resistance, string mass, and friction at the pivot. Conclusion This experiment successfully demonstrated how the acceleration due to gravity, \\( \\(g\\) \\) , can be measured using a simple pendulum. By carefully measuring the length of the pendulum and the period of its oscillations, and by rigorously analyzing uncertainties, a reasonably accurate value for \\( \\(g\\) \\) was obtained. Despite the simplicity of the setup, our measured value of \\( \\(g = 9.56 \\pm 0.05 \\, \\text{m/s}^2\\) \\) was within a few percent of the standard value \\( \\(9.81 \\, \\text{m/s}^2\\) \\) . The small discrepancy can be attributed to various factors such as measurement errors, reaction time in manual timing, and unaccounted damping forces like air resistance or pivot friction. This exercise highlights the importance of: - Minimizing systematic errors (e.g., using precise instruments), - Averaging over multiple trials to reduce random errors, - Understanding how uncertainties propagate , and - Critically comparing experimental results to accepted standards . Ultimately, the experiment reinforces foundational concepts in classical mechanics and experimental physics, especially the interplay between theoretical models and real-world measurement limitations.","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#measuring-earths-gravitational-acceleration-using-a-simple-pendulum","text":"","title":"Measuring Earth's Gravitational Acceleration Using a Simple Pendulum"},{"location":"1%20Physics/7%20Measurements/Problem_1/#objective","text":"To determine the local value of the acceleration due to gravity, \\( \\(g\\) \\) , by measuring the period of a simple pendulum. This experiment highlights rigorous scientific measurement practices and detailed uncertainty analysis.","title":"Objective"},{"location":"1%20Physics/7%20Measurements/Problem_1/#theoretical-background","text":"","title":"Theoretical Background"},{"location":"1%20Physics/7%20Measurements/Problem_1/#what-is-a-simple-pendulum","text":"A simple pendulum consists of a mass (called the bob) suspended by a light, inextensible string from a fixed point so that it can swing freely. For small angular displacements (less than 15\u00b0), the restoring force is proportional to the displacement, resulting in simple harmonic motion.","title":"What is a Simple Pendulum?"},{"location":"1%20Physics/7%20Measurements/Problem_1/#period-of-a-simple-pendulum","text":"The time it takes for the pendulum to complete one full back-and-forth swing is the period \\( \\(T\\) \\) , given by: \\[ T = 2\\pi \\sqrt{\\frac{L}{g}} \\] \\( \\(T\\) \\) = Period of oscillation (s) \\( \\(L\\) \\) = Length from pivot to center of mass (m) \\( \\(g\\) \\) = Gravitational acceleration (m/s\u00b2) By rearranging the formula, we can solve for \\( \\(g\\) \\) : \\[ g = \\frac{4\\pi^2 L}{T^2} \\] This provides a practical method for measuring \\( \\(g\\) \\) using a pendulum.","title":"Period of a Simple Pendulum"},{"location":"1%20Physics/7%20Measurements/Problem_1/#materials","text":"A string (1.0 to 1.5 m) A small mass (e.g., metal washer, keychain) Stopwatch or smartphone with timer Ruler or measuring tape (preferably mm precision) Support stand or a fixed hook","title":"Materials"},{"location":"1%20Physics/7%20Measurements/Problem_1/#experimental-setup","text":"Fix one end of the string to a sturdy support. Attach the bob at the other end. Measure the length \\( \\(L\\) \\) from the point of suspension to the center of mass of the bob. Estimate the measurement resolution. For example, a standard ruler has a resolution of 0.01 m, so: $$ \\Delta L = \\frac{0.01}{2} = 0.005 \\, \\text{m} $$","title":"Experimental Setup"},{"location":"1%20Physics/7%20Measurements/Problem_1/#data-collection-procedure","text":"Displace the pendulum by less than 15\u00b0 and release it without pushing. Use a stopwatch to measure the time for 10 full oscillations . Repeat this process 10 times . Record all measurements of \\( \\(T_{10}\\) \\) (time for 10 oscillations). Calculate: The mean time: \\( \\(\\overline{T_{10}}\\) \\) The standard deviation : \\( \\(\\sigma_T\\) \\) The uncertainty in the mean : $$ \\Delta T_{10} = \\frac{\\sigma_T}{\\sqrt{n}} \\quad \\text{where } n = 10 $$ Convert time for 10 oscillations into single-period time: $$ T = \\frac{\\overline{T_{10}}}{10}, \\quad \\Delta T = \\frac{\\Delta T_{10}}{10} $$","title":"Data Collection Procedure"},{"location":"1%20Physics/7%20Measurements/Problem_1/#sample-data-table","text":"Trial \\( \\(T_{10}\\) \\) (s) 1 20.31 2 20.28 3 20.35 4 20.29 5 20.33 6 20.27 7 20.30 8 20.34 9 20.31 10 20.29 \\[\\overline{T_{10}} = 20.307 \\, \\text{s}\\] \\[\\sigma_T = 0.025 \\, \\text{s}\\] \\[\\Delta T_{10} = \\frac{0.025}{\\sqrt{10}} = 0.0079 \\, \\text{s}\\] \\[T = \\frac{20.307}{10} = 2.031 \\, \\text{s}\\] \\[\\Delta T = \\frac{0.0079}{10} = 0.00079 \\, \\text{s}\\]","title":"Sample Data Table"},{"location":"1%20Physics/7%20Measurements/Problem_1/#final-calculations","text":"","title":"Final Calculations"},{"location":"1%20Physics/7%20Measurements/Problem_1/#1-calculating-g","text":"Using \\( \\(L = 1.000 \\, \\text{m}\\) \\) : \\[ g = \\frac{4\\pi^2 \\cdot 1.000}{(2.031)^2} \\approx 9.56 \\, \\text{m/s}^2 \\]","title":"1. Calculating \\(\\(g\\)\\):"},{"location":"1%20Physics/7%20Measurements/Problem_1/#2-propagation-of-uncertainties","text":"\\[ \\Delta g = g \\cdot \\sqrt{ \\left( \\frac{\\Delta L}{L} \\right)^2 + \\left( 2 \\cdot \\frac{\\Delta T}{T} \\right)^2 } \\] Substituting the known values: \\[ \\Delta g = 9.56 \\cdot \\sqrt{ \\left( \\frac{0.005}{1.000} \\right)^2 + \\left( 2 \\cdot \\frac{0.00079}{2.031} \\right)^2 } \\approx 0.05 \\, \\text{m/s}^2 \\]","title":"2. Propagation of Uncertainties:"},{"location":"1%20Physics/7%20Measurements/Problem_1/#results-summary","text":"Quantity Value Length \\( \\(L\\) \\) 1.000 m Uncertainty \\( \\(\\Delta L\\) \\) 0.005 m Period \\( \\(T\\) \\) 2.031 s Uncertainty \\( \\(\\Delta T\\) \\) 0.00079 s Gravity \\( \\(g\\) \\) 9.56 m/s\u00b2 Uncertainty \\( \\(\\Delta g\\) \\) \u00b10.05 m/s\u00b2 Standard \\( \\(g\\) \\) 9.81 m/s\u00b2","title":"Results Summary"},{"location":"1%20Physics/7%20Measurements/Problem_1/#analysis-and-discussion","text":"","title":"Analysis and Discussion"},{"location":"1%20Physics/7%20Measurements/Problem_1/#comparison-with-standard-value","text":"Measured: \\( \\(g = 9.56 \\pm 0.05 \\, \\text{m/s}^2\\) \\) Standard: \\( \\(9.81 \\, \\text{m/s}^2\\) \\) Difference is within ~2.6%, which is acceptable for an experiment with basic tools.","title":"Comparison with Standard Value"},{"location":"1%20Physics/7%20Measurements/Problem_1/#measurement-uncertainty-impact","text":"Length ( ( \\(\\Delta L\\) \\) ) : Dominated by the resolution of the ruler. Using a more precise tool or taking multiple measurements and averaging can reduce uncertainty. Timing ( ( \\(\\Delta T\\) \\) ) : Human reaction time introduces variability. Averaging multiple trials and measuring multiple oscillations helps mitigate this. Other Assumptions : Small angle approximation is valid only for \\( \\(\\theta < 15^\\circ\\) \\) . Neglects air resistance, string mass, and friction at the pivot.","title":"Measurement Uncertainty Impact"},{"location":"1%20Physics/7%20Measurements/Problem_1/#conclusion","text":"This experiment successfully demonstrated how the acceleration due to gravity, \\( \\(g\\) \\) , can be measured using a simple pendulum. By carefully measuring the length of the pendulum and the period of its oscillations, and by rigorously analyzing uncertainties, a reasonably accurate value for \\( \\(g\\) \\) was obtained. Despite the simplicity of the setup, our measured value of \\( \\(g = 9.56 \\pm 0.05 \\, \\text{m/s}^2\\) \\) was within a few percent of the standard value \\( \\(9.81 \\, \\text{m/s}^2\\) \\) . The small discrepancy can be attributed to various factors such as measurement errors, reaction time in manual timing, and unaccounted damping forces like air resistance or pivot friction. This exercise highlights the importance of: - Minimizing systematic errors (e.g., using precise instruments), - Averaging over multiple trials to reduce random errors, - Understanding how uncertainties propagate , and - Critically comparing experimental results to accepted standards . Ultimately, the experiment reinforces foundational concepts in classical mechanics and experimental physics, especially the interplay between theoretical models and real-world measurement limitations.","title":"Conclusion"},{"location":"2%20Mathematics/1%20Linear_algebra/","text":"Linear Algebra","title":"Linear Algebra"},{"location":"2%20Mathematics/1%20Linear_algebra/#linear-algebra","text":"","title":"Linear Algebra"},{"location":"2%20Mathematics/2%20Analytic_geometry/","text":"Analytic geometry","title":"Analytic geometry"},{"location":"2%20Mathematics/2%20Analytic_geometry/#analytic-geometry","text":"","title":"Analytic geometry"},{"location":"2%20Mathematics/3%20Calculus/","text":"Calculus","title":"Calculus"},{"location":"2%20Mathematics/3%20Calculus/#calculus","text":"","title":"Calculus"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/","text":"Set Theory","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/#set-theory","text":"","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/","text":"Relations","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/#relations","text":"","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/","text":"Functions","title":"Functions"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/#functions","text":"","title":"Functions"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/","text":"Combinatorics","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/#combinatorics","text":"","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/","text":"Number Theory","title":"Number Theory"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/#number-theory","text":"","title":"Number Theory"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/","text":"Sequences and Series","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/#sequences-and-series","text":"","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/","text":"Induction","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/#induction","text":"","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/","text":"Recurrence","title":"Recurrence"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/#recurrence","text":"","title":"Recurrence"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/","text":"Graph Theory","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/#graph-theory","text":"","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/","text":"Logic","title":"Logic"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/#logic","text":"","title":"Logic"}]}