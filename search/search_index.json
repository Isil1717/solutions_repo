{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Technical setup Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft) Useful links Python Miniconda Documentation Google Colab How to use this repository Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW Where can I find the problems? Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Introduction"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#technical-setup","text":"Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft)","title":"Technical setup"},{"location":"#useful-links","text":"Python Miniconda Documentation Google Colab","title":"Useful links"},{"location":"#how-to-use-this-repository","text":"Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW","title":"How to use this repository"},{"location":"#where-can-i-find-the-problems","text":"Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Where can I find the problems?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/","text":"\u2699\ufe0f Mechanics \u2013 Problem 1 \ud83e\udde0 Mechanics Problem 1: Investigating the Range as a Function of the Angle of Projection \ud83c\udfaf Problem Overview We study the dependence of the horizontal range of a projectile on the launch angle \\( \\theta \\) , taking into account physical parameters such as: Initial velocity \\( v_0 \\) Gravitational acceleration \\( g \\) Air resistance (optional) Launch height \\( h \\) Inclined terrain \ud83d\udcd0 1. Ideal Projectile Motion (No Air Resistance) Coordinate System We decompose the motion into horizontal and vertical components. Equations of Motion: Initial velocity components: \\[ v_{0x} = v_0 \\cos(\\theta), \\quad v_{0y} = v_0 \\sin(\\theta) \\] Displacements: \\[ x(t) = v_0 \\cos(\\theta) \\cdot t \\] \\[ y(t) = v_0 \\sin(\\theta) \\cdot t - \\frac{1}{2} g t^2 \\] Time of flight (when \\( y = 0 \\) ): \\[ T = \\frac{2v_0 \\sin(\\theta)}{g} \\] Range: \\[ R(\\theta) = x(T) = \\frac{v_0^2 \\sin(2\\theta)}{g} \\] \ud83e\uddee 2. Python Implementation (Ideal Case) import numpy as np import matplotlib.pyplot as plt g = 9.81 # gravity [m/s^2] angles_deg = np.linspace(0, 90, 500) angles_rad = np.radians(angles_deg) def ideal_range(v0, theta): return (v0**2 * np.sin(2 * theta)) / g v0_values = [10, 20, 30] plt.figure(figsize=(10, 6)) for v0 in v0_values: R = ideal_range(v0, angles_rad) plt.plot(angles_deg, R, label=f\"$v_0 = {v0}$ m/s\") plt.title(\"Range vs Angle (Ideal Case)\") plt.xlabel(\"Launch Angle (degrees)\") plt.ylabel(\"Range (meters)\") plt.legend() plt.grid(True) plt.savefig(\"ideal_range.png\") plt.show() \ud83c\udfd4\ufe0f 3. Uneven Terrain (Inclined Plane) Let the ground be inclined by angle \\( \\alpha \\) . The effective launch angle becomes \\( \\theta - \\alpha \\) , and time of flight changes accordingly. Time to impact (from projectile to slope): \\[ T = \\frac{2 v_0 \\sin(\\theta - \\alpha)}{g \\cos(\\alpha)} \\] Modified range on inclined plane: \\[ R = \\frac{v_0^2 \\sin(2(\\theta - \\alpha))}{g \\cos(\\alpha)} \\] This is derived assuming a symmetrical trajectory in the slope frame. \ud83c\udf2c\ufe0f 4. Air Resistance (Linear Drag) When air resistance is considered, the force becomes: \\[ \\vec{F}_{\\text{drag}} = -k \\vec{v} \\] Where \\( k \\) is the drag coefficient. Equations of motion: \\[ \\frac{d v_x}{dt} = -\\frac{k}{m} v_x, \\quad \\frac{d v_y}{dt} = -g - \\frac{k}{m} v_y \\] Solutions: \\[ v_x(t) = v_{0x} e^{-kt/m}, \\quad v_y(t) = \\left(v_{0y} + \\frac{mg}{k} \\right) e^{-kt/m} - \\frac{mg}{k} \\] Position functions (after integration): \\[ x(t) = \\frac{m v_{0x}}{k} \\left(1 - e^{-kt/m} \\right) \\] \\[ y(t) = \\left(v_{0y} + \\frac{mg}{k} \\right) \\cdot \\frac{m}{k} \\left(1 - e^{-kt/m} \\right) - \\frac{mg}{k} \\cdot t \\] These equations require numerical solutions for time of flight and range.","title":"\u2699\ufe0f Mechanics \u2013 Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#mechanics-problem-1","text":"","title":"\u2699\ufe0f Mechanics \u2013 Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#mechanics-problem-1-investigating-the-range-as-a-function-of-the-angle-of-projection","text":"","title":"\ud83e\udde0 Mechanics Problem 1: Investigating the Range as a Function of the Angle of Projection"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#problem-overview","text":"We study the dependence of the horizontal range of a projectile on the launch angle \\( \\theta \\) , taking into account physical parameters such as: Initial velocity \\( v_0 \\) Gravitational acceleration \\( g \\) Air resistance (optional) Launch height \\( h \\) Inclined terrain","title":"\ud83c\udfaf Problem Overview"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#1-ideal-projectile-motion-no-air-resistance","text":"","title":"\ud83d\udcd0 1. Ideal Projectile Motion (No Air Resistance)"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#coordinate-system","text":"We decompose the motion into horizontal and vertical components.","title":"Coordinate System"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#equations-of-motion","text":"Initial velocity components: \\[ v_{0x} = v_0 \\cos(\\theta), \\quad v_{0y} = v_0 \\sin(\\theta) \\] Displacements: \\[ x(t) = v_0 \\cos(\\theta) \\cdot t \\] \\[ y(t) = v_0 \\sin(\\theta) \\cdot t - \\frac{1}{2} g t^2 \\] Time of flight (when \\( y = 0 \\) ): \\[ T = \\frac{2v_0 \\sin(\\theta)}{g} \\] Range: \\[ R(\\theta) = x(T) = \\frac{v_0^2 \\sin(2\\theta)}{g} \\]","title":"Equations of Motion:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#2-python-implementation-ideal-case","text":"import numpy as np import matplotlib.pyplot as plt g = 9.81 # gravity [m/s^2] angles_deg = np.linspace(0, 90, 500) angles_rad = np.radians(angles_deg) def ideal_range(v0, theta): return (v0**2 * np.sin(2 * theta)) / g v0_values = [10, 20, 30] plt.figure(figsize=(10, 6)) for v0 in v0_values: R = ideal_range(v0, angles_rad) plt.plot(angles_deg, R, label=f\"$v_0 = {v0}$ m/s\") plt.title(\"Range vs Angle (Ideal Case)\") plt.xlabel(\"Launch Angle (degrees)\") plt.ylabel(\"Range (meters)\") plt.legend() plt.grid(True) plt.savefig(\"ideal_range.png\") plt.show()","title":"\ud83e\uddee 2. Python Implementation (Ideal Case)"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#3-uneven-terrain-inclined-plane","text":"Let the ground be inclined by angle \\( \\alpha \\) . The effective launch angle becomes \\( \\theta - \\alpha \\) , and time of flight changes accordingly.","title":"\ud83c\udfd4\ufe0f 3. Uneven Terrain (Inclined Plane)"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#time-to-impact-from-projectile-to-slope","text":"\\[ T = \\frac{2 v_0 \\sin(\\theta - \\alpha)}{g \\cos(\\alpha)} \\]","title":"Time to impact (from projectile to slope):"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#modified-range-on-inclined-plane","text":"\\[ R = \\frac{v_0^2 \\sin(2(\\theta - \\alpha))}{g \\cos(\\alpha)} \\] This is derived assuming a symmetrical trajectory in the slope frame.","title":"Modified range on inclined plane:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#4-air-resistance-linear-drag","text":"When air resistance is considered, the force becomes: \\[ \\vec{F}_{\\text{drag}} = -k \\vec{v} \\] Where \\( k \\) is the drag coefficient.","title":"\ud83c\udf2c\ufe0f 4. Air Resistance (Linear Drag)"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#equations-of-motion_1","text":"\\[ \\frac{d v_x}{dt} = -\\frac{k}{m} v_x, \\quad \\frac{d v_y}{dt} = -g - \\frac{k}{m} v_y \\]","title":"Equations of motion:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#solutions","text":"\\[ v_x(t) = v_{0x} e^{-kt/m}, \\quad v_y(t) = \\left(v_{0y} + \\frac{mg}{k} \\right) e^{-kt/m} - \\frac{mg}{k} \\]","title":"Solutions:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#position-functions-after-integration","text":"\\[ x(t) = \\frac{m v_{0x}}{k} \\left(1 - e^{-kt/m} \\right) \\] \\[ y(t) = \\left(v_{0y} + \\frac{mg}{k} \\right) \\cdot \\frac{m}{k} \\left(1 - e^{-kt/m} \\right) - \\frac{mg}{k} \\cdot t \\] These equations require numerical solutions for time of flight and range.","title":"Position functions (after integration):"},{"location":"1%20Physics/1%20Mechanics/Problem_2/","text":"Problem 2 Investigating the Dynamics of a Forced Damped Pendulum Introduction The forced damped pendulum is a classic example of a non-linear oscillatory system. The system demonstrates a rich variety of behaviors, including resonance, chaos, and quasiperiodic motion, depending on the interplay between damping, restoring forces, and external driving forces. The dynamics of this system are governed by the second-order differential equation: \\[ \\frac{d^2 \\theta}{dt^2} + b \\frac{d\\theta}{dt} + \\frac{g}{L} \\sin(\\theta) = A \\cos(\\omega t) \\] Where: - \\( \\theta(t) \\) is the angular displacement, - \\( b \\) is the damping coefficient, - \\( g \\) is the gravitational acceleration, - \\( L \\) is the length of the pendulum, - \\( A \\) is the amplitude of the external driving force, - \\( \\omega \\) is the angular frequency of the external force. Small-Angle Approximation For small oscillations, we use the approximation \\( \\sin(\\theta) \\approx \\theta \\) , leading to a linearized form of the equation: \\[ \\frac{d^2 \\theta}{dt^2} + b \\frac{d \\theta}{dt} + \\frac{g}{L} \\theta = A \\cos(\\omega t) \\] This approximation simplifies the analysis, and the system behaves similarly to a driven damped harmonic oscillator. The natural frequency of the undamped system is: \\[ \\omega_0 = \\sqrt{\\frac{g}{L}} \\] At resonance, when the driving frequency \\( \\omega \\) matches the natural frequency \\( \\omega_0 \\) , the amplitude of oscillations can increase dramatically. This condition is given by: \\[ \\omega_{\\text{res}} = \\sqrt{\\frac{g}{L}} \\] Numerical Simulation To simulate the dynamics of the forced damped pendulum, we rewrite the second-order differential equation as a system of first-order equations: Let: - \\( \\theta_1 = \\theta \\) , - \\( \\theta_2 = \\frac{d \\theta}{dt} \\) . The system becomes: \\[ \\frac{d \\theta_1}{dt} = \\theta_2 \\] \\[ \\frac{d \\theta_2}{dt} = -b \\theta_2 - \\frac{g}{L} \\sin(\\theta_1) + A \\cos(\\omega t) \\] This system can be solved numerically using methods like the Runge-Kutta algorithm to obtain the time evolution of \\( \\theta_1(t) \\) and \\( \\theta_2(t) \\) . Effects of Damping and Driving Forces Damping Coefficient \\( b \\) The damping coefficient \\( b \\) controls the rate at which the oscillations decay. As \\( b \\) increases, the system loses energy more rapidly, causing the amplitude of oscillations to decrease. When \\( b \\) is large enough, the system eventually reaches a steady state with no oscillations. For small damping \\( b \\) , resonance phenomena occur, and the system can exhibit large oscillations if the driving frequency \\( \\omega \\) is close to the natural frequency of the system. The modified equation for damping is: \\[ \\frac{d^2 \\theta}{dt^2} + b \\frac{d \\theta}{dt} + \\frac{g}{L} \\theta = A \\cos(\\omega t) \\] Driving Force Amplitude \\( A \\) The amplitude of the driving force \\( A \\) determines how much energy is supplied to the system. As \\( A \\) increases, the amplitude of oscillations increases. If \\( A \\) is large enough and \\( \\omega \\) is close to \\( \\omega_{\\text{res}} \\) , the system enters a state of large amplitude oscillations, potentially leading to resonance. Driving Frequency \\( \\omega \\) The driving frequency \\( \\omega \\) plays a crucial role in determining the behavior of the system. At resonance, when \\( \\omega = \\omega_{\\text{res}} \\) , the system's response is maximal, and the oscillations grow significantly. The system exhibits a peak in amplitude at this frequency. For frequencies far from resonance, the oscillations have much smaller amplitudes. Chaos and Bifurcations As the parameters \\( A \\) (driving amplitude) and \\( \\omega \\) (driving frequency) are varied, the system can undergo bifurcations, where small changes in parameters lead to large changes in the system\u2019s behavior. The bifurcation diagram can reveal transitions from periodic to chaotic motion. In a bifurcation diagram, as \\( A \\) or \\( \\omega \\) increases, the system may exhibit a sudden transition to chaotic behavior. This is due to sensitive dependence on initial conditions, a hallmark of chaos. Lyapunov Exponent The Lyapunov exponent measures the rate at which nearby trajectories in phase space diverge, and is a key indicator of chaos. A positive Lyapunov exponent indicates chaotic behavior, while a negative value suggests stable periodic motion. It is defined as: \\[ \\lambda = \\lim_{t \\to \\infty} \\frac{1}{t} \\ln \\left( \\frac{|\\delta(t)|}{|\\delta(0)|} \\right) \\] Where: - \\( \\delta(t) \\) is the separation between two nearby trajectories at time \\( t \\) , - \\( \\delta(0) \\) is the initial separation. A positive Lyapunov exponent means that the system is chaotic and exhibits exponential divergence of nearby trajectories. Conclusion The dynamics of the forced damped pendulum provide a rich example of nonlinear behavior, including resonance, chaos, and periodic motion. By varying the damping coefficient, driving amplitude, and driving frequency, we observe a variety of dynamic responses, from stable oscillations to chaotic motion. Numerical simulations and analytical techniques such as the Lyapunov exponent and bifurcation diagrams allow for a deeper understanding of these behaviors, with applications in engineering, biomechanics, and electronics. import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # --- Physical parameters --- g = 9.81 # gravitational acceleration (m/s^2) L = 1.0 # pendulum length (m) b = 0.5 # damping coefficient A = 1.2 # amplitude of the driving force omega = 2.0 # angular frequency of the driving force # --- Time settings --- t_start = 0.0 t_end = 50.0 dt = 0.01 t_eval = np.arange(t_start, t_end, dt) # --- Initial conditions --- theta0 = 0.2 # initial angle (radians) theta_dot0 = 0.0 # initial angular velocity (rad/s) initial_state = [theta0, theta_dot0] # --- Differential equations --- def forced_damped_pendulum(t, y): theta, theta_dot = y dtheta_dt = theta_dot dtheta_dot_dt = -b * theta_dot - (g / L) * np.sin(theta) + A * np.cos(omega * t) return [dtheta_dt, dtheta_dot_dt] # --- Solve the system --- sol = solve_ivp( fun=forced_damped_pendulum, t_span=(t_start, t_end), y0=initial_state, t_eval=t_eval, method='RK45' ) # --- Plot the results --- plt.figure(figsize=(10, 5)) plt.plot(sol.t, sol.y[0], label='\u03b8(t) [rad]', color='darkblue') plt.xlabel('Time [s]') plt.ylabel('Angle \u03b8 [rad]') plt.title('Forced Damped Pendulum Simulation') plt.grid(True) plt.legend() plt.tight_layout() plt.show()","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#investigating-the-dynamics-of-a-forced-damped-pendulum","text":"","title":"Investigating the Dynamics of a Forced Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#introduction","text":"The forced damped pendulum is a classic example of a non-linear oscillatory system. The system demonstrates a rich variety of behaviors, including resonance, chaos, and quasiperiodic motion, depending on the interplay between damping, restoring forces, and external driving forces. The dynamics of this system are governed by the second-order differential equation: \\[ \\frac{d^2 \\theta}{dt^2} + b \\frac{d\\theta}{dt} + \\frac{g}{L} \\sin(\\theta) = A \\cos(\\omega t) \\] Where: - \\( \\theta(t) \\) is the angular displacement, - \\( b \\) is the damping coefficient, - \\( g \\) is the gravitational acceleration, - \\( L \\) is the length of the pendulum, - \\( A \\) is the amplitude of the external driving force, - \\( \\omega \\) is the angular frequency of the external force.","title":"Introduction"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#small-angle-approximation","text":"For small oscillations, we use the approximation \\( \\sin(\\theta) \\approx \\theta \\) , leading to a linearized form of the equation: \\[ \\frac{d^2 \\theta}{dt^2} + b \\frac{d \\theta}{dt} + \\frac{g}{L} \\theta = A \\cos(\\omega t) \\] This approximation simplifies the analysis, and the system behaves similarly to a driven damped harmonic oscillator. The natural frequency of the undamped system is: \\[ \\omega_0 = \\sqrt{\\frac{g}{L}} \\] At resonance, when the driving frequency \\( \\omega \\) matches the natural frequency \\( \\omega_0 \\) , the amplitude of oscillations can increase dramatically. This condition is given by: \\[ \\omega_{\\text{res}} = \\sqrt{\\frac{g}{L}} \\]","title":"Small-Angle Approximation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#numerical-simulation","text":"To simulate the dynamics of the forced damped pendulum, we rewrite the second-order differential equation as a system of first-order equations: Let: - \\( \\theta_1 = \\theta \\) , - \\( \\theta_2 = \\frac{d \\theta}{dt} \\) . The system becomes: \\[ \\frac{d \\theta_1}{dt} = \\theta_2 \\] \\[ \\frac{d \\theta_2}{dt} = -b \\theta_2 - \\frac{g}{L} \\sin(\\theta_1) + A \\cos(\\omega t) \\] This system can be solved numerically using methods like the Runge-Kutta algorithm to obtain the time evolution of \\( \\theta_1(t) \\) and \\( \\theta_2(t) \\) .","title":"Numerical Simulation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#effects-of-damping-and-driving-forces","text":"","title":"Effects of Damping and Driving Forces"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#damping-coefficient-b","text":"The damping coefficient \\( b \\) controls the rate at which the oscillations decay. As \\( b \\) increases, the system loses energy more rapidly, causing the amplitude of oscillations to decrease. When \\( b \\) is large enough, the system eventually reaches a steady state with no oscillations. For small damping \\( b \\) , resonance phenomena occur, and the system can exhibit large oscillations if the driving frequency \\( \\omega \\) is close to the natural frequency of the system. The modified equation for damping is: \\[ \\frac{d^2 \\theta}{dt^2} + b \\frac{d \\theta}{dt} + \\frac{g}{L} \\theta = A \\cos(\\omega t) \\]","title":"Damping Coefficient \\( b \\)"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#driving-force-amplitude-a","text":"The amplitude of the driving force \\( A \\) determines how much energy is supplied to the system. As \\( A \\) increases, the amplitude of oscillations increases. If \\( A \\) is large enough and \\( \\omega \\) is close to \\( \\omega_{\\text{res}} \\) , the system enters a state of large amplitude oscillations, potentially leading to resonance.","title":"Driving Force Amplitude \\( A \\)"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#driving-frequency-omega","text":"The driving frequency \\( \\omega \\) plays a crucial role in determining the behavior of the system. At resonance, when \\( \\omega = \\omega_{\\text{res}} \\) , the system's response is maximal, and the oscillations grow significantly. The system exhibits a peak in amplitude at this frequency. For frequencies far from resonance, the oscillations have much smaller amplitudes.","title":"Driving Frequency \\( \\omega \\)"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#chaos-and-bifurcations","text":"As the parameters \\( A \\) (driving amplitude) and \\( \\omega \\) (driving frequency) are varied, the system can undergo bifurcations, where small changes in parameters lead to large changes in the system\u2019s behavior. The bifurcation diagram can reveal transitions from periodic to chaotic motion. In a bifurcation diagram, as \\( A \\) or \\( \\omega \\) increases, the system may exhibit a sudden transition to chaotic behavior. This is due to sensitive dependence on initial conditions, a hallmark of chaos.","title":"Chaos and Bifurcations"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#lyapunov-exponent","text":"The Lyapunov exponent measures the rate at which nearby trajectories in phase space diverge, and is a key indicator of chaos. A positive Lyapunov exponent indicates chaotic behavior, while a negative value suggests stable periodic motion. It is defined as: \\[ \\lambda = \\lim_{t \\to \\infty} \\frac{1}{t} \\ln \\left( \\frac{|\\delta(t)|}{|\\delta(0)|} \\right) \\] Where: - \\( \\delta(t) \\) is the separation between two nearby trajectories at time \\( t \\) , - \\( \\delta(0) \\) is the initial separation. A positive Lyapunov exponent means that the system is chaotic and exhibits exponential divergence of nearby trajectories.","title":"Lyapunov Exponent"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#conclusion","text":"The dynamics of the forced damped pendulum provide a rich example of nonlinear behavior, including resonance, chaos, and periodic motion. By varying the damping coefficient, driving amplitude, and driving frequency, we observe a variety of dynamic responses, from stable oscillations to chaotic motion. Numerical simulations and analytical techniques such as the Lyapunov exponent and bifurcation diagrams allow for a deeper understanding of these behaviors, with applications in engineering, biomechanics, and electronics. import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # --- Physical parameters --- g = 9.81 # gravitational acceleration (m/s^2) L = 1.0 # pendulum length (m) b = 0.5 # damping coefficient A = 1.2 # amplitude of the driving force omega = 2.0 # angular frequency of the driving force # --- Time settings --- t_start = 0.0 t_end = 50.0 dt = 0.01 t_eval = np.arange(t_start, t_end, dt) # --- Initial conditions --- theta0 = 0.2 # initial angle (radians) theta_dot0 = 0.0 # initial angular velocity (rad/s) initial_state = [theta0, theta_dot0] # --- Differential equations --- def forced_damped_pendulum(t, y): theta, theta_dot = y dtheta_dt = theta_dot dtheta_dot_dt = -b * theta_dot - (g / L) * np.sin(theta) + A * np.cos(omega * t) return [dtheta_dt, dtheta_dot_dt] # --- Solve the system --- sol = solve_ivp( fun=forced_damped_pendulum, t_span=(t_start, t_end), y0=initial_state, t_eval=t_eval, method='RK45' ) # --- Plot the results --- plt.figure(figsize=(10, 5)) plt.plot(sol.t, sol.y[0], label='\u03b8(t) [rad]', color='darkblue') plt.xlabel('Time [s]') plt.ylabel('Angle \u03b8 [rad]') plt.title('Forced Damped Pendulum Simulation') plt.grid(True) plt.legend() plt.tight_layout() plt.show()","title":"Conclusion"},{"location":"1%20Physics/2%20Gravity/Problem_1/","text":"Problem 1 Kepler's Third Law: Orbital Period and Radius Motivation In celestial mechanics, Kepler's Third Law describes a fundamental connection between the orbital period and the orbital radius of a body moving around a central mass. This law allows us to estimate the structure and scale of planetary systems, including our own Solar System. Kepler discovered this empirical law from observations, and later Newton derived it from the law of universal gravitation. It is one of the most elegant and powerful tools in astrophysics. Derivation from Newtonian Mechanics Let a small mass \\( m \\) orbit a massive central body of mass \\( M \\) (e.g., the Earth around the Sun) in a circular orbit of radius \\( r \\) . The gravitational force provides the centripetal acceleration : \\[ F_{\\text{gravity}} = \\frac{G M m}{r^2}, \\quad F_{\\text{centripetal}} = \\frac{m v^2}{r} \\] Equating the two forces: \\[ \\frac{G M m}{r^2} = \\frac{m v^2}{r} \\] Simplifying and solving for orbital speed \\( v \\) : \\[ v^2 = \\frac{G M}{r} \\] The orbital period \\( T \\) is the time to complete one full orbit, which is the circumference divided by speed: \\[ T = \\frac{2\\pi r}{v} \\] Substitute the expression for \\( v \\) : \\[ T = 2\\pi r \\sqrt{\\frac{r}{G M}} = 2\\pi \\sqrt{\\frac{r^3}{G M}} \\] Now squaring both sides: \\[ T^2 = \\frac{4\\pi^2}{G M} \\cdot r^3 \\] This is the mathematical form of Kepler's Third Law : \\[ T^2 \\propto r^3 \\] The proportionality constant depends only on the mass \\( M \\) of the central object. Implications of Kepler's Law Universal Relationship : All bodies orbiting the same central mass follow the same \\( T^2/r^3 \\) ratio. Comparative Analysis : Knowing \\( T \\) and \\( r \\) for one object allows us to predict them for another. Mass Estimation : Rearranging the equation allows for calculating the mass of a star or planet: \\[ M = \\frac{4\\pi^2 r^3}{G T^2} \\] Real-World Examples Example 1: The Moon's Orbit Around Earth Radius: \\( r = 3.84 \\times 10^8 \\) m Period: \\( T = 27.3 \\) days \\( \\approx 2.36 \\times 10^6 \\) s Using Kepler's Law: \\[ T^2 = \\frac{4\\pi^2 r^3}{G M_{\\text{Earth}}} \\] This checks out when we use Earth\u2019s mass \\( M = 5.97 \\times 10^{24} \\, \\text{kg} \\) . \u2609 Example 2: Planets Around the Sun Planet \\( r \\) (AU) \\( T \\) (years) \\( T^2 \\) \\( r^3 \\) Mercury 0.39 0.24 0.0576 0.0593 Earth 1.00 1.00 1.0000 1.0000 Jupiter 5.20 11.86 140.7 140.6 We observe: \\[ \\frac{T^2}{r^3} \\approx \\text{constant} \\] Python Simulation: Numerical Verification import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # m^3 kg^-1 s^-2 M_sun = 1.989e30 # kg # Generate orbital radii from 0.1 AU to 5 AU (converted to meters) AU = 1.496e11 # meters radii = np.linspace(0.1 * AU, 5 * AU, 100) T_squared = (4 * np.pi**2 * radii**3) / (G * M_sun) T_days = np.sqrt(T_squared) / (60 * 60 * 24) # Plot T^2 vs r^3 plt.figure(figsize=(8,6)) plt.plot(radii**3, T_squared, label=r\"$T^2$ vs $r^3$\", color='blue') plt.xlabel(r\"Orbital Radius Cubed ($r^3$) [$\\mathrm{m}^3$]\") plt.ylabel(r\"Orbital Period Squared ($T^2$) [$\\mathrm{s}^2$]\") plt.title(\"Kepler's Third Law Simulation\") plt.grid(True) plt.legend() plt.tight_layout() plt.show() Visualization & Analysis The plot above shows a linear relationship between \\( T^2 \\) and \\( r^3 \\) , confirming the theoretical expectation from Kepler\u2019s Third Law. To quantify: from scipy.stats import linregress slope, intercept, r_value, _, _ = linregress(radii**3, T_squared) print(\"Slope:\", slope) print(\"R^2:\", r_value**2) An \\( R^2 \\) value near 1 confirms an excellent fit. Extension to Elliptical Orbits Kepler originally formulated his third law for elliptical orbits , using the semi-major axis \\( a \\) instead of radius \\( r \\) : \\[ T^2 = \\frac{4\\pi^2 a^3}{G M} \\] This form still holds for non-circular , but bound orbits like those of comets, satellites, and binary stars. The key is to replace radius with semi-major axis . Summary We derived Kepler's Third Law from Newton's gravitation. We confirmed the relationship numerically using Python. We discussed real-world systems where the law is applicable. The law is essential for orbital mechanics , space missions , and planetary astronomy . Further Exploration Model elliptical orbits and test the same law using the semi-major axis. Include perturbations (e.g., other planets' gravity). Explore relativistic corrections (e.g., Mercury\u2019s precession).","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#problem-1","text":"Kepler's Third Law: Orbital Period and Radius","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#motivation","text":"In celestial mechanics, Kepler's Third Law describes a fundamental connection between the orbital period and the orbital radius of a body moving around a central mass. This law allows us to estimate the structure and scale of planetary systems, including our own Solar System. Kepler discovered this empirical law from observations, and later Newton derived it from the law of universal gravitation. It is one of the most elegant and powerful tools in astrophysics.","title":"Motivation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#derivation-from-newtonian-mechanics","text":"Let a small mass \\( m \\) orbit a massive central body of mass \\( M \\) (e.g., the Earth around the Sun) in a circular orbit of radius \\( r \\) . The gravitational force provides the centripetal acceleration : \\[ F_{\\text{gravity}} = \\frac{G M m}{r^2}, \\quad F_{\\text{centripetal}} = \\frac{m v^2}{r} \\] Equating the two forces: \\[ \\frac{G M m}{r^2} = \\frac{m v^2}{r} \\] Simplifying and solving for orbital speed \\( v \\) : \\[ v^2 = \\frac{G M}{r} \\] The orbital period \\( T \\) is the time to complete one full orbit, which is the circumference divided by speed: \\[ T = \\frac{2\\pi r}{v} \\] Substitute the expression for \\( v \\) : \\[ T = 2\\pi r \\sqrt{\\frac{r}{G M}} = 2\\pi \\sqrt{\\frac{r^3}{G M}} \\] Now squaring both sides: \\[ T^2 = \\frac{4\\pi^2}{G M} \\cdot r^3 \\] This is the mathematical form of Kepler's Third Law : \\[ T^2 \\propto r^3 \\] The proportionality constant depends only on the mass \\( M \\) of the central object.","title":"Derivation from Newtonian Mechanics"},{"location":"1%20Physics/2%20Gravity/Problem_1/#implications-of-keplers-law","text":"Universal Relationship : All bodies orbiting the same central mass follow the same \\( T^2/r^3 \\) ratio. Comparative Analysis : Knowing \\( T \\) and \\( r \\) for one object allows us to predict them for another. Mass Estimation : Rearranging the equation allows for calculating the mass of a star or planet: \\[ M = \\frac{4\\pi^2 r^3}{G T^2} \\]","title":"Implications of Kepler's Law"},{"location":"1%20Physics/2%20Gravity/Problem_1/#real-world-examples","text":"","title":"Real-World Examples"},{"location":"1%20Physics/2%20Gravity/Problem_1/#example-1-the-moons-orbit-around-earth","text":"Radius: \\( r = 3.84 \\times 10^8 \\) m Period: \\( T = 27.3 \\) days \\( \\approx 2.36 \\times 10^6 \\) s Using Kepler's Law: \\[ T^2 = \\frac{4\\pi^2 r^3}{G M_{\\text{Earth}}} \\] This checks out when we use Earth\u2019s mass \\( M = 5.97 \\times 10^{24} \\, \\text{kg} \\) .","title":"Example 1: The Moon's Orbit Around Earth"},{"location":"1%20Physics/2%20Gravity/Problem_1/#example-2-planets-around-the-sun","text":"Planet \\( r \\) (AU) \\( T \\) (years) \\( T^2 \\) \\( r^3 \\) Mercury 0.39 0.24 0.0576 0.0593 Earth 1.00 1.00 1.0000 1.0000 Jupiter 5.20 11.86 140.7 140.6 We observe: \\[ \\frac{T^2}{r^3} \\approx \\text{constant} \\]","title":"\u2609 Example 2: Planets Around the Sun"},{"location":"1%20Physics/2%20Gravity/Problem_1/#python-simulation-numerical-verification","text":"import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # m^3 kg^-1 s^-2 M_sun = 1.989e30 # kg # Generate orbital radii from 0.1 AU to 5 AU (converted to meters) AU = 1.496e11 # meters radii = np.linspace(0.1 * AU, 5 * AU, 100) T_squared = (4 * np.pi**2 * radii**3) / (G * M_sun) T_days = np.sqrt(T_squared) / (60 * 60 * 24) # Plot T^2 vs r^3 plt.figure(figsize=(8,6)) plt.plot(radii**3, T_squared, label=r\"$T^2$ vs $r^3$\", color='blue') plt.xlabel(r\"Orbital Radius Cubed ($r^3$) [$\\mathrm{m}^3$]\") plt.ylabel(r\"Orbital Period Squared ($T^2$) [$\\mathrm{s}^2$]\") plt.title(\"Kepler's Third Law Simulation\") plt.grid(True) plt.legend() plt.tight_layout() plt.show()","title":"Python Simulation: Numerical Verification"},{"location":"1%20Physics/2%20Gravity/Problem_1/#visualization-analysis","text":"The plot above shows a linear relationship between \\( T^2 \\) and \\( r^3 \\) , confirming the theoretical expectation from Kepler\u2019s Third Law. To quantify: from scipy.stats import linregress slope, intercept, r_value, _, _ = linregress(radii**3, T_squared) print(\"Slope:\", slope) print(\"R^2:\", r_value**2) An \\( R^2 \\) value near 1 confirms an excellent fit.","title":"Visualization &amp; Analysis"},{"location":"1%20Physics/2%20Gravity/Problem_1/#extension-to-elliptical-orbits","text":"Kepler originally formulated his third law for elliptical orbits , using the semi-major axis \\( a \\) instead of radius \\( r \\) : \\[ T^2 = \\frac{4\\pi^2 a^3}{G M} \\] This form still holds for non-circular , but bound orbits like those of comets, satellites, and binary stars. The key is to replace radius with semi-major axis .","title":"Extension to Elliptical Orbits"},{"location":"1%20Physics/2%20Gravity/Problem_1/#summary","text":"We derived Kepler's Third Law from Newton's gravitation. We confirmed the relationship numerically using Python. We discussed real-world systems where the law is applicable. The law is essential for orbital mechanics , space missions , and planetary astronomy .","title":"Summary"},{"location":"1%20Physics/2%20Gravity/Problem_1/#further-exploration","text":"Model elliptical orbits and test the same law using the semi-major axis. Include perturbations (e.g., other planets' gravity). Explore relativistic corrections (e.g., Mercury\u2019s precession).","title":"Further Exploration"},{"location":"1%20Physics/2%20Gravity/Problem_2/","text":"Problem 2 Cosmic Velocities: Theory, Implementation & Visualizations This project calculates the first , second , and third cosmic velocities for Earth , Mars , and Jupiter , including mathematical derivations , Python code , and visualizations . 1. \ud83c\udf0c Theoretical Background 1.1 First Cosmic Velocity The first cosmic velocity is the minimum speed required to enter orbit around a celestial body. This is based on the balance between centripetal force and gravitational force . Mathematically, it is derived from the following relation: \\[ F_{\\text{centripetal}} = F_{\\text{gravitational}} \\] Where: \\[ \\frac{m v_1^2}{R} = \\frac{G M m}{R^2} \\] Simplifying for \\( v_1 \\) , we get the first cosmic velocity : \\[ v_1 = \\sqrt{\\frac{GM}{R}} \\] Where: - \\( G \\) = Gravitational constant \\( 6.67430 \\times 10^{-11} \\ \\text{m}^3 \\text{kg}^{-1} \\text{s}^{-2} \\) - \\( M \\) = Mass of the celestial body (kg) - \\( R \\) = Radius of the celestial body (m) 1.2 Second Cosmic Velocity The second cosmic velocity is the escape velocity , the speed needed to escape the gravitational pull of the celestial body. This can be derived from the energy conservation between kinetic energy and gravitational potential energy: \\[ E_{\\text{total}} = E_{\\text{kinetic}} + E_{\\text{potential}} \\] Where: \\[ E_{\\text{kinetic}} = \\frac{1}{2} m v^2 \\quad \\text{and} \\quad E_{\\text{potential}} = - \\frac{G M m}{R} \\] Setting total energy to zero for escape: \\[ \\frac{1}{2} m v_2^2 = \\frac{G M m}{R} \\] Simplifying, we find the second cosmic velocity : \\[ v_2 = \\sqrt{\\frac{2GM}{R}} = \\sqrt{2} \\times v_1 \\] 1.3 Third Cosmic Velocity The third cosmic velocity is the speed required to escape the gravitational influence of the solar system , i.e., to escape the Sun\u2019s gravitational pull. This can be determined using the escape velocity from the Sun at a given distance \\( r \\) from the Sun: \\[ v_3 = \\sqrt{v_2^2 + v_{\\text{solar escape}}^2} \\] Where \\( v_{\\text{solar escape}} \\) is the escape velocity from the Sun at the object\u2019s distance: \\[ v_{\\text{solar escape}} = \\sqrt{\\frac{2 G M_{\\text{Sun}}}{r_{\\text{sun}}}} \\] Where: - \\( r_{\\text{sun}} \\) is the distance from the Sun in meters. 2. \ud83d\udcda Constants and Parameters 2.1 Gravitational and Astronomical Constants Parameter Value Description \\( G \\) \\( 6.67430 \\times 10^{-11} \\ \\text{m}^3 \\text{kg}^{-1} \\text{s}^{-2} \\) Gravitational constant \\( M_{\\text{Sun}} \\) \\( 1.989 \\times 10^{30} \\ \\text{kg} \\) Mass of the Sun 1 AU \\( 1.496 \\times 10^{11} \\ \\text{m} \\) Astronomical unit 2.2 Planetary Data Planet Mass \\( M \\) (kg) Radius \\( R \\) (m) Distance to Sun (AU) Earth \\( 5.972 \\times 10^{24} \\) \\( 6.371 \\times 10^6 \\) 1.0 Mars \\( 6.39 \\times 10^{23} \\) \\( 3.3895 \\times 10^6 \\) 1.524 Jupiter \\( 1.898 \\times 10^{27} \\) \\( 6.9911 \\times 10^7 \\) 5.204 3. \ud83e\udde0 Python Code Implementations import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # Gravitational constant (m^3 kg^-1 s^-2) sun_mass = 1.989e30 # Mass of the Sun (kg) AU = 1.496e11 # Astronomical Unit (m) # Planetary data (Mass, Radius, Distance to Sun in AU) bodies = { \"Earth\": (5.972e24, 6.371e6, 1.0), \"Mars\": (6.39e23, 3.3895e6, 1.524), \"Jupiter\": (1.898e27, 6.9911e7, 5.204) } # Function to calculate velocities (v1, v2, v3) def calculate_velocities(mass, radius, distance_to_sun_AU): v1 = np.sqrt(G * mass / radius) v2 = np.sqrt(2) * v1 distance_to_sun = distance_to_sun_AU * AU v_sun_escape = np.sqrt(2 * G * sun_mass / distance_to_sun) v3 = np.sqrt(v2**2 + v_sun_escape**2) return v1, v2, v3 # Results results = {body: calculate_velocities(mass, radius, distance) for body, (mass, radius, distance) in bodies.items()} # Output Results for body, (v1, v2, v3) in results.items(): print(f\"{body}: v1 = {v1/1000:.2f} km/s, v2 = {v2/1000:.2f} km/s, v3 = {v3/1000:.2f} km/s\") # Visualization labels = list(results.keys()) v1_vals = [results[b][0] / 1000 for b in labels] v2_vals = [results[b][1] / 1000 for b in labels] v3_vals = [results[b][2] / 1000 for b in labels] x = np.arange(len(labels)) width = 0.25 fig, ax = plt.subplots(figsize=(8,5)) ax.bar(x - width, v1_vals, width, label='First Cosmic Velocity (v1)') ax.bar(x, v2_vals, width, label='Second Cosmic Velocity (v2)') ax.bar(x + width, v3_vals, width, label='Third Cosmic Velocity (v3)') ax.set_ylabel('Velocity (km/s)') ax.set_title('Cosmic Velocities for Planets') ax.set_xticks(x) ax.set_xticklabels(labels) ax.legend() ax.grid(True) plt.tight_layout() plt.show() Planet First Cosmic Velocity (v1) [km/s] Second Cosmic Velocity (v2) [km/s] Third Cosmic Velocity (v3) [km/s] Earth 7.91 11.18 42.13 Mars 5.03 7.11 34.38 Jupiter 42.12 59.55 66.69","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#cosmic-velocities-theory-implementation-visualizations","text":"This project calculates the first , second , and third cosmic velocities for Earth , Mars , and Jupiter , including mathematical derivations , Python code , and visualizations .","title":"Cosmic Velocities: Theory, Implementation &amp; Visualizations"},{"location":"1%20Physics/2%20Gravity/Problem_2/#1-theoretical-background","text":"","title":"1. \ud83c\udf0c Theoretical Background"},{"location":"1%20Physics/2%20Gravity/Problem_2/#11-first-cosmic-velocity","text":"The first cosmic velocity is the minimum speed required to enter orbit around a celestial body. This is based on the balance between centripetal force and gravitational force . Mathematically, it is derived from the following relation: \\[ F_{\\text{centripetal}} = F_{\\text{gravitational}} \\] Where: \\[ \\frac{m v_1^2}{R} = \\frac{G M m}{R^2} \\] Simplifying for \\( v_1 \\) , we get the first cosmic velocity : \\[ v_1 = \\sqrt{\\frac{GM}{R}} \\] Where: - \\( G \\) = Gravitational constant \\( 6.67430 \\times 10^{-11} \\ \\text{m}^3 \\text{kg}^{-1} \\text{s}^{-2} \\) - \\( M \\) = Mass of the celestial body (kg) - \\( R \\) = Radius of the celestial body (m)","title":"1.1 First Cosmic Velocity"},{"location":"1%20Physics/2%20Gravity/Problem_2/#12-second-cosmic-velocity","text":"The second cosmic velocity is the escape velocity , the speed needed to escape the gravitational pull of the celestial body. This can be derived from the energy conservation between kinetic energy and gravitational potential energy: \\[ E_{\\text{total}} = E_{\\text{kinetic}} + E_{\\text{potential}} \\] Where: \\[ E_{\\text{kinetic}} = \\frac{1}{2} m v^2 \\quad \\text{and} \\quad E_{\\text{potential}} = - \\frac{G M m}{R} \\] Setting total energy to zero for escape: \\[ \\frac{1}{2} m v_2^2 = \\frac{G M m}{R} \\] Simplifying, we find the second cosmic velocity : \\[ v_2 = \\sqrt{\\frac{2GM}{R}} = \\sqrt{2} \\times v_1 \\]","title":"1.2 Second Cosmic Velocity"},{"location":"1%20Physics/2%20Gravity/Problem_2/#13-third-cosmic-velocity","text":"The third cosmic velocity is the speed required to escape the gravitational influence of the solar system , i.e., to escape the Sun\u2019s gravitational pull. This can be determined using the escape velocity from the Sun at a given distance \\( r \\) from the Sun: \\[ v_3 = \\sqrt{v_2^2 + v_{\\text{solar escape}}^2} \\] Where \\( v_{\\text{solar escape}} \\) is the escape velocity from the Sun at the object\u2019s distance: \\[ v_{\\text{solar escape}} = \\sqrt{\\frac{2 G M_{\\text{Sun}}}{r_{\\text{sun}}}} \\] Where: - \\( r_{\\text{sun}} \\) is the distance from the Sun in meters.","title":"1.3 Third Cosmic Velocity"},{"location":"1%20Physics/2%20Gravity/Problem_2/#2-constants-and-parameters","text":"","title":"2. \ud83d\udcda Constants and Parameters"},{"location":"1%20Physics/2%20Gravity/Problem_2/#21-gravitational-and-astronomical-constants","text":"Parameter Value Description \\( G \\) \\( 6.67430 \\times 10^{-11} \\ \\text{m}^3 \\text{kg}^{-1} \\text{s}^{-2} \\) Gravitational constant \\( M_{\\text{Sun}} \\) \\( 1.989 \\times 10^{30} \\ \\text{kg} \\) Mass of the Sun 1 AU \\( 1.496 \\times 10^{11} \\ \\text{m} \\) Astronomical unit","title":"2.1 Gravitational and Astronomical Constants"},{"location":"1%20Physics/2%20Gravity/Problem_2/#22-planetary-data","text":"Planet Mass \\( M \\) (kg) Radius \\( R \\) (m) Distance to Sun (AU) Earth \\( 5.972 \\times 10^{24} \\) \\( 6.371 \\times 10^6 \\) 1.0 Mars \\( 6.39 \\times 10^{23} \\) \\( 3.3895 \\times 10^6 \\) 1.524 Jupiter \\( 1.898 \\times 10^{27} \\) \\( 6.9911 \\times 10^7 \\) 5.204","title":"2.2 Planetary Data"},{"location":"1%20Physics/2%20Gravity/Problem_2/#3-python-code-implementations","text":"import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # Gravitational constant (m^3 kg^-1 s^-2) sun_mass = 1.989e30 # Mass of the Sun (kg) AU = 1.496e11 # Astronomical Unit (m) # Planetary data (Mass, Radius, Distance to Sun in AU) bodies = { \"Earth\": (5.972e24, 6.371e6, 1.0), \"Mars\": (6.39e23, 3.3895e6, 1.524), \"Jupiter\": (1.898e27, 6.9911e7, 5.204) } # Function to calculate velocities (v1, v2, v3) def calculate_velocities(mass, radius, distance_to_sun_AU): v1 = np.sqrt(G * mass / radius) v2 = np.sqrt(2) * v1 distance_to_sun = distance_to_sun_AU * AU v_sun_escape = np.sqrt(2 * G * sun_mass / distance_to_sun) v3 = np.sqrt(v2**2 + v_sun_escape**2) return v1, v2, v3 # Results results = {body: calculate_velocities(mass, radius, distance) for body, (mass, radius, distance) in bodies.items()} # Output Results for body, (v1, v2, v3) in results.items(): print(f\"{body}: v1 = {v1/1000:.2f} km/s, v2 = {v2/1000:.2f} km/s, v3 = {v3/1000:.2f} km/s\") # Visualization labels = list(results.keys()) v1_vals = [results[b][0] / 1000 for b in labels] v2_vals = [results[b][1] / 1000 for b in labels] v3_vals = [results[b][2] / 1000 for b in labels] x = np.arange(len(labels)) width = 0.25 fig, ax = plt.subplots(figsize=(8,5)) ax.bar(x - width, v1_vals, width, label='First Cosmic Velocity (v1)') ax.bar(x, v2_vals, width, label='Second Cosmic Velocity (v2)') ax.bar(x + width, v3_vals, width, label='Third Cosmic Velocity (v3)') ax.set_ylabel('Velocity (km/s)') ax.set_title('Cosmic Velocities for Planets') ax.set_xticks(x) ax.set_xticklabels(labels) ax.legend() ax.grid(True) plt.tight_layout() plt.show() Planet First Cosmic Velocity (v1) [km/s] Second Cosmic Velocity (v2) [km/s] Third Cosmic Velocity (v3) [km/s] Earth 7.91 11.18 42.13 Mars 5.03 7.11 34.38 Jupiter 42.12 59.55 66.69","title":"3. \ud83e\udde0 Python Code Implementations"},{"location":"1%20Physics/2%20Gravity/Problem_3/","text":"# Problem 3 ## Trajectories of a Freely Released Payload Near Earth Motivation When a payload is released from a spacecraft near Earth, its trajectory depends on the initial velocity, position, and the gravitational forces acting on it. These trajectories are crucial for understanding how objects behave in space and for planning satellite deployments, reentry missions, and escape scenarios. Physics Concepts Newton's Law of Gravitation The gravitational force acting on a payload is given by the following equation: \\[ \\vec{F} = -G \\frac{M m}{r^2} \\hat{r} \\] Where: - \\( G = 6.674 \\times 10^{-11} \\, \\text{Nm}^2/\\text{kg}^2 \\) \u2014 Gravitational constant - \\( M \\) \u2014 Earth's mass - \\( m \\) \u2014 Payload's mass - \\( r \\) \u2014 Distance from Earth's center - \\( \\hat{r} \\) \u2014 Unit vector pointing from Earth to the payload Escape Velocity The escape velocity is the minimum velocity needed to break free from Earth's gravitational field: \\[ v_{\\text{esc}} = \\sqrt{\\frac{2GM}{r}} \\] At Earth's surface, the escape velocity is approximately 11.2 km/s . Numerical Simulation in Python Imports and Constants We begin by importing necessary libraries and defining key constants. import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # Gravitational constant [m^3 kg^-1 s^-2] M = 5.972e24 # Mass of Earth [kg] R_earth = 6.371e6 # Radius of Earth [m] ## Initial Conditions In this section, we define the initial conditions for the payload, which includes its altitude, initial position, and initial velocity. # Initial conditions altitude = 300e3 # Altitude from Earth's surface (300 km) r0 = np.array([R_earth + altitude, 0]) # Initial position vector (x, y) v0 = np.array([0, 7700]) # Initial velocity vector (vx, vy) in m/s Time Settings In this section, we define the time settings for the simulation, including the time step ( dt ) and the total simulation time ( T ). # Time settings dt = 1 # Time step (seconds) T = 10000 # Total simulation time (seconds) steps = int(T / dt) # Number of time steps Simulation Function Now, let\u2019s implement the Euler method to numerically integrate the equations of motion and simulate the trajectory of the payload. # Simulation function def simulate(r0, v0, dt, steps): r = np.zeros((steps, 2)) # Position array v = np.zeros((steps, 2)) # Velocity array r[0] = r0 # Set initial position v[0] = v0 # Set initial velocity for i in range(steps - 1): distance = np.linalg.norm(r[i]) # Calculate distance from Earth\u2019s center # Check if the payload has hit the Earth's surface if distance < R_earth: print(f\"Impact with Earth at step {i}, time {i * dt} s\") return r[:i+1] # Calculate the acceleration due to gravity a = -G * M * r[i] / distance**3 v[i + 1] = v[i] + a * dt # Update velocity r[i + 1] = r[i] + v[i + 1] * dt # Update position return r # Return the trajectory Visualization Now, we will run the simulation and plot the resulting trajectory of the payload. # Run the simulation trajectory = simulate(r0, v0, dt, steps) # Plotting the trajectory plt.figure(figsize=(8, 8)) plt.plot(trajectory[:, 0], trajectory[:, 1], label=\"Payload Trajectory\") # Draw Earth earth = plt.Circle((0, 0), R_earth, color='blue', alpha=0.5, label=\"Earth\") plt.gca().add_artist(earth) # Plot formatting plt.xlabel(\"x [m]\") plt.ylabel(\"y [m]\") plt.title(\"Trajectory of a Freely Released Payload\") plt.axis(\"equal\") plt.grid(True) plt.legend() plt.show() Trajectory Types Based on Initial Speed Initial Speed (m/s) Outcome < 7000 Falls back to Earth \u2248 7670 Circular orbit 7000\u201311000 Elliptical orbit \u2248 11200 Parabolic escape > 11200 Hyperbolic escape Conclusion In this project, we modeled the gravitational motion of a payload near Earth and simulated its trajectory using the Euler method . The key takeaways include: Simulation : We calculated the trajectory of a freely released payload, starting at a specific altitude with a given initial velocity. We used the Euler method for numerical integration of the motion under Earth's gravity. Trajectory Types : Based on the initial velocity, we observed different types of trajectories: If the velocity is too low, the payload falls back to Earth. If the velocity is high enough, the payload enters a stable orbit or escapes Earth's gravity. The payload's path could be parabolic, elliptical, or hyperbolic depending on its initial conditions. Visualization : Using matplotlib , we visualized the trajectory of the payload, showing its path relative to Earth\u2019s surface. The simulation results provide a clear understanding of how initial conditions like altitude and velocity affect the trajectory. Real-World Applications : This model can be applied to space missions, satellite deployments, or reentry predictions. Understanding the physics behind these trajectories is vital for designing successful space missions and ensuring the safety of payloads.","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#motivation","text":"When a payload is released from a spacecraft near Earth, its trajectory depends on the initial velocity, position, and the gravitational forces acting on it. These trajectories are crucial for understanding how objects behave in space and for planning satellite deployments, reentry missions, and escape scenarios.","title":"Motivation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#physics-concepts","text":"","title":"Physics Concepts"},{"location":"1%20Physics/2%20Gravity/Problem_3/#newtons-law-of-gravitation","text":"The gravitational force acting on a payload is given by the following equation: \\[ \\vec{F} = -G \\frac{M m}{r^2} \\hat{r} \\] Where: - \\( G = 6.674 \\times 10^{-11} \\, \\text{Nm}^2/\\text{kg}^2 \\) \u2014 Gravitational constant - \\( M \\) \u2014 Earth's mass - \\( m \\) \u2014 Payload's mass - \\( r \\) \u2014 Distance from Earth's center - \\( \\hat{r} \\) \u2014 Unit vector pointing from Earth to the payload","title":"Newton's Law of Gravitation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#escape-velocity","text":"The escape velocity is the minimum velocity needed to break free from Earth's gravitational field: \\[ v_{\\text{esc}} = \\sqrt{\\frac{2GM}{r}} \\] At Earth's surface, the escape velocity is approximately 11.2 km/s .","title":"Escape Velocity"},{"location":"1%20Physics/2%20Gravity/Problem_3/#numerical-simulation-in-python","text":"","title":"Numerical Simulation in Python"},{"location":"1%20Physics/2%20Gravity/Problem_3/#imports-and-constants","text":"We begin by importing necessary libraries and defining key constants. import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # Gravitational constant [m^3 kg^-1 s^-2] M = 5.972e24 # Mass of Earth [kg] R_earth = 6.371e6 # Radius of Earth [m] ## Initial Conditions In this section, we define the initial conditions for the payload, which includes its altitude, initial position, and initial velocity. # Initial conditions altitude = 300e3 # Altitude from Earth's surface (300 km) r0 = np.array([R_earth + altitude, 0]) # Initial position vector (x, y) v0 = np.array([0, 7700]) # Initial velocity vector (vx, vy) in m/s","title":"Imports and Constants"},{"location":"1%20Physics/2%20Gravity/Problem_3/#time-settings","text":"In this section, we define the time settings for the simulation, including the time step ( dt ) and the total simulation time ( T ). # Time settings dt = 1 # Time step (seconds) T = 10000 # Total simulation time (seconds) steps = int(T / dt) # Number of time steps","title":"Time Settings"},{"location":"1%20Physics/2%20Gravity/Problem_3/#simulation-function","text":"Now, let\u2019s implement the Euler method to numerically integrate the equations of motion and simulate the trajectory of the payload. # Simulation function def simulate(r0, v0, dt, steps): r = np.zeros((steps, 2)) # Position array v = np.zeros((steps, 2)) # Velocity array r[0] = r0 # Set initial position v[0] = v0 # Set initial velocity for i in range(steps - 1): distance = np.linalg.norm(r[i]) # Calculate distance from Earth\u2019s center # Check if the payload has hit the Earth's surface if distance < R_earth: print(f\"Impact with Earth at step {i}, time {i * dt} s\") return r[:i+1] # Calculate the acceleration due to gravity a = -G * M * r[i] / distance**3 v[i + 1] = v[i] + a * dt # Update velocity r[i + 1] = r[i] + v[i + 1] * dt # Update position return r # Return the trajectory","title":"Simulation Function"},{"location":"1%20Physics/2%20Gravity/Problem_3/#visualization","text":"Now, we will run the simulation and plot the resulting trajectory of the payload. # Run the simulation trajectory = simulate(r0, v0, dt, steps) # Plotting the trajectory plt.figure(figsize=(8, 8)) plt.plot(trajectory[:, 0], trajectory[:, 1], label=\"Payload Trajectory\") # Draw Earth earth = plt.Circle((0, 0), R_earth, color='blue', alpha=0.5, label=\"Earth\") plt.gca().add_artist(earth) # Plot formatting plt.xlabel(\"x [m]\") plt.ylabel(\"y [m]\") plt.title(\"Trajectory of a Freely Released Payload\") plt.axis(\"equal\") plt.grid(True) plt.legend() plt.show()","title":"Visualization"},{"location":"1%20Physics/2%20Gravity/Problem_3/#trajectory-types-based-on-initial-speed","text":"Initial Speed (m/s) Outcome < 7000 Falls back to Earth \u2248 7670 Circular orbit 7000\u201311000 Elliptical orbit \u2248 11200 Parabolic escape > 11200 Hyperbolic escape","title":"Trajectory Types Based on Initial Speed"},{"location":"1%20Physics/2%20Gravity/Problem_3/#conclusion","text":"In this project, we modeled the gravitational motion of a payload near Earth and simulated its trajectory using the Euler method . The key takeaways include: Simulation : We calculated the trajectory of a freely released payload, starting at a specific altitude with a given initial velocity. We used the Euler method for numerical integration of the motion under Earth's gravity. Trajectory Types : Based on the initial velocity, we observed different types of trajectories: If the velocity is too low, the payload falls back to Earth. If the velocity is high enough, the payload enters a stable orbit or escapes Earth's gravity. The payload's path could be parabolic, elliptical, or hyperbolic depending on its initial conditions. Visualization : Using matplotlib , we visualized the trajectory of the payload, showing its path relative to Earth\u2019s surface. The simulation results provide a clear understanding of how initial conditions like altitude and velocity affect the trajectory. Real-World Applications : This model can be applied to space missions, satellite deployments, or reentry predictions. Understanding the physics behind these trajectories is vital for designing successful space missions and ensuring the safety of payloads.","title":"Conclusion"},{"location":"1%20Physics/3%20Waves/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_2/","text":"Problem 2","title":"Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/7%20Measurements/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"2%20Mathematics/1%20Linear_algebra/","text":"Linear Algebra","title":"Linear Algebra"},{"location":"2%20Mathematics/1%20Linear_algebra/#linear-algebra","text":"","title":"Linear Algebra"},{"location":"2%20Mathematics/2%20Analytic_geometry/","text":"Analytic geometry","title":"Analytic geometry"},{"location":"2%20Mathematics/2%20Analytic_geometry/#analytic-geometry","text":"","title":"Analytic geometry"},{"location":"2%20Mathematics/3%20Calculus/","text":"Calculus","title":"Calculus"},{"location":"2%20Mathematics/3%20Calculus/#calculus","text":"","title":"Calculus"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/","text":"Set Theory","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/#set-theory","text":"","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/","text":"Relations","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/#relations","text":"","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/","text":"Functions","title":"Functions"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/#functions","text":"","title":"Functions"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/","text":"Combinatorics","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/#combinatorics","text":"","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/","text":"Number Theory","title":"Number Theory"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/#number-theory","text":"","title":"Number Theory"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/","text":"Sequences and Series","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/#sequences-and-series","text":"","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/","text":"Induction","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/#induction","text":"","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/","text":"Recurrence","title":"Recurrence"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/#recurrence","text":"","title":"Recurrence"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/","text":"Graph Theory","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/#graph-theory","text":"","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/","text":"Logic","title":"Logic"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/#logic","text":"","title":"Logic"}]}