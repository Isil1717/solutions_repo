{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Technical setup Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft) Useful links Python Miniconda Documentation Google Colab How to use this repository Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW Where can I find the problems? Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Introduction"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#technical-setup","text":"Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft)","title":"Technical setup"},{"location":"#useful-links","text":"Python Miniconda Documentation Google Colab","title":"Useful links"},{"location":"#how-to-use-this-repository","text":"Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW","title":"How to use this repository"},{"location":"#where-can-i-find-the-problems","text":"Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Where can I find the problems?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/","text":"\u2699\ufe0f Mechanics \u2013 Problem 1 \ud83e\udde0 Mechanics Problem 1: Investigating the Range as a Function of the Angle of Projection \ud83c\udfaf Problem Overview We study the dependence of the horizontal range of a projectile on the launch angle \\( \\theta \\) , taking into account physical parameters such as: Initial velocity \\( v_0 \\) Gravitational acceleration \\( g \\) Air resistance (optional) Launch height \\( h \\) Inclined terrain \ud83d\udcd0 1. Ideal Projectile Motion (No Air Resistance) Coordinate System We decompose the motion into horizontal and vertical components. Equations of Motion: Initial velocity components: \\[ v_{0x} = v_0 \\cos(\\theta), \\quad v_{0y} = v_0 \\sin(\\theta) \\] Displacements: \\[ x(t) = v_0 \\cos(\\theta) \\cdot t \\] \\[ y(t) = v_0 \\sin(\\theta) \\cdot t - \\frac{1}{2} g t^2 \\] Time of flight (when \\( y = 0 \\) ): \\[ T = \\frac{2v_0 \\sin(\\theta)}{g} \\] Range: \\[ R(\\theta) = x(T) = \\frac{v_0^2 \\sin(2\\theta)}{g} \\] \ud83e\uddee 2. Python Implementation (Ideal Case) import numpy as np import matplotlib.pyplot as plt g = 9.81 # gravity [m/s^2] angles_deg = np.linspace(0, 90, 500) angles_rad = np.radians(angles_deg) def ideal_range(v0, theta): return (v0**2 * np.sin(2 * theta)) / g v0_values = [10, 20, 30] plt.figure(figsize=(10, 6)) for v0 in v0_values: R = ideal_range(v0, angles_rad) plt.plot(angles_deg, R, label=f\"$v_0 = {v0}$ m/s\") plt.title(\"Range vs Angle (Ideal Case)\") plt.xlabel(\"Launch Angle (degrees)\") plt.ylabel(\"Range (meters)\") plt.legend() plt.grid(True) plt.savefig(\"ideal_range.png\") plt.show() \ud83c\udfd4\ufe0f 3. Uneven Terrain (Inclined Plane) Let the ground be inclined by angle \\( \\alpha \\) . The effective launch angle becomes \\( \\theta - \\alpha \\) , and time of flight changes accordingly. Time to impact (from projectile to slope): \\[ T = \\frac{2 v_0 \\sin(\\theta - \\alpha)}{g \\cos(\\alpha)} \\] Modified range on inclined plane: \\[ R = \\frac{v_0^2 \\sin(2(\\theta - \\alpha))}{g \\cos(\\alpha)} \\] This is derived assuming a symmetrical trajectory in the slope frame. \ud83c\udf2c\ufe0f 4. Air Resistance (Linear Drag) When air resistance is considered, the force becomes: \\[ \\vec{F}_{\\text{drag}} = -k \\vec{v} \\] Where \\( k \\) is the drag coefficient. Equations of motion: \\[ \\frac{d v_x}{dt} = -\\frac{k}{m} v_x, \\quad \\frac{d v_y}{dt} = -g - \\frac{k}{m} v_y \\] Solutions: \\[ v_x(t) = v_{0x} e^{-kt/m}, \\quad v_y(t) = \\left(v_{0y} + \\frac{mg}{k} \\right) e^{-kt/m} - \\frac{mg}{k} \\] Position functions (after integration): \\[ x(t) = \\frac{m v_{0x}}{k} \\left(1 - e^{-kt/m} \\right) \\] \\[ y(t) = \\left(v_{0y} + \\frac{mg}{k} \\right) \\cdot \\frac{m}{k} \\left(1 - e^{-kt/m} \\right) - \\frac{mg}{k} \\cdot t \\] These equations require numerical solutions for time of flight and range.","title":"\u2699\ufe0f Mechanics \u2013 Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#mechanics-problem-1","text":"","title":"\u2699\ufe0f Mechanics \u2013 Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#mechanics-problem-1-investigating-the-range-as-a-function-of-the-angle-of-projection","text":"","title":"\ud83e\udde0 Mechanics Problem 1: Investigating the Range as a Function of the Angle of Projection"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#problem-overview","text":"We study the dependence of the horizontal range of a projectile on the launch angle \\( \\theta \\) , taking into account physical parameters such as: Initial velocity \\( v_0 \\) Gravitational acceleration \\( g \\) Air resistance (optional) Launch height \\( h \\) Inclined terrain","title":"\ud83c\udfaf Problem Overview"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#1-ideal-projectile-motion-no-air-resistance","text":"","title":"\ud83d\udcd0 1. Ideal Projectile Motion (No Air Resistance)"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#coordinate-system","text":"We decompose the motion into horizontal and vertical components.","title":"Coordinate System"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#equations-of-motion","text":"Initial velocity components: \\[ v_{0x} = v_0 \\cos(\\theta), \\quad v_{0y} = v_0 \\sin(\\theta) \\] Displacements: \\[ x(t) = v_0 \\cos(\\theta) \\cdot t \\] \\[ y(t) = v_0 \\sin(\\theta) \\cdot t - \\frac{1}{2} g t^2 \\] Time of flight (when \\( y = 0 \\) ): \\[ T = \\frac{2v_0 \\sin(\\theta)}{g} \\] Range: \\[ R(\\theta) = x(T) = \\frac{v_0^2 \\sin(2\\theta)}{g} \\]","title":"Equations of Motion:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#2-python-implementation-ideal-case","text":"import numpy as np import matplotlib.pyplot as plt g = 9.81 # gravity [m/s^2] angles_deg = np.linspace(0, 90, 500) angles_rad = np.radians(angles_deg) def ideal_range(v0, theta): return (v0**2 * np.sin(2 * theta)) / g v0_values = [10, 20, 30] plt.figure(figsize=(10, 6)) for v0 in v0_values: R = ideal_range(v0, angles_rad) plt.plot(angles_deg, R, label=f\"$v_0 = {v0}$ m/s\") plt.title(\"Range vs Angle (Ideal Case)\") plt.xlabel(\"Launch Angle (degrees)\") plt.ylabel(\"Range (meters)\") plt.legend() plt.grid(True) plt.savefig(\"ideal_range.png\") plt.show()","title":"\ud83e\uddee 2. Python Implementation (Ideal Case)"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#3-uneven-terrain-inclined-plane","text":"Let the ground be inclined by angle \\( \\alpha \\) . The effective launch angle becomes \\( \\theta - \\alpha \\) , and time of flight changes accordingly.","title":"\ud83c\udfd4\ufe0f 3. Uneven Terrain (Inclined Plane)"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#time-to-impact-from-projectile-to-slope","text":"\\[ T = \\frac{2 v_0 \\sin(\\theta - \\alpha)}{g \\cos(\\alpha)} \\]","title":"Time to impact (from projectile to slope):"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#modified-range-on-inclined-plane","text":"\\[ R = \\frac{v_0^2 \\sin(2(\\theta - \\alpha))}{g \\cos(\\alpha)} \\] This is derived assuming a symmetrical trajectory in the slope frame.","title":"Modified range on inclined plane:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#4-air-resistance-linear-drag","text":"When air resistance is considered, the force becomes: \\[ \\vec{F}_{\\text{drag}} = -k \\vec{v} \\] Where \\( k \\) is the drag coefficient.","title":"\ud83c\udf2c\ufe0f 4. Air Resistance (Linear Drag)"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#equations-of-motion_1","text":"\\[ \\frac{d v_x}{dt} = -\\frac{k}{m} v_x, \\quad \\frac{d v_y}{dt} = -g - \\frac{k}{m} v_y \\]","title":"Equations of motion:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#solutions","text":"\\[ v_x(t) = v_{0x} e^{-kt/m}, \\quad v_y(t) = \\left(v_{0y} + \\frac{mg}{k} \\right) e^{-kt/m} - \\frac{mg}{k} \\]","title":"Solutions:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#position-functions-after-integration","text":"\\[ x(t) = \\frac{m v_{0x}}{k} \\left(1 - e^{-kt/m} \\right) \\] \\[ y(t) = \\left(v_{0y} + \\frac{mg}{k} \\right) \\cdot \\frac{m}{k} \\left(1 - e^{-kt/m} \\right) - \\frac{mg}{k} \\cdot t \\] These equations require numerical solutions for time of flight and range.","title":"Position functions (after integration):"},{"location":"1%20Physics/1%20Mechanics/Problem_2/","text":"Problem 2 Investigating the Dynamics of a Forced Damped Pendulum Introduction The forced damped pendulum is a classic example of a non-linear oscillatory system. The system demonstrates a rich variety of behaviors, including resonance, chaos, and quasiperiodic motion, depending on the interplay between damping, restoring forces, and external driving forces. The dynamics of this system are governed by the second-order differential equation: \\[ \\frac{d^2 \\theta}{dt^2} + b \\frac{d\\theta}{dt} + \\frac{g}{L} \\sin(\\theta) = A \\cos(\\omega t) \\] Where: - \\( \\theta(t) \\) is the angular displacement, - \\( b \\) is the damping coefficient, - \\( g \\) is the gravitational acceleration, - \\( L \\) is the length of the pendulum, - \\( A \\) is the amplitude of the external driving force, - \\( \\omega \\) is the angular frequency of the external force. Small-Angle Approximation For small oscillations, we use the approximation \\( \\sin(\\theta) \\approx \\theta \\) , leading to a linearized form of the equation: \\[ \\frac{d^2 \\theta}{dt^2} + b \\frac{d \\theta}{dt} + \\frac{g}{L} \\theta = A \\cos(\\omega t) \\] This approximation simplifies the analysis, and the system behaves similarly to a driven damped harmonic oscillator. The natural frequency of the undamped system is: \\[ \\omega_0 = \\sqrt{\\frac{g}{L}} \\] At resonance, when the driving frequency \\( \\omega \\) matches the natural frequency \\( \\omega_0 \\) , the amplitude of oscillations can increase dramatically. This condition is given by: \\[ \\omega_{\\text{res}} = \\sqrt{\\frac{g}{L}} \\] Numerical Simulation To simulate the dynamics of the forced damped pendulum, we rewrite the second-order differential equation as a system of first-order equations: Let: - \\( \\theta_1 = \\theta \\) , - \\( \\theta_2 = \\frac{d \\theta}{dt} \\) . The system becomes: \\[ \\frac{d \\theta_1}{dt} = \\theta_2 \\] \\[ \\frac{d \\theta_2}{dt} = -b \\theta_2 - \\frac{g}{L} \\sin(\\theta_1) + A \\cos(\\omega t) \\] This system can be solved numerically using methods like the Runge-Kutta algorithm to obtain the time evolution of \\( \\theta_1(t) \\) and \\( \\theta_2(t) \\) . Effects of Damping and Driving Forces Damping Coefficient \\( b \\) The damping coefficient \\( b \\) controls the rate at which the oscillations decay. As \\( b \\) increases, the system loses energy more rapidly, causing the amplitude of oscillations to decrease. When \\( b \\) is large enough, the system eventually reaches a steady state with no oscillations. For small damping \\( b \\) , resonance phenomena occur, and the system can exhibit large oscillations if the driving frequency \\( \\omega \\) is close to the natural frequency of the system. The modified equation for damping is: \\[ \\frac{d^2 \\theta}{dt^2} + b \\frac{d \\theta}{dt} + \\frac{g}{L} \\theta = A \\cos(\\omega t) \\] Driving Force Amplitude \\( A \\) The amplitude of the driving force \\( A \\) determines how much energy is supplied to the system. As \\( A \\) increases, the amplitude of oscillations increases. If \\( A \\) is large enough and \\( \\omega \\) is close to \\( \\omega_{\\text{res}} \\) , the system enters a state of large amplitude oscillations, potentially leading to resonance. Driving Frequency \\( \\omega \\) The driving frequency \\( \\omega \\) plays a crucial role in determining the behavior of the system. At resonance, when \\( \\omega = \\omega_{\\text{res}} \\) , the system's response is maximal, and the oscillations grow significantly. The system exhibits a peak in amplitude at this frequency. For frequencies far from resonance, the oscillations have much smaller amplitudes. Chaos and Bifurcations As the parameters \\( A \\) (driving amplitude) and \\( \\omega \\) (driving frequency) are varied, the system can undergo bifurcations, where small changes in parameters lead to large changes in the system\u2019s behavior. The bifurcation diagram can reveal transitions from periodic to chaotic motion. In a bifurcation diagram, as \\( A \\) or \\( \\omega \\) increases, the system may exhibit a sudden transition to chaotic behavior. This is due to sensitive dependence on initial conditions, a hallmark of chaos. Lyapunov Exponent The Lyapunov exponent measures the rate at which nearby trajectories in phase space diverge, and is a key indicator of chaos. A positive Lyapunov exponent indicates chaotic behavior, while a negative value suggests stable periodic motion. It is defined as: \\[ \\lambda = \\lim_{t \\to \\infty} \\frac{1}{t} \\ln \\left( \\frac{|\\delta(t)|}{|\\delta(0)|} \\right) \\] Where: - \\( \\delta(t) \\) is the separation between two nearby trajectories at time \\( t \\) , - \\( \\delta(0) \\) is the initial separation. A positive Lyapunov exponent means that the system is chaotic and exhibits exponential divergence of nearby trajectories. Conclusion The dynamics of the forced damped pendulum provide a rich example of nonlinear behavior, including resonance, chaos, and periodic motion. By varying the damping coefficient, driving amplitude, and driving frequency, we observe a variety of dynamic responses, from stable oscillations to chaotic motion. Numerical simulations and analytical techniques such as the Lyapunov exponent and bifurcation diagrams allow for a deeper understanding of these behaviors, with applications in engineering, biomechanics, and electronics. import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # --- Physical parameters --- g = 9.81 # gravitational acceleration (m/s^2) L = 1.0 # pendulum length (m) b = 0.5 # damping coefficient A = 1.2 # amplitude of the driving force omega = 2.0 # angular frequency of the driving force # --- Time settings --- t_start = 0.0 t_end = 50.0 dt = 0.01 t_eval = np.arange(t_start, t_end, dt) # --- Initial conditions --- theta0 = 0.2 # initial angle (radians) theta_dot0 = 0.0 # initial angular velocity (rad/s) initial_state = [theta0, theta_dot0] # --- Differential equations --- def forced_damped_pendulum(t, y): theta, theta_dot = y dtheta_dt = theta_dot dtheta_dot_dt = -b * theta_dot - (g / L) * np.sin(theta) + A * np.cos(omega * t) return [dtheta_dt, dtheta_dot_dt] # --- Solve the system --- sol = solve_ivp( fun=forced_damped_pendulum, t_span=(t_start, t_end), y0=initial_state, t_eval=t_eval, method='RK45' ) # --- Plot the results --- plt.figure(figsize=(10, 5)) plt.plot(sol.t, sol.y[0], label='\u03b8(t) [rad]', color='darkblue') plt.xlabel('Time [s]') plt.ylabel('Angle \u03b8 [rad]') plt.title('Forced Damped Pendulum Simulation') plt.grid(True) plt.legend() plt.tight_layout() plt.show()","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#investigating-the-dynamics-of-a-forced-damped-pendulum","text":"","title":"Investigating the Dynamics of a Forced Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#introduction","text":"The forced damped pendulum is a classic example of a non-linear oscillatory system. The system demonstrates a rich variety of behaviors, including resonance, chaos, and quasiperiodic motion, depending on the interplay between damping, restoring forces, and external driving forces. The dynamics of this system are governed by the second-order differential equation: \\[ \\frac{d^2 \\theta}{dt^2} + b \\frac{d\\theta}{dt} + \\frac{g}{L} \\sin(\\theta) = A \\cos(\\omega t) \\] Where: - \\( \\theta(t) \\) is the angular displacement, - \\( b \\) is the damping coefficient, - \\( g \\) is the gravitational acceleration, - \\( L \\) is the length of the pendulum, - \\( A \\) is the amplitude of the external driving force, - \\( \\omega \\) is the angular frequency of the external force.","title":"Introduction"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#small-angle-approximation","text":"For small oscillations, we use the approximation \\( \\sin(\\theta) \\approx \\theta \\) , leading to a linearized form of the equation: \\[ \\frac{d^2 \\theta}{dt^2} + b \\frac{d \\theta}{dt} + \\frac{g}{L} \\theta = A \\cos(\\omega t) \\] This approximation simplifies the analysis, and the system behaves similarly to a driven damped harmonic oscillator. The natural frequency of the undamped system is: \\[ \\omega_0 = \\sqrt{\\frac{g}{L}} \\] At resonance, when the driving frequency \\( \\omega \\) matches the natural frequency \\( \\omega_0 \\) , the amplitude of oscillations can increase dramatically. This condition is given by: \\[ \\omega_{\\text{res}} = \\sqrt{\\frac{g}{L}} \\]","title":"Small-Angle Approximation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#numerical-simulation","text":"To simulate the dynamics of the forced damped pendulum, we rewrite the second-order differential equation as a system of first-order equations: Let: - \\( \\theta_1 = \\theta \\) , - \\( \\theta_2 = \\frac{d \\theta}{dt} \\) . The system becomes: \\[ \\frac{d \\theta_1}{dt} = \\theta_2 \\] \\[ \\frac{d \\theta_2}{dt} = -b \\theta_2 - \\frac{g}{L} \\sin(\\theta_1) + A \\cos(\\omega t) \\] This system can be solved numerically using methods like the Runge-Kutta algorithm to obtain the time evolution of \\( \\theta_1(t) \\) and \\( \\theta_2(t) \\) .","title":"Numerical Simulation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#effects-of-damping-and-driving-forces","text":"","title":"Effects of Damping and Driving Forces"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#damping-coefficient-b","text":"The damping coefficient \\( b \\) controls the rate at which the oscillations decay. As \\( b \\) increases, the system loses energy more rapidly, causing the amplitude of oscillations to decrease. When \\( b \\) is large enough, the system eventually reaches a steady state with no oscillations. For small damping \\( b \\) , resonance phenomena occur, and the system can exhibit large oscillations if the driving frequency \\( \\omega \\) is close to the natural frequency of the system. The modified equation for damping is: \\[ \\frac{d^2 \\theta}{dt^2} + b \\frac{d \\theta}{dt} + \\frac{g}{L} \\theta = A \\cos(\\omega t) \\]","title":"Damping Coefficient \\( b \\)"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#driving-force-amplitude-a","text":"The amplitude of the driving force \\( A \\) determines how much energy is supplied to the system. As \\( A \\) increases, the amplitude of oscillations increases. If \\( A \\) is large enough and \\( \\omega \\) is close to \\( \\omega_{\\text{res}} \\) , the system enters a state of large amplitude oscillations, potentially leading to resonance.","title":"Driving Force Amplitude \\( A \\)"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#driving-frequency-omega","text":"The driving frequency \\( \\omega \\) plays a crucial role in determining the behavior of the system. At resonance, when \\( \\omega = \\omega_{\\text{res}} \\) , the system's response is maximal, and the oscillations grow significantly. The system exhibits a peak in amplitude at this frequency. For frequencies far from resonance, the oscillations have much smaller amplitudes.","title":"Driving Frequency \\( \\omega \\)"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#chaos-and-bifurcations","text":"As the parameters \\( A \\) (driving amplitude) and \\( \\omega \\) (driving frequency) are varied, the system can undergo bifurcations, where small changes in parameters lead to large changes in the system\u2019s behavior. The bifurcation diagram can reveal transitions from periodic to chaotic motion. In a bifurcation diagram, as \\( A \\) or \\( \\omega \\) increases, the system may exhibit a sudden transition to chaotic behavior. This is due to sensitive dependence on initial conditions, a hallmark of chaos.","title":"Chaos and Bifurcations"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#lyapunov-exponent","text":"The Lyapunov exponent measures the rate at which nearby trajectories in phase space diverge, and is a key indicator of chaos. A positive Lyapunov exponent indicates chaotic behavior, while a negative value suggests stable periodic motion. It is defined as: \\[ \\lambda = \\lim_{t \\to \\infty} \\frac{1}{t} \\ln \\left( \\frac{|\\delta(t)|}{|\\delta(0)|} \\right) \\] Where: - \\( \\delta(t) \\) is the separation between two nearby trajectories at time \\( t \\) , - \\( \\delta(0) \\) is the initial separation. A positive Lyapunov exponent means that the system is chaotic and exhibits exponential divergence of nearby trajectories.","title":"Lyapunov Exponent"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#conclusion","text":"The dynamics of the forced damped pendulum provide a rich example of nonlinear behavior, including resonance, chaos, and periodic motion. By varying the damping coefficient, driving amplitude, and driving frequency, we observe a variety of dynamic responses, from stable oscillations to chaotic motion. Numerical simulations and analytical techniques such as the Lyapunov exponent and bifurcation diagrams allow for a deeper understanding of these behaviors, with applications in engineering, biomechanics, and electronics. import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # --- Physical parameters --- g = 9.81 # gravitational acceleration (m/s^2) L = 1.0 # pendulum length (m) b = 0.5 # damping coefficient A = 1.2 # amplitude of the driving force omega = 2.0 # angular frequency of the driving force # --- Time settings --- t_start = 0.0 t_end = 50.0 dt = 0.01 t_eval = np.arange(t_start, t_end, dt) # --- Initial conditions --- theta0 = 0.2 # initial angle (radians) theta_dot0 = 0.0 # initial angular velocity (rad/s) initial_state = [theta0, theta_dot0] # --- Differential equations --- def forced_damped_pendulum(t, y): theta, theta_dot = y dtheta_dt = theta_dot dtheta_dot_dt = -b * theta_dot - (g / L) * np.sin(theta) + A * np.cos(omega * t) return [dtheta_dt, dtheta_dot_dt] # --- Solve the system --- sol = solve_ivp( fun=forced_damped_pendulum, t_span=(t_start, t_end), y0=initial_state, t_eval=t_eval, method='RK45' ) # --- Plot the results --- plt.figure(figsize=(10, 5)) plt.plot(sol.t, sol.y[0], label='\u03b8(t) [rad]', color='darkblue') plt.xlabel('Time [s]') plt.ylabel('Angle \u03b8 [rad]') plt.title('Forced Damped Pendulum Simulation') plt.grid(True) plt.legend() plt.tight_layout() plt.show()","title":"Conclusion"},{"location":"1%20Physics/2%20Gravity/Problem_1/","text":"Problem 1 Kepler's Third Law: Orbital Period and Radius Motivation In celestial mechanics, Kepler's Third Law describes a fundamental connection between the orbital period and the orbital radius of a body moving around a central mass. This law allows us to estimate the structure and scale of planetary systems, including our own Solar System. Kepler discovered this empirical law from observations, and later Newton derived it from the law of universal gravitation. It is one of the most elegant and powerful tools in astrophysics. Derivation from Newtonian Mechanics Let a small mass \\( m \\) orbit a massive central body of mass \\( M \\) (e.g., the Earth around the Sun) in a circular orbit of radius \\( r \\) . The gravitational force provides the centripetal acceleration : \\[ F_{\\text{gravity}} = \\frac{G M m}{r^2}, \\quad F_{\\text{centripetal}} = \\frac{m v^2}{r} \\] Equating the two forces: \\[ \\frac{G M m}{r^2} = \\frac{m v^2}{r} \\] Simplifying and solving for orbital speed \\( v \\) : \\[ v^2 = \\frac{G M}{r} \\] The orbital period \\( T \\) is the time to complete one full orbit, which is the circumference divided by speed: \\[ T = \\frac{2\\pi r}{v} \\] Substitute the expression for \\( v \\) : \\[ T = 2\\pi r \\sqrt{\\frac{r}{G M}} = 2\\pi \\sqrt{\\frac{r^3}{G M}} \\] Now squaring both sides: \\[ T^2 = \\frac{4\\pi^2}{G M} \\cdot r^3 \\] This is the mathematical form of Kepler's Third Law : \\[ T^2 \\propto r^3 \\] The proportionality constant depends only on the mass \\( M \\) of the central object. Implications of Kepler's Law Universal Relationship : All bodies orbiting the same central mass follow the same \\( T^2/r^3 \\) ratio. Comparative Analysis : Knowing \\( T \\) and \\( r \\) for one object allows us to predict them for another. Mass Estimation : Rearranging the equation allows for calculating the mass of a star or planet: \\[ M = \\frac{4\\pi^2 r^3}{G T^2} \\] Real-World Examples Example 1: The Moon's Orbit Around Earth Radius: \\( r = 3.84 \\times 10^8 \\) m Period: \\( T = 27.3 \\) days \\( \\approx 2.36 \\times 10^6 \\) s Using Kepler's Law: \\[ T^2 = \\frac{4\\pi^2 r^3}{G M_{\\text{Earth}}} \\] This checks out when we use Earth\u2019s mass \\( M = 5.97 \\times 10^{24} \\, \\text{kg} \\) . \u2609 Example 2: Planets Around the Sun Planet \\( r \\) (AU) \\( T \\) (years) \\( T^2 \\) \\( r^3 \\) Mercury 0.39 0.24 0.0576 0.0593 Earth 1.00 1.00 1.0000 1.0000 Jupiter 5.20 11.86 140.7 140.6 We observe: \\[ \\frac{T^2}{r^3} \\approx \\text{constant} \\] Python Simulation: Numerical Verification import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # m^3 kg^-1 s^-2 M_sun = 1.989e30 # kg # Generate orbital radii from 0.1 AU to 5 AU (converted to meters) AU = 1.496e11 # meters radii = np.linspace(0.1 * AU, 5 * AU, 100) T_squared = (4 * np.pi**2 * radii**3) / (G * M_sun) T_days = np.sqrt(T_squared) / (60 * 60 * 24) # Plot T^2 vs r^3 plt.figure(figsize=(8,6)) plt.plot(radii**3, T_squared, label=r\"$T^2$ vs $r^3$\", color='blue') plt.xlabel(r\"Orbital Radius Cubed ($r^3$) [$\\mathrm{m}^3$]\") plt.ylabel(r\"Orbital Period Squared ($T^2$) [$\\mathrm{s}^2$]\") plt.title(\"Kepler's Third Law Simulation\") plt.grid(True) plt.legend() plt.tight_layout() plt.show() Visualization & Analysis The plot above shows a linear relationship between \\( T^2 \\) and \\( r^3 \\) , confirming the theoretical expectation from Kepler\u2019s Third Law. To quantify: from scipy.stats import linregress slope, intercept, r_value, _, _ = linregress(radii**3, T_squared) print(\"Slope:\", slope) print(\"R^2:\", r_value**2) An \\( R^2 \\) value near 1 confirms an excellent fit. Extension to Elliptical Orbits Kepler originally formulated his third law for elliptical orbits , using the semi-major axis \\( a \\) instead of radius \\( r \\) : \\[ T^2 = \\frac{4\\pi^2 a^3}{G M} \\] This form still holds for non-circular , but bound orbits like those of comets, satellites, and binary stars. The key is to replace radius with semi-major axis . Summary We derived Kepler's Third Law from Newton's gravitation. We confirmed the relationship numerically using Python. We discussed real-world systems where the law is applicable. The law is essential for orbital mechanics , space missions , and planetary astronomy . Further Exploration Model elliptical orbits and test the same law using the semi-major axis. Include perturbations (e.g., other planets' gravity). Explore relativistic corrections (e.g., Mercury\u2019s precession).","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#problem-1","text":"Kepler's Third Law: Orbital Period and Radius","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#motivation","text":"In celestial mechanics, Kepler's Third Law describes a fundamental connection between the orbital period and the orbital radius of a body moving around a central mass. This law allows us to estimate the structure and scale of planetary systems, including our own Solar System. Kepler discovered this empirical law from observations, and later Newton derived it from the law of universal gravitation. It is one of the most elegant and powerful tools in astrophysics.","title":"Motivation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#derivation-from-newtonian-mechanics","text":"Let a small mass \\( m \\) orbit a massive central body of mass \\( M \\) (e.g., the Earth around the Sun) in a circular orbit of radius \\( r \\) . The gravitational force provides the centripetal acceleration : \\[ F_{\\text{gravity}} = \\frac{G M m}{r^2}, \\quad F_{\\text{centripetal}} = \\frac{m v^2}{r} \\] Equating the two forces: \\[ \\frac{G M m}{r^2} = \\frac{m v^2}{r} \\] Simplifying and solving for orbital speed \\( v \\) : \\[ v^2 = \\frac{G M}{r} \\] The orbital period \\( T \\) is the time to complete one full orbit, which is the circumference divided by speed: \\[ T = \\frac{2\\pi r}{v} \\] Substitute the expression for \\( v \\) : \\[ T = 2\\pi r \\sqrt{\\frac{r}{G M}} = 2\\pi \\sqrt{\\frac{r^3}{G M}} \\] Now squaring both sides: \\[ T^2 = \\frac{4\\pi^2}{G M} \\cdot r^3 \\] This is the mathematical form of Kepler's Third Law : \\[ T^2 \\propto r^3 \\] The proportionality constant depends only on the mass \\( M \\) of the central object.","title":"Derivation from Newtonian Mechanics"},{"location":"1%20Physics/2%20Gravity/Problem_1/#implications-of-keplers-law","text":"Universal Relationship : All bodies orbiting the same central mass follow the same \\( T^2/r^3 \\) ratio. Comparative Analysis : Knowing \\( T \\) and \\( r \\) for one object allows us to predict them for another. Mass Estimation : Rearranging the equation allows for calculating the mass of a star or planet: \\[ M = \\frac{4\\pi^2 r^3}{G T^2} \\]","title":"Implications of Kepler's Law"},{"location":"1%20Physics/2%20Gravity/Problem_1/#real-world-examples","text":"","title":"Real-World Examples"},{"location":"1%20Physics/2%20Gravity/Problem_1/#example-1-the-moons-orbit-around-earth","text":"Radius: \\( r = 3.84 \\times 10^8 \\) m Period: \\( T = 27.3 \\) days \\( \\approx 2.36 \\times 10^6 \\) s Using Kepler's Law: \\[ T^2 = \\frac{4\\pi^2 r^3}{G M_{\\text{Earth}}} \\] This checks out when we use Earth\u2019s mass \\( M = 5.97 \\times 10^{24} \\, \\text{kg} \\) .","title":"Example 1: The Moon's Orbit Around Earth"},{"location":"1%20Physics/2%20Gravity/Problem_1/#example-2-planets-around-the-sun","text":"Planet \\( r \\) (AU) \\( T \\) (years) \\( T^2 \\) \\( r^3 \\) Mercury 0.39 0.24 0.0576 0.0593 Earth 1.00 1.00 1.0000 1.0000 Jupiter 5.20 11.86 140.7 140.6 We observe: \\[ \\frac{T^2}{r^3} \\approx \\text{constant} \\]","title":"\u2609 Example 2: Planets Around the Sun"},{"location":"1%20Physics/2%20Gravity/Problem_1/#python-simulation-numerical-verification","text":"import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # m^3 kg^-1 s^-2 M_sun = 1.989e30 # kg # Generate orbital radii from 0.1 AU to 5 AU (converted to meters) AU = 1.496e11 # meters radii = np.linspace(0.1 * AU, 5 * AU, 100) T_squared = (4 * np.pi**2 * radii**3) / (G * M_sun) T_days = np.sqrt(T_squared) / (60 * 60 * 24) # Plot T^2 vs r^3 plt.figure(figsize=(8,6)) plt.plot(radii**3, T_squared, label=r\"$T^2$ vs $r^3$\", color='blue') plt.xlabel(r\"Orbital Radius Cubed ($r^3$) [$\\mathrm{m}^3$]\") plt.ylabel(r\"Orbital Period Squared ($T^2$) [$\\mathrm{s}^2$]\") plt.title(\"Kepler's Third Law Simulation\") plt.grid(True) plt.legend() plt.tight_layout() plt.show()","title":"Python Simulation: Numerical Verification"},{"location":"1%20Physics/2%20Gravity/Problem_1/#visualization-analysis","text":"The plot above shows a linear relationship between \\( T^2 \\) and \\( r^3 \\) , confirming the theoretical expectation from Kepler\u2019s Third Law. To quantify: from scipy.stats import linregress slope, intercept, r_value, _, _ = linregress(radii**3, T_squared) print(\"Slope:\", slope) print(\"R^2:\", r_value**2) An \\( R^2 \\) value near 1 confirms an excellent fit.","title":"Visualization &amp; Analysis"},{"location":"1%20Physics/2%20Gravity/Problem_1/#extension-to-elliptical-orbits","text":"Kepler originally formulated his third law for elliptical orbits , using the semi-major axis \\( a \\) instead of radius \\( r \\) : \\[ T^2 = \\frac{4\\pi^2 a^3}{G M} \\] This form still holds for non-circular , but bound orbits like those of comets, satellites, and binary stars. The key is to replace radius with semi-major axis .","title":"Extension to Elliptical Orbits"},{"location":"1%20Physics/2%20Gravity/Problem_1/#summary","text":"We derived Kepler's Third Law from Newton's gravitation. We confirmed the relationship numerically using Python. We discussed real-world systems where the law is applicable. The law is essential for orbital mechanics , space missions , and planetary astronomy .","title":"Summary"},{"location":"1%20Physics/2%20Gravity/Problem_1/#further-exploration","text":"Model elliptical orbits and test the same law using the semi-major axis. Include perturbations (e.g., other planets' gravity). Explore relativistic corrections (e.g., Mercury\u2019s precession).","title":"Further Exploration"},{"location":"1%20Physics/2%20Gravity/Problem_2/","text":"Problem 2 Cosmic Velocities: Theory, Implementation & Visualizations This project calculates the first , second , and third cosmic velocities for Earth , Mars , and Jupiter , including mathematical derivations , Python code , and visualizations . 1. \ud83c\udf0c Theoretical Background 1.1 First Cosmic Velocity The first cosmic velocity is the minimum speed required to enter orbit around a celestial body. This is based on the balance between centripetal force and gravitational force . Mathematically, it is derived from the following relation: \\[ F_{\\text{centripetal}} = F_{\\text{gravitational}} \\] Where: \\[ \\frac{m v_1^2}{R} = \\frac{G M m}{R^2} \\] Simplifying for \\( v_1 \\) , we get the first cosmic velocity : \\[ v_1 = \\sqrt{\\frac{GM}{R}} \\] Where: - \\( G \\) = Gravitational constant \\( 6.67430 \\times 10^{-11} \\ \\text{m}^3 \\text{kg}^{-1} \\text{s}^{-2} \\) - \\( M \\) = Mass of the celestial body (kg) - \\( R \\) = Radius of the celestial body (m) 1.2 Second Cosmic Velocity The second cosmic velocity is the escape velocity , the speed needed to escape the gravitational pull of the celestial body. This can be derived from the energy conservation between kinetic energy and gravitational potential energy: \\[ E_{\\text{total}} = E_{\\text{kinetic}} + E_{\\text{potential}} \\] Where: \\[ E_{\\text{kinetic}} = \\frac{1}{2} m v^2 \\quad \\text{and} \\quad E_{\\text{potential}} = - \\frac{G M m}{R} \\] Setting total energy to zero for escape: \\[ \\frac{1}{2} m v_2^2 = \\frac{G M m}{R} \\] Simplifying, we find the second cosmic velocity : \\[ v_2 = \\sqrt{\\frac{2GM}{R}} = \\sqrt{2} \\times v_1 \\] 1.3 Third Cosmic Velocity The third cosmic velocity is the speed required to escape the gravitational influence of the solar system , i.e., to escape the Sun\u2019s gravitational pull. This can be determined using the escape velocity from the Sun at a given distance \\( r \\) from the Sun: \\[ v_3 = \\sqrt{v_2^2 + v_{\\text{solar escape}}^2} \\] Where \\( v_{\\text{solar escape}} \\) is the escape velocity from the Sun at the object\u2019s distance: \\[ v_{\\text{solar escape}} = \\sqrt{\\frac{2 G M_{\\text{Sun}}}{r_{\\text{sun}}}} \\] Where: - \\( r_{\\text{sun}} \\) is the distance from the Sun in meters. 2. \ud83d\udcda Constants and Parameters 2.1 Gravitational and Astronomical Constants Parameter Value Description \\( G \\) \\( 6.67430 \\times 10^{-11} \\ \\text{m}^3 \\text{kg}^{-1} \\text{s}^{-2} \\) Gravitational constant \\( M_{\\text{Sun}} \\) \\( 1.989 \\times 10^{30} \\ \\text{kg} \\) Mass of the Sun 1 AU \\( 1.496 \\times 10^{11} \\ \\text{m} \\) Astronomical unit 2.2 Planetary Data Planet Mass \\( M \\) (kg) Radius \\( R \\) (m) Distance to Sun (AU) Earth \\( 5.972 \\times 10^{24} \\) \\( 6.371 \\times 10^6 \\) 1.0 Mars \\( 6.39 \\times 10^{23} \\) \\( 3.3895 \\times 10^6 \\) 1.524 Jupiter \\( 1.898 \\times 10^{27} \\) \\( 6.9911 \\times 10^7 \\) 5.204 3. \ud83e\udde0 Python Code Implementations import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # Gravitational constant (m^3 kg^-1 s^-2) sun_mass = 1.989e30 # Mass of the Sun (kg) AU = 1.496e11 # Astronomical Unit (m) # Planetary data (Mass, Radius, Distance to Sun in AU) bodies = { \"Earth\": (5.972e24, 6.371e6, 1.0), \"Mars\": (6.39e23, 3.3895e6, 1.524), \"Jupiter\": (1.898e27, 6.9911e7, 5.204) } # Function to calculate velocities (v1, v2, v3) def calculate_velocities(mass, radius, distance_to_sun_AU): v1 = np.sqrt(G * mass / radius) v2 = np.sqrt(2) * v1 distance_to_sun = distance_to_sun_AU * AU v_sun_escape = np.sqrt(2 * G * sun_mass / distance_to_sun) v3 = np.sqrt(v2**2 + v_sun_escape**2) return v1, v2, v3 # Results results = {body: calculate_velocities(mass, radius, distance) for body, (mass, radius, distance) in bodies.items()} # Output Results for body, (v1, v2, v3) in results.items(): print(f\"{body}: v1 = {v1/1000:.2f} km/s, v2 = {v2/1000:.2f} km/s, v3 = {v3/1000:.2f} km/s\") # Visualization labels = list(results.keys()) v1_vals = [results[b][0] / 1000 for b in labels] v2_vals = [results[b][1] / 1000 for b in labels] v3_vals = [results[b][2] / 1000 for b in labels] x = np.arange(len(labels)) width = 0.25 fig, ax = plt.subplots(figsize=(8,5)) ax.bar(x - width, v1_vals, width, label='First Cosmic Velocity (v1)') ax.bar(x, v2_vals, width, label='Second Cosmic Velocity (v2)') ax.bar(x + width, v3_vals, width, label='Third Cosmic Velocity (v3)') ax.set_ylabel('Velocity (km/s)') ax.set_title('Cosmic Velocities for Planets') ax.set_xticks(x) ax.set_xticklabels(labels) ax.legend() ax.grid(True) plt.tight_layout() plt.show() Planet First Cosmic Velocity (v1) [km/s] Second Cosmic Velocity (v2) [km/s] Third Cosmic Velocity (v3) [km/s] Earth 7.91 11.18 42.13 Mars 5.03 7.11 34.38 Jupiter 42.12 59.55 66.69","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#cosmic-velocities-theory-implementation-visualizations","text":"This project calculates the first , second , and third cosmic velocities for Earth , Mars , and Jupiter , including mathematical derivations , Python code , and visualizations .","title":"Cosmic Velocities: Theory, Implementation &amp; Visualizations"},{"location":"1%20Physics/2%20Gravity/Problem_2/#1-theoretical-background","text":"","title":"1. \ud83c\udf0c Theoretical Background"},{"location":"1%20Physics/2%20Gravity/Problem_2/#11-first-cosmic-velocity","text":"The first cosmic velocity is the minimum speed required to enter orbit around a celestial body. This is based on the balance between centripetal force and gravitational force . Mathematically, it is derived from the following relation: \\[ F_{\\text{centripetal}} = F_{\\text{gravitational}} \\] Where: \\[ \\frac{m v_1^2}{R} = \\frac{G M m}{R^2} \\] Simplifying for \\( v_1 \\) , we get the first cosmic velocity : \\[ v_1 = \\sqrt{\\frac{GM}{R}} \\] Where: - \\( G \\) = Gravitational constant \\( 6.67430 \\times 10^{-11} \\ \\text{m}^3 \\text{kg}^{-1} \\text{s}^{-2} \\) - \\( M \\) = Mass of the celestial body (kg) - \\( R \\) = Radius of the celestial body (m)","title":"1.1 First Cosmic Velocity"},{"location":"1%20Physics/2%20Gravity/Problem_2/#12-second-cosmic-velocity","text":"The second cosmic velocity is the escape velocity , the speed needed to escape the gravitational pull of the celestial body. This can be derived from the energy conservation between kinetic energy and gravitational potential energy: \\[ E_{\\text{total}} = E_{\\text{kinetic}} + E_{\\text{potential}} \\] Where: \\[ E_{\\text{kinetic}} = \\frac{1}{2} m v^2 \\quad \\text{and} \\quad E_{\\text{potential}} = - \\frac{G M m}{R} \\] Setting total energy to zero for escape: \\[ \\frac{1}{2} m v_2^2 = \\frac{G M m}{R} \\] Simplifying, we find the second cosmic velocity : \\[ v_2 = \\sqrt{\\frac{2GM}{R}} = \\sqrt{2} \\times v_1 \\]","title":"1.2 Second Cosmic Velocity"},{"location":"1%20Physics/2%20Gravity/Problem_2/#13-third-cosmic-velocity","text":"The third cosmic velocity is the speed required to escape the gravitational influence of the solar system , i.e., to escape the Sun\u2019s gravitational pull. This can be determined using the escape velocity from the Sun at a given distance \\( r \\) from the Sun: \\[ v_3 = \\sqrt{v_2^2 + v_{\\text{solar escape}}^2} \\] Where \\( v_{\\text{solar escape}} \\) is the escape velocity from the Sun at the object\u2019s distance: \\[ v_{\\text{solar escape}} = \\sqrt{\\frac{2 G M_{\\text{Sun}}}{r_{\\text{sun}}}} \\] Where: - \\( r_{\\text{sun}} \\) is the distance from the Sun in meters.","title":"1.3 Third Cosmic Velocity"},{"location":"1%20Physics/2%20Gravity/Problem_2/#2-constants-and-parameters","text":"","title":"2. \ud83d\udcda Constants and Parameters"},{"location":"1%20Physics/2%20Gravity/Problem_2/#21-gravitational-and-astronomical-constants","text":"Parameter Value Description \\( G \\) \\( 6.67430 \\times 10^{-11} \\ \\text{m}^3 \\text{kg}^{-1} \\text{s}^{-2} \\) Gravitational constant \\( M_{\\text{Sun}} \\) \\( 1.989 \\times 10^{30} \\ \\text{kg} \\) Mass of the Sun 1 AU \\( 1.496 \\times 10^{11} \\ \\text{m} \\) Astronomical unit","title":"2.1 Gravitational and Astronomical Constants"},{"location":"1%20Physics/2%20Gravity/Problem_2/#22-planetary-data","text":"Planet Mass \\( M \\) (kg) Radius \\( R \\) (m) Distance to Sun (AU) Earth \\( 5.972 \\times 10^{24} \\) \\( 6.371 \\times 10^6 \\) 1.0 Mars \\( 6.39 \\times 10^{23} \\) \\( 3.3895 \\times 10^6 \\) 1.524 Jupiter \\( 1.898 \\times 10^{27} \\) \\( 6.9911 \\times 10^7 \\) 5.204","title":"2.2 Planetary Data"},{"location":"1%20Physics/2%20Gravity/Problem_2/#3-python-code-implementations","text":"import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # Gravitational constant (m^3 kg^-1 s^-2) sun_mass = 1.989e30 # Mass of the Sun (kg) AU = 1.496e11 # Astronomical Unit (m) # Planetary data (Mass, Radius, Distance to Sun in AU) bodies = { \"Earth\": (5.972e24, 6.371e6, 1.0), \"Mars\": (6.39e23, 3.3895e6, 1.524), \"Jupiter\": (1.898e27, 6.9911e7, 5.204) } # Function to calculate velocities (v1, v2, v3) def calculate_velocities(mass, radius, distance_to_sun_AU): v1 = np.sqrt(G * mass / radius) v2 = np.sqrt(2) * v1 distance_to_sun = distance_to_sun_AU * AU v_sun_escape = np.sqrt(2 * G * sun_mass / distance_to_sun) v3 = np.sqrt(v2**2 + v_sun_escape**2) return v1, v2, v3 # Results results = {body: calculate_velocities(mass, radius, distance) for body, (mass, radius, distance) in bodies.items()} # Output Results for body, (v1, v2, v3) in results.items(): print(f\"{body}: v1 = {v1/1000:.2f} km/s, v2 = {v2/1000:.2f} km/s, v3 = {v3/1000:.2f} km/s\") # Visualization labels = list(results.keys()) v1_vals = [results[b][0] / 1000 for b in labels] v2_vals = [results[b][1] / 1000 for b in labels] v3_vals = [results[b][2] / 1000 for b in labels] x = np.arange(len(labels)) width = 0.25 fig, ax = plt.subplots(figsize=(8,5)) ax.bar(x - width, v1_vals, width, label='First Cosmic Velocity (v1)') ax.bar(x, v2_vals, width, label='Second Cosmic Velocity (v2)') ax.bar(x + width, v3_vals, width, label='Third Cosmic Velocity (v3)') ax.set_ylabel('Velocity (km/s)') ax.set_title('Cosmic Velocities for Planets') ax.set_xticks(x) ax.set_xticklabels(labels) ax.legend() ax.grid(True) plt.tight_layout() plt.show() Planet First Cosmic Velocity (v1) [km/s] Second Cosmic Velocity (v2) [km/s] Third Cosmic Velocity (v3) [km/s] Earth 7.91 11.18 42.13 Mars 5.03 7.11 34.38 Jupiter 42.12 59.55 66.69","title":"3. \ud83e\udde0 Python Code Implementations"},{"location":"1%20Physics/2%20Gravity/Problem_3/","text":"# Problem 3 # Trajectories of a Freely Released Payload Near Earth Motivation When a payload is released from a spacecraft near Earth, its trajectory depends on the initial velocity, position, and the gravitational forces acting on it. These trajectories are crucial for understanding how objects behave in space and for planning satellite deployments, reentry missions, and escape scenarios. Physics Concepts Newton's Law of Gravitation The gravitational force acting on a payload is given by the following equation: \\[ \\vec{F} = -G \\frac{M m}{r^2} \\hat{r} \\] Where: - \\( G = 6.674 \\times 10^{-11} \\, \\text{Nm}^2/\\text{kg}^2 \\) \u2014 Gravitational constant - \\( M \\) \u2014 Earth's mass - \\( m \\) \u2014 Payload's mass - \\( r \\) \u2014 Distance from Earth's center - \\( \\hat{r} \\) \u2014 Unit vector pointing from Earth to the payload Escape Velocity The escape velocity is the minimum velocity needed to break free from Earth's gravitational field: \\[ v_{\\text{esc}} = \\sqrt{\\frac{2GM}{r}} \\] At Earth's surface, the escape velocity is approximately 11.2 km/s . Numerical Simulation in Python Imports and Constants We begin by importing necessary libraries and defining key constants. import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # Gravitational constant [m^3 kg^-1 s^-2] M = 5.972e24 # Mass of Earth [kg] R_earth = 6.371e6 # Radius of Earth [m] # Initial Conditions In this section, we define the initial conditions for the payload, which includes its altitude, initial position, and initial velocity. # Initial conditions altitude = 300e3 # Altitude from Earth's surface (300 km) r0 = np.array([R_earth + altitude, 0]) # Initial position vector (x, y) v0 = np.array([0, 7700]) # Initial velocity vector (vx, vy) in m/s Time Settings In this section, we define the time settings for the simulation, including the time step ( dt ) and the total simulation time ( T ). # Time settings dt = 1 # Time step (seconds) T = 10000 # Total simulation time (seconds) steps = int(T / dt) # Number of time steps Simulation Function Now, let\u2019s implement the Euler method to numerically integrate the equations of motion and simulate the trajectory of the payload. # Simulation function def simulate(r0, v0, dt, steps): r = np.zeros((steps, 2)) # Position array v = np.zeros((steps, 2)) # Velocity array r[0] = r0 # Set initial position v[0] = v0 # Set initial velocity for i in range(steps - 1): distance = np.linalg.norm(r[i]) # Calculate distance from Earth\u2019s center # Check if the payload has hit the Earth's surface if distance < R_earth: print(f\"Impact with Earth at step {i}, time {i * dt} s\") return r[:i+1] # Calculate the acceleration due to gravity a = -G * M * r[i] / distance**3 v[i + 1] = v[i] + a * dt # Update velocity r[i + 1] = r[i] + v[i + 1] * dt # Update position return r # Return the trajectory Visualization Now, we will run the simulation and plot the resulting trajectory of the payload. # Run the simulation trajectory = simulate(r0, v0, dt, steps) # Plotting the trajectory plt.figure(figsize=(8, 8)) plt.plot(trajectory[:, 0], trajectory[:, 1], label=\"Payload Trajectory\") # Draw Earth earth = plt.Circle((0, 0), R_earth, color='blue', alpha=0.5, label=\"Earth\") plt.gca().add_artist(earth) # Plot formatting plt.xlabel(\"x [m]\") plt.ylabel(\"y [m]\") plt.title(\"Trajectory of a Freely Released Payload\") plt.axis(\"equal\") plt.grid(True) plt.legend() plt.show() Trajectory Types Based on Initial Speed Initial Speed (m/s) Outcome < 7000 Falls back to Earth \u2248 7670 Circular orbit 7000\u201311000 Elliptical orbit \u2248 11200 Parabolic escape > 11200 Hyperbolic escape Conclusion In this project, we modeled the gravitational motion of a payload near Earth and simulated its trajectory using the Euler method . The key takeaways include: Simulation : We calculated the trajectory of a freely released payload, starting at a specific altitude with a given initial velocity. We used the Euler method for numerical integration of the motion under Earth's gravity. Trajectory Types : Based on the initial velocity, we observed different types of trajectories: If the velocity is too low, the payload falls back to Earth. If the velocity is high enough, the payload enters a stable orbit or escapes Earth's gravity. The payload's path could be parabolic, elliptical, or hyperbolic depending on its initial conditions. Visualization : Using matplotlib , we visualized the trajectory of the payload, showing its path relative to Earth\u2019s surface. The simulation results provide a clear understanding of how initial conditions like altitude and velocity affect the trajectory. Real-World Applications : This model can be applied to space missions, satellite deployments, or reentry predictions. Understanding the physics behind these trajectories is vital for designing successful space missions and ensuring the safety of payloads.","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#motivation","text":"When a payload is released from a spacecraft near Earth, its trajectory depends on the initial velocity, position, and the gravitational forces acting on it. These trajectories are crucial for understanding how objects behave in space and for planning satellite deployments, reentry missions, and escape scenarios.","title":"Motivation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#physics-concepts","text":"","title":"Physics Concepts"},{"location":"1%20Physics/2%20Gravity/Problem_3/#newtons-law-of-gravitation","text":"The gravitational force acting on a payload is given by the following equation: \\[ \\vec{F} = -G \\frac{M m}{r^2} \\hat{r} \\] Where: - \\( G = 6.674 \\times 10^{-11} \\, \\text{Nm}^2/\\text{kg}^2 \\) \u2014 Gravitational constant - \\( M \\) \u2014 Earth's mass - \\( m \\) \u2014 Payload's mass - \\( r \\) \u2014 Distance from Earth's center - \\( \\hat{r} \\) \u2014 Unit vector pointing from Earth to the payload","title":"Newton's Law of Gravitation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#escape-velocity","text":"The escape velocity is the minimum velocity needed to break free from Earth's gravitational field: \\[ v_{\\text{esc}} = \\sqrt{\\frac{2GM}{r}} \\] At Earth's surface, the escape velocity is approximately 11.2 km/s .","title":"Escape Velocity"},{"location":"1%20Physics/2%20Gravity/Problem_3/#numerical-simulation-in-python","text":"","title":"Numerical Simulation in Python"},{"location":"1%20Physics/2%20Gravity/Problem_3/#imports-and-constants","text":"We begin by importing necessary libraries and defining key constants. import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # Gravitational constant [m^3 kg^-1 s^-2] M = 5.972e24 # Mass of Earth [kg] R_earth = 6.371e6 # Radius of Earth [m] # Initial Conditions In this section, we define the initial conditions for the payload, which includes its altitude, initial position, and initial velocity. # Initial conditions altitude = 300e3 # Altitude from Earth's surface (300 km) r0 = np.array([R_earth + altitude, 0]) # Initial position vector (x, y) v0 = np.array([0, 7700]) # Initial velocity vector (vx, vy) in m/s","title":"Imports and Constants"},{"location":"1%20Physics/2%20Gravity/Problem_3/#time-settings","text":"In this section, we define the time settings for the simulation, including the time step ( dt ) and the total simulation time ( T ). # Time settings dt = 1 # Time step (seconds) T = 10000 # Total simulation time (seconds) steps = int(T / dt) # Number of time steps","title":"Time Settings"},{"location":"1%20Physics/2%20Gravity/Problem_3/#simulation-function","text":"Now, let\u2019s implement the Euler method to numerically integrate the equations of motion and simulate the trajectory of the payload. # Simulation function def simulate(r0, v0, dt, steps): r = np.zeros((steps, 2)) # Position array v = np.zeros((steps, 2)) # Velocity array r[0] = r0 # Set initial position v[0] = v0 # Set initial velocity for i in range(steps - 1): distance = np.linalg.norm(r[i]) # Calculate distance from Earth\u2019s center # Check if the payload has hit the Earth's surface if distance < R_earth: print(f\"Impact with Earth at step {i}, time {i * dt} s\") return r[:i+1] # Calculate the acceleration due to gravity a = -G * M * r[i] / distance**3 v[i + 1] = v[i] + a * dt # Update velocity r[i + 1] = r[i] + v[i + 1] * dt # Update position return r # Return the trajectory","title":"Simulation Function"},{"location":"1%20Physics/2%20Gravity/Problem_3/#visualization","text":"Now, we will run the simulation and plot the resulting trajectory of the payload. # Run the simulation trajectory = simulate(r0, v0, dt, steps) # Plotting the trajectory plt.figure(figsize=(8, 8)) plt.plot(trajectory[:, 0], trajectory[:, 1], label=\"Payload Trajectory\") # Draw Earth earth = plt.Circle((0, 0), R_earth, color='blue', alpha=0.5, label=\"Earth\") plt.gca().add_artist(earth) # Plot formatting plt.xlabel(\"x [m]\") plt.ylabel(\"y [m]\") plt.title(\"Trajectory of a Freely Released Payload\") plt.axis(\"equal\") plt.grid(True) plt.legend() plt.show()","title":"Visualization"},{"location":"1%20Physics/2%20Gravity/Problem_3/#trajectory-types-based-on-initial-speed","text":"Initial Speed (m/s) Outcome < 7000 Falls back to Earth \u2248 7670 Circular orbit 7000\u201311000 Elliptical orbit \u2248 11200 Parabolic escape > 11200 Hyperbolic escape","title":"Trajectory Types Based on Initial Speed"},{"location":"1%20Physics/2%20Gravity/Problem_3/#conclusion","text":"In this project, we modeled the gravitational motion of a payload near Earth and simulated its trajectory using the Euler method . The key takeaways include: Simulation : We calculated the trajectory of a freely released payload, starting at a specific altitude with a given initial velocity. We used the Euler method for numerical integration of the motion under Earth's gravity. Trajectory Types : Based on the initial velocity, we observed different types of trajectories: If the velocity is too low, the payload falls back to Earth. If the velocity is high enough, the payload enters a stable orbit or escapes Earth's gravity. The payload's path could be parabolic, elliptical, or hyperbolic depending on its initial conditions. Visualization : Using matplotlib , we visualized the trajectory of the payload, showing its path relative to Earth\u2019s surface. The simulation results provide a clear understanding of how initial conditions like altitude and velocity affect the trajectory. Real-World Applications : This model can be applied to space missions, satellite deployments, or reentry predictions. Understanding the physics behind these trajectories is vital for designing successful space missions and ensuring the safety of payloads.","title":"Conclusion"},{"location":"1%20Physics/3%20Waves/Problem_1/","text":"Problem 1 Interference of Circular Waves from Square-Arranged Point Sources A Theoretical and Computational Study in 2D Water Wave Superposition 1. Introduction Wave interference lies at the heart of wave physics. It refers to the phenomenon where two or more wavefronts overlap and combine to form a new wave pattern. On a water surface, circular waves from multiple point sources can interact in visually striking ways\u2014forming alternating patterns of constructive and destructive interference . This document investigates the superposition of water waves emitted from four identical, coherent sources arranged in a square configuration . Using the wave equation in cylindrical coordinates and Python-based simulation, we model, visualize, and analyze the resulting interference pattern . 2. Theoretical Background 2.1 Wave from a Single Point Source The displacement \\( \\eta \\) of a water surface at time \\( t \\) and position \\( (x, y) \\) , due to a wave originating from a point source at \\( (x_0, y_0) \\) , is given by: \\[ \\eta(x, y, t) = \\frac{A}{r} \\cos(kr - \\omega t + \\phi) \\] Where: \\( A \\) : amplitude of the wave, \\( r = \\sqrt{(x - x_0)^2 + (y - y_0)^2} \\) : radial distance to source, \\( k = \\frac{2\\pi}{\\lambda} \\) : wave number (with \\( \\lambda \\) wavelength), \\( \\omega = 2\\pi f \\) : angular frequency (with \\( f \\) frequency), \\( \\phi \\) : phase constant, \\( t \\) : time. Note: The \\( \\frac{A}{r} \\) term models radial energy dispersion on a 2D surface. This simulates the realistic drop in amplitude with distance. 2.2 Superposition of Multiple Sources If there are \\( N \\) identical sources located at positions \\( (x_i, y_i) \\) , the total displacement is: \\[ \\eta_{\\text{total}}(x, y, t) = \\sum_{i=1}^{N} \\frac{A}{r_i} \\cos(kr_i - \\omega t + \\phi) \\] Where each \\( r_i = \\sqrt{(x - x_i)^2 + (y - y_i)^2} \\) is the distance from point \\( (x, y) \\) to source \\( i \\) . The interference pattern is determined by the phase differences between these cosine terms: Constructive interference : \\( kr_i - kr_j = 2\\pi n \\) Destructive interference : \\( kr_i - kr_j = (2n+1)\\pi \\) for integer \\( n \\) . 2.3 Phase Matching & Interference Zones For two waves: \\[ \\eta_1 = \\frac{A}{r_1} \\cos(kr_1 - \\omega t), \\quad \\eta_2 = \\frac{A}{r_2} \\cos(kr_2 - \\omega t) \\] The total displacement: \\[ \\eta = \\eta_1 + \\eta_2 = \\frac{A}{r_1} \\cos(kr_1 - \\omega t) + \\frac{A}{r_2} \\cos(kr_2 - \\omega t) \\] Using the trigonometric identity: \\[ \\cos \\alpha + \\cos \\beta = 2 \\cos\\left(\\frac{\\alpha + \\beta}{2}\\right) \\cos\\left(\\frac{\\alpha - \\beta}{2}\\right) \\] We obtain an interference envelope : \\[ \\eta = 2A_{\\text{eff}} \\cos\\left(\\frac{k(r_1 - r_2)}{2} \\right) \\cdot \\cos\\left( \\frac{k(r_1 + r_2)}{2} - \\omega t \\right) \\] Which reveals oscillating interference fringes governed by the path difference \\( r_1 - r_2 \\) . 3. Geometry of the Setup We use a square of side length \\( L = 2 \\) , centered at the origin. The sources are located at: \\( S_1 = (-1, -1) \\) \\( S_2 = (-1, +1) \\) \\( S_3 = (+1, -1) \\) \\( S_4 = (+1, +1) \\) These sources are: Coherent (same frequency), In-phase (same \\( \\phi = 0 \\) ), Identical in amplitude and wavelength. 4. Python Simulation Code import numpy as np import matplotlib.pyplot as plt # --- Parameters --- A = 1.0 wavelength = 1.0 frequency = 1.0 phi = 0 k = 2 * np.pi / wavelength omega = 2 * np.pi * frequency t = 0 # --- Grid --- x = np.linspace(-5, 5, 500) y = np.linspace(-5, 5, 500) X, Y = np.meshgrid(x, y) # --- Source Positions (Square) --- L = 2.0 sources = [(-1, -1), (-1, 1), (1, -1), (1, 1)] # --- Superposition of Waves --- eta_total = np.zeros_like(X) for (x0, y0) in sources: R = np.sqrt((X - x0)**2 + (Y - y0)**2) + 1e-6 # Avoid singularity at R=0 eta = (A / R) * np.cos(k * R - omega * t + phi) eta_total += eta # --- Plot --- plt.figure(figsize=(10, 8)) plt.pcolormesh(X, Y, eta_total, shading='auto', cmap='seismic') plt.colorbar(label='Surface Displacement \u03b7') plt.title(\"Interference of 4 Point Sources (Square)\") plt.xlabel(\"x position\") plt.ylabel(\"y position\") plt.axis('equal') plt.tight_layout() plt.show() 5. Analysis of Results Constructive Interference Occurs when the path difference from any two sources is an integer multiple of \\( \\lambda \\) : \\[ \\Delta r = n \\lambda \\] Produces bright fringes in the plot. Destructive Interference Occurs when: \\[ \\Delta r = (n + \\frac{1}{2}) \\lambda \\] These appear as dark regions . Symmetry The interference pattern exhibits 4-fold rotational symmetry due to the square geometry. Patterns are stationary since all sources oscillate in phase. 6. Experimental Extensions Time Evolution To animate the pattern over time, iterate over t : for t in np.linspace(0, 2*np.pi, 100): ... Other Polygons Equilateral triangle : Use 3 points at \\( 120^\\circ \\) intervals. Pentagon : Use polar coordinates: N = 5 R = 2 sources = [(R * np.cos(2*np.pi*i/N), R * np.sin(2*np.pi*i/N)) for i in range(N)] Arbitrary Phases Vary \\( \\phi \\) per source to simulate phase delays or non-coherent waves . 7. Generalization The method above can be generalized to any N sources located at arbitrary positions \\( (x_i, y_i) \\) , possibly with varying phase offsets \\( \\phi_i \\) : \\[ \\eta(x, y, t) = \\sum_{i=1}^{N} \\frac{A}{r_i} \\cos(kr_i - \\omega t + \\phi_i) \\] This enables modeling of more complex systems, including: Laser interference, Sound field simulations, Quantum wavefunction interference. 8. Suggested Folder Structure wave_simulation_square/ \u251c\u2500\u2500 interference_square.md \u251c\u2500\u2500 simulation_square.py \u251c\u2500\u2500 images/ \u2502 \u2514\u2500\u2500 pattern_snapshot.png \u251c\u2500\u2500 animation/ \u2502 \u2514\u2500\u2500 gif_frames/ \u2514\u2500\u2500 README.md 9. Conclusion In this study, we investigated the interference of circular water waves emitted from four coherent sources positioned at the vertices of a square. By employing the principle of superposition , we derived and simulated the resulting surface displacement: \\[ \\eta_{\\text{total}}(x, y, t) = \\sum_{i=1}^{N} \\frac{A}{r_i} \\cos(k r_i - \\omega t + \\phi_i) \\] where each \\( r_i \\) is the distance from the \\(i^{th}\\) source to the point \\( (x, y) \\) , and all sources share common amplitude \\( A \\) , wave number \\( k \\) , frequency \\( \\omega \\) , and coherent phase differences. Key Findings: The interference pattern exhibits high symmetry , due to the square configuration. Constructive interference appears when the path differences between sources align to integer multiples of the wavelength \\( \\lambda \\) . Destructive interference results from phase differences of odd multiples of \\( \\pi \\) , forming nodal lines (regions of cancellation). The amplitude decays with distance \\( \\left(\\propto \\frac{1}{r}\\right) \\) , modeling physical energy dissipation in water. The overall displacement field is spatially complex but temporally periodic , governed by the cosine term involving time \\( t \\) . Physical Implications: This simulation reinforces key wave physics concepts such as: The superposition principle in linear systems, The effects of phase coherence and source arrangement, The formation of nodal and antinodal lines , Realistic amplitude decay over space. Potential Extensions: Varying the number of sources or changing the polygon (triangle, pentagon, etc.) Introducing initial phase differences between emitters Adding obstacles or barriers to study reflection and diffraction Extending the model to simulate optical , acoustic , or quantum interference phenomena Ultimately, this project demonstrates the effectiveness of combining analytical wave modeling with computational visualization to explore fundamental physical behaviors in wave systems.","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#interference-of-circular-waves-from-square-arranged-point-sources","text":"","title":"Interference of Circular Waves from Square-Arranged Point Sources"},{"location":"1%20Physics/3%20Waves/Problem_1/#a-theoretical-and-computational-study-in-2d-water-wave-superposition","text":"","title":"A Theoretical and Computational Study in 2D Water Wave Superposition"},{"location":"1%20Physics/3%20Waves/Problem_1/#1-introduction","text":"Wave interference lies at the heart of wave physics. It refers to the phenomenon where two or more wavefronts overlap and combine to form a new wave pattern. On a water surface, circular waves from multiple point sources can interact in visually striking ways\u2014forming alternating patterns of constructive and destructive interference . This document investigates the superposition of water waves emitted from four identical, coherent sources arranged in a square configuration . Using the wave equation in cylindrical coordinates and Python-based simulation, we model, visualize, and analyze the resulting interference pattern .","title":"1. Introduction"},{"location":"1%20Physics/3%20Waves/Problem_1/#2-theoretical-background","text":"","title":"2. Theoretical Background"},{"location":"1%20Physics/3%20Waves/Problem_1/#21-wave-from-a-single-point-source","text":"The displacement \\( \\eta \\) of a water surface at time \\( t \\) and position \\( (x, y) \\) , due to a wave originating from a point source at \\( (x_0, y_0) \\) , is given by: \\[ \\eta(x, y, t) = \\frac{A}{r} \\cos(kr - \\omega t + \\phi) \\] Where: \\( A \\) : amplitude of the wave, \\( r = \\sqrt{(x - x_0)^2 + (y - y_0)^2} \\) : radial distance to source, \\( k = \\frac{2\\pi}{\\lambda} \\) : wave number (with \\( \\lambda \\) wavelength), \\( \\omega = 2\\pi f \\) : angular frequency (with \\( f \\) frequency), \\( \\phi \\) : phase constant, \\( t \\) : time. Note: The \\( \\frac{A}{r} \\) term models radial energy dispersion on a 2D surface. This simulates the realistic drop in amplitude with distance.","title":"2.1 Wave from a Single Point Source"},{"location":"1%20Physics/3%20Waves/Problem_1/#22-superposition-of-multiple-sources","text":"If there are \\( N \\) identical sources located at positions \\( (x_i, y_i) \\) , the total displacement is: \\[ \\eta_{\\text{total}}(x, y, t) = \\sum_{i=1}^{N} \\frac{A}{r_i} \\cos(kr_i - \\omega t + \\phi) \\] Where each \\( r_i = \\sqrt{(x - x_i)^2 + (y - y_i)^2} \\) is the distance from point \\( (x, y) \\) to source \\( i \\) . The interference pattern is determined by the phase differences between these cosine terms: Constructive interference : \\( kr_i - kr_j = 2\\pi n \\) Destructive interference : \\( kr_i - kr_j = (2n+1)\\pi \\) for integer \\( n \\) .","title":"2.2 Superposition of Multiple Sources"},{"location":"1%20Physics/3%20Waves/Problem_1/#23-phase-matching-interference-zones","text":"For two waves: \\[ \\eta_1 = \\frac{A}{r_1} \\cos(kr_1 - \\omega t), \\quad \\eta_2 = \\frac{A}{r_2} \\cos(kr_2 - \\omega t) \\] The total displacement: \\[ \\eta = \\eta_1 + \\eta_2 = \\frac{A}{r_1} \\cos(kr_1 - \\omega t) + \\frac{A}{r_2} \\cos(kr_2 - \\omega t) \\] Using the trigonometric identity: \\[ \\cos \\alpha + \\cos \\beta = 2 \\cos\\left(\\frac{\\alpha + \\beta}{2}\\right) \\cos\\left(\\frac{\\alpha - \\beta}{2}\\right) \\] We obtain an interference envelope : \\[ \\eta = 2A_{\\text{eff}} \\cos\\left(\\frac{k(r_1 - r_2)}{2} \\right) \\cdot \\cos\\left( \\frac{k(r_1 + r_2)}{2} - \\omega t \\right) \\] Which reveals oscillating interference fringes governed by the path difference \\( r_1 - r_2 \\) .","title":"2.3 Phase Matching &amp; Interference Zones"},{"location":"1%20Physics/3%20Waves/Problem_1/#3-geometry-of-the-setup","text":"We use a square of side length \\( L = 2 \\) , centered at the origin. The sources are located at: \\( S_1 = (-1, -1) \\) \\( S_2 = (-1, +1) \\) \\( S_3 = (+1, -1) \\) \\( S_4 = (+1, +1) \\) These sources are: Coherent (same frequency), In-phase (same \\( \\phi = 0 \\) ), Identical in amplitude and wavelength.","title":"3. Geometry of the Setup"},{"location":"1%20Physics/3%20Waves/Problem_1/#4-python-simulation-code","text":"import numpy as np import matplotlib.pyplot as plt # --- Parameters --- A = 1.0 wavelength = 1.0 frequency = 1.0 phi = 0 k = 2 * np.pi / wavelength omega = 2 * np.pi * frequency t = 0 # --- Grid --- x = np.linspace(-5, 5, 500) y = np.linspace(-5, 5, 500) X, Y = np.meshgrid(x, y) # --- Source Positions (Square) --- L = 2.0 sources = [(-1, -1), (-1, 1), (1, -1), (1, 1)] # --- Superposition of Waves --- eta_total = np.zeros_like(X) for (x0, y0) in sources: R = np.sqrt((X - x0)**2 + (Y - y0)**2) + 1e-6 # Avoid singularity at R=0 eta = (A / R) * np.cos(k * R - omega * t + phi) eta_total += eta # --- Plot --- plt.figure(figsize=(10, 8)) plt.pcolormesh(X, Y, eta_total, shading='auto', cmap='seismic') plt.colorbar(label='Surface Displacement \u03b7') plt.title(\"Interference of 4 Point Sources (Square)\") plt.xlabel(\"x position\") plt.ylabel(\"y position\") plt.axis('equal') plt.tight_layout() plt.show()","title":"4. Python Simulation Code"},{"location":"1%20Physics/3%20Waves/Problem_1/#5-analysis-of-results","text":"","title":"5. Analysis of Results"},{"location":"1%20Physics/3%20Waves/Problem_1/#constructive-interference","text":"Occurs when the path difference from any two sources is an integer multiple of \\( \\lambda \\) : \\[ \\Delta r = n \\lambda \\] Produces bright fringes in the plot.","title":"Constructive Interference"},{"location":"1%20Physics/3%20Waves/Problem_1/#destructive-interference","text":"Occurs when: \\[ \\Delta r = (n + \\frac{1}{2}) \\lambda \\] These appear as dark regions .","title":"Destructive Interference"},{"location":"1%20Physics/3%20Waves/Problem_1/#symmetry","text":"The interference pattern exhibits 4-fold rotational symmetry due to the square geometry. Patterns are stationary since all sources oscillate in phase.","title":"Symmetry"},{"location":"1%20Physics/3%20Waves/Problem_1/#6-experimental-extensions","text":"","title":"6. Experimental Extensions"},{"location":"1%20Physics/3%20Waves/Problem_1/#time-evolution","text":"To animate the pattern over time, iterate over t : for t in np.linspace(0, 2*np.pi, 100): ...","title":"Time Evolution"},{"location":"1%20Physics/3%20Waves/Problem_1/#other-polygons","text":"Equilateral triangle : Use 3 points at \\( 120^\\circ \\) intervals. Pentagon : Use polar coordinates: N = 5 R = 2 sources = [(R * np.cos(2*np.pi*i/N), R * np.sin(2*np.pi*i/N)) for i in range(N)]","title":"Other Polygons"},{"location":"1%20Physics/3%20Waves/Problem_1/#arbitrary-phases","text":"Vary \\( \\phi \\) per source to simulate phase delays or non-coherent waves .","title":"Arbitrary Phases"},{"location":"1%20Physics/3%20Waves/Problem_1/#7-generalization","text":"The method above can be generalized to any N sources located at arbitrary positions \\( (x_i, y_i) \\) , possibly with varying phase offsets \\( \\phi_i \\) : \\[ \\eta(x, y, t) = \\sum_{i=1}^{N} \\frac{A}{r_i} \\cos(kr_i - \\omega t + \\phi_i) \\] This enables modeling of more complex systems, including: Laser interference, Sound field simulations, Quantum wavefunction interference.","title":"7. Generalization"},{"location":"1%20Physics/3%20Waves/Problem_1/#8-suggested-folder-structure","text":"wave_simulation_square/ \u251c\u2500\u2500 interference_square.md \u251c\u2500\u2500 simulation_square.py \u251c\u2500\u2500 images/ \u2502 \u2514\u2500\u2500 pattern_snapshot.png \u251c\u2500\u2500 animation/ \u2502 \u2514\u2500\u2500 gif_frames/ \u2514\u2500\u2500 README.md","title":"8. Suggested Folder Structure"},{"location":"1%20Physics/3%20Waves/Problem_1/#9-conclusion","text":"In this study, we investigated the interference of circular water waves emitted from four coherent sources positioned at the vertices of a square. By employing the principle of superposition , we derived and simulated the resulting surface displacement: \\[ \\eta_{\\text{total}}(x, y, t) = \\sum_{i=1}^{N} \\frac{A}{r_i} \\cos(k r_i - \\omega t + \\phi_i) \\] where each \\( r_i \\) is the distance from the \\(i^{th}\\) source to the point \\( (x, y) \\) , and all sources share common amplitude \\( A \\) , wave number \\( k \\) , frequency \\( \\omega \\) , and coherent phase differences.","title":"9. Conclusion"},{"location":"1%20Physics/3%20Waves/Problem_1/#key-findings","text":"The interference pattern exhibits high symmetry , due to the square configuration. Constructive interference appears when the path differences between sources align to integer multiples of the wavelength \\( \\lambda \\) . Destructive interference results from phase differences of odd multiples of \\( \\pi \\) , forming nodal lines (regions of cancellation). The amplitude decays with distance \\( \\left(\\propto \\frac{1}{r}\\right) \\) , modeling physical energy dissipation in water. The overall displacement field is spatially complex but temporally periodic , governed by the cosine term involving time \\( t \\) .","title":"Key Findings:"},{"location":"1%20Physics/3%20Waves/Problem_1/#physical-implications","text":"This simulation reinforces key wave physics concepts such as: The superposition principle in linear systems, The effects of phase coherence and source arrangement, The formation of nodal and antinodal lines , Realistic amplitude decay over space.","title":"Physical Implications:"},{"location":"1%20Physics/3%20Waves/Problem_1/#potential-extensions","text":"Varying the number of sources or changing the polygon (triangle, pentagon, etc.) Introducing initial phase differences between emitters Adding obstacles or barriers to study reflection and diffraction Extending the model to simulate optical , acoustic , or quantum interference phenomena Ultimately, this project demonstrates the effectiveness of combining analytical wave modeling with computational visualization to explore fundamental physical behaviors in wave systems.","title":"Potential Extensions:"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/","text":"Problem 1 Lorentz Force Simulation: Dynamics of Charged Particles in Electromagnetic Fields Introduction This project simulates the motion of a charged particle under the combined influence of electric ( \\( \\vec{E} \\) ) and magnetic ( \\( \\vec{B} \\) ) fields, using the classical Lorentz force law : \\[ \\vec{F} = q\\vec{E} + q(\\vec{v} \\times \\vec{B}) \\] Where: - \\( \\vec{F} \\) : total force acting on the particle (Newtons) - \\( q \\) : electric charge of the particle (Coulombs) - \\( \\vec{E} \\) : electric field vector (V/m) - \\( \\vec{v} \\) : instantaneous velocity of the particle (m/s) - \\( \\vec{B} \\) : magnetic field vector (Tesla) This force governs many fundamental processes in plasma physics, space science, and accelerator technology. Project Goals Simulate the 3D motion of charged particles under various field configurations Numerically integrate Newton\u2019s second law using the Euler method Analyze motion types: circular, helical, linear, and drift trajectories Derive physical quantities like the Larmor radius and drift velocity Visualize results with interactive and static 3D plots Physical Concepts 1. Pure Magnetic Field ( \\( \\vec{E} = 0 \\) ) The force is always perpendicular to the velocity The particle performs uniform circular or helical motion No energy is gained or lost (speed remains constant) 2. Pure Electric Field ( \\( \\vec{B} = 0 \\) ) The particle undergoes uniform linear acceleration Kinetic energy increases with time Trajectory is a parabola in time 3. Crossed Fields ( \\( \\vec{E} \\perp \\vec{B} \\) ) Particle drifts at velocity: $$ \\vec{v}_d = \\frac{\\vec{E} \\times \\vec{B}}{B^2} $$ Superposition of drift and circular motion: cycloidal trajectory 4. Larmor Radius The radius of circular motion in a uniform magnetic field is given by: \\[ r_L = \\frac{m v_\\perp}{|q| B} \\] Where \\( v_\\perp \\) is the component of velocity perpendicular to \\( \\vec{B} \\) . Python Simulation Code The following code uses NumPy and Matplotlib to simulate and plot the trajectory using the Euler method for numerical integration: import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D # ------------------------------- # 1. Define Physical Parameters # ------------------------------- q = 1.6e-19 # Particle charge (C) m = 9.11e-31 # Particle mass (kg) E = np.array([0.0, 0.0, 0.0]) # Electric field (V/m) B = np.array([0.0, 0.0, 1.0]) # Magnetic field (T) v0 = np.array([1e6, 0.0, 1e6]) # Initial velocity (m/s) x0 = np.array([0.0, 0.0, 0.0]) # Initial position (m) # ------------------------------- # 2. Time Discretization # ------------------------------- dt = 1e-11 # Time step (s) t_max = 1e-7 # Total time (s) steps = int(t_max / dt) # ------------------------------- # 3. Initialize Arrays # ------------------------------- x = np.zeros((steps, 3)) v = np.zeros((steps, 3)) x[0] = x0 v[0] = v0 # ------------------------------- # 4. Euler Method Loop # ------------------------------- for i in range(steps - 1): F = q * (E + np.cross(v[i], B)) a = F / m v[i + 1] = v[i] + a * dt x[i + 1] = x[i] + v[i] * dt # ------------------------------- # 5. 3D Trajectory Plot # ------------------------------- fig = plt.figure(figsize=(10, 6)) ax = fig.add_subplot(111, projection='3d') ax.plot(x[:, 0], x[:, 1], x[:, 2], label=\"Particle Trajectory\", color='navy') ax.set_xlabel('x (m)') ax.set_ylabel('y (m)') ax.set_zlabel('z (m)') ax.set_title('Charged Particle Trajectory in Electromagnetic Field') ax.legend() plt.tight_layout() plt.show() Observations Helical Motion : When \\( \\vec{v} \\) has both perpendicular and parallel components relative to \\( \\vec{B} \\) , a helical path forms. Drift Motion : In \\( \\vec{E} \\times \\vec{B} \\) configuration, a constant lateral drift occurs. Acceleration : In the presence of an electric field, energy increases over time. Confinement : Stronger \\( B \\) fields reduce the radius, improving magnetic confinement. Real-World Applications System Role of Lorentz Force Cyclotron Circular acceleration of particles via magnetic fields Mass Spectrometry Charge-to-mass separation using \\( \\vec{v} \\times \\vec{B} \\) Fusion Reactors Plasma confinement with strong \\( \\vec{B} \\) and \\( \\vec{E} \\) fields Auroras Charged solar particles guided by Earth's magnetic field Van Allen Belts Trapped particle dynamics governed by Earth's magnetosphere Parameter Exploration Ideas To study different scenarios, try changing: q , m \u2192 particle identity (electron, proton, ion, etc.) E , B \u2192 field directions and magnitudes v0 \u2192 perpendicular vs. parallel velocity components dt , t_max \u2192 resolution and simulation span For instance: - Set \\( \\vec{E} = [1e4, 0, 0] \\) , \\( \\vec{B} = [0, 0, 1] \\) for E \u00d7 B drift - Try \\( v_0 = [0, 1e6, 0] \\) to isolate circular motion - Simulate multiple particles or particles of opposite charge Conclusion This simulation provides a clear and flexible numerical tool to understand the behavior of charged particles under electromagnetic forces. It highlights: Rotational motion in magnetic fields Linear acceleration in electric fields Guided drift motion in combined fields The approach can be extended to: - Use more accurate integration (e.g., Runge-Kutta) - Introduce spatially or temporally varying fields - Model multi-particle plasma dynamics - Include relativistic corrections for high-speed particles Understanding Lorentz force dynamics is crucial in disciplines like astrophysics , plasma engineering , space weather modeling , and particle accelerator design .","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#lorentz-force-simulation-dynamics-of-charged-particles-in-electromagnetic-fields","text":"","title":"Lorentz Force Simulation: Dynamics of Charged Particles in Electromagnetic Fields"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#introduction","text":"This project simulates the motion of a charged particle under the combined influence of electric ( \\( \\vec{E} \\) ) and magnetic ( \\( \\vec{B} \\) ) fields, using the classical Lorentz force law : \\[ \\vec{F} = q\\vec{E} + q(\\vec{v} \\times \\vec{B}) \\] Where: - \\( \\vec{F} \\) : total force acting on the particle (Newtons) - \\( q \\) : electric charge of the particle (Coulombs) - \\( \\vec{E} \\) : electric field vector (V/m) - \\( \\vec{v} \\) : instantaneous velocity of the particle (m/s) - \\( \\vec{B} \\) : magnetic field vector (Tesla) This force governs many fundamental processes in plasma physics, space science, and accelerator technology.","title":"Introduction"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#project-goals","text":"Simulate the 3D motion of charged particles under various field configurations Numerically integrate Newton\u2019s second law using the Euler method Analyze motion types: circular, helical, linear, and drift trajectories Derive physical quantities like the Larmor radius and drift velocity Visualize results with interactive and static 3D plots","title":"Project Goals"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#physical-concepts","text":"","title":"Physical Concepts"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#1-pure-magnetic-field-vece-0","text":"The force is always perpendicular to the velocity The particle performs uniform circular or helical motion No energy is gained or lost (speed remains constant)","title":"1. Pure Magnetic Field (\\( \\vec{E} = 0 \\))"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#2-pure-electric-field-vecb-0","text":"The particle undergoes uniform linear acceleration Kinetic energy increases with time Trajectory is a parabola in time","title":"2. Pure Electric Field (\\( \\vec{B} = 0 \\))"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#3-crossed-fields-vece-perp-vecb","text":"Particle drifts at velocity: $$ \\vec{v}_d = \\frac{\\vec{E} \\times \\vec{B}}{B^2} $$ Superposition of drift and circular motion: cycloidal trajectory","title":"3. Crossed Fields (\\( \\vec{E} \\perp \\vec{B} \\))"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#4-larmor-radius","text":"The radius of circular motion in a uniform magnetic field is given by: \\[ r_L = \\frac{m v_\\perp}{|q| B} \\] Where \\( v_\\perp \\) is the component of velocity perpendicular to \\( \\vec{B} \\) .","title":"4. Larmor Radius"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#python-simulation-code","text":"The following code uses NumPy and Matplotlib to simulate and plot the trajectory using the Euler method for numerical integration: import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D # ------------------------------- # 1. Define Physical Parameters # ------------------------------- q = 1.6e-19 # Particle charge (C) m = 9.11e-31 # Particle mass (kg) E = np.array([0.0, 0.0, 0.0]) # Electric field (V/m) B = np.array([0.0, 0.0, 1.0]) # Magnetic field (T) v0 = np.array([1e6, 0.0, 1e6]) # Initial velocity (m/s) x0 = np.array([0.0, 0.0, 0.0]) # Initial position (m) # ------------------------------- # 2. Time Discretization # ------------------------------- dt = 1e-11 # Time step (s) t_max = 1e-7 # Total time (s) steps = int(t_max / dt) # ------------------------------- # 3. Initialize Arrays # ------------------------------- x = np.zeros((steps, 3)) v = np.zeros((steps, 3)) x[0] = x0 v[0] = v0 # ------------------------------- # 4. Euler Method Loop # ------------------------------- for i in range(steps - 1): F = q * (E + np.cross(v[i], B)) a = F / m v[i + 1] = v[i] + a * dt x[i + 1] = x[i] + v[i] * dt # ------------------------------- # 5. 3D Trajectory Plot # ------------------------------- fig = plt.figure(figsize=(10, 6)) ax = fig.add_subplot(111, projection='3d') ax.plot(x[:, 0], x[:, 1], x[:, 2], label=\"Particle Trajectory\", color='navy') ax.set_xlabel('x (m)') ax.set_ylabel('y (m)') ax.set_zlabel('z (m)') ax.set_title('Charged Particle Trajectory in Electromagnetic Field') ax.legend() plt.tight_layout() plt.show()","title":"Python Simulation Code"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#observations","text":"Helical Motion : When \\( \\vec{v} \\) has both perpendicular and parallel components relative to \\( \\vec{B} \\) , a helical path forms. Drift Motion : In \\( \\vec{E} \\times \\vec{B} \\) configuration, a constant lateral drift occurs. Acceleration : In the presence of an electric field, energy increases over time. Confinement : Stronger \\( B \\) fields reduce the radius, improving magnetic confinement.","title":"Observations"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#real-world-applications","text":"System Role of Lorentz Force Cyclotron Circular acceleration of particles via magnetic fields Mass Spectrometry Charge-to-mass separation using \\( \\vec{v} \\times \\vec{B} \\) Fusion Reactors Plasma confinement with strong \\( \\vec{B} \\) and \\( \\vec{E} \\) fields Auroras Charged solar particles guided by Earth's magnetic field Van Allen Belts Trapped particle dynamics governed by Earth's magnetosphere","title":"Real-World Applications"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#parameter-exploration-ideas","text":"To study different scenarios, try changing: q , m \u2192 particle identity (electron, proton, ion, etc.) E , B \u2192 field directions and magnitudes v0 \u2192 perpendicular vs. parallel velocity components dt , t_max \u2192 resolution and simulation span For instance: - Set \\( \\vec{E} = [1e4, 0, 0] \\) , \\( \\vec{B} = [0, 0, 1] \\) for E \u00d7 B drift - Try \\( v_0 = [0, 1e6, 0] \\) to isolate circular motion - Simulate multiple particles or particles of opposite charge","title":"Parameter Exploration Ideas"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#conclusion","text":"This simulation provides a clear and flexible numerical tool to understand the behavior of charged particles under electromagnetic forces. It highlights: Rotational motion in magnetic fields Linear acceleration in electric fields Guided drift motion in combined fields The approach can be extended to: - Use more accurate integration (e.g., Runge-Kutta) - Introduce spatially or temporally varying fields - Model multi-particle plasma dynamics - Include relativistic corrections for high-speed particles Understanding Lorentz force dynamics is crucial in disciplines like astrophysics , plasma engineering , space weather modeling , and particle accelerator design .","title":"Conclusion"},{"location":"1%20Physics/5%20Circuits/Problem_1/","text":"Problem 1 Equivalent Resistance Using Graph Theory Motivation Calculating equivalent resistance is fundamental in circuit analysis. Traditional methods rely on identifying series and parallel combinations. However, for complex networks , this approach becomes inefficient and error-prone. Graph theory provides a structured, algorithmic method to analyze circuits: Nodes represent junctions. Edges represent resistors (with weights equal to resistance). Using graph reduction and traversal algorithms, we can compute the total equivalent resistance even for intricate networks. Theoretical Foundation A resistor network can be modeled as an undirected weighted graph : Each node represents a connection point. Each edge connects two nodes and carries a resistance . We aim to compute the total resistance between two terminals (e.g., node A and B), regardless of how resistors are connected (series, parallel, nested). Mathematical Background Ohm's Law: \\[ V = IR \\] Kirchhoff\u2019s Laws: KCL (Node Law) : The sum of currents into a node is zero. KVL (Loop Law) : The sum of voltages in a closed loop is zero. Using these laws, a circuit graph can be converted into a system of equations. Algorithm Description Goal Given a resistor network (graph), reduce it to a single equivalent resistance between two nodes. Key Steps Identify simple structures : Series connections Parallel connections Iteratively reduce the graph: Merge series resistors: If nodes A\u2013B\u2013C form a chain: $$ R_{eq} = R_{AB} + R_{BC} $$ Merge parallel resistors: If multiple edges between A and B: $$ \\frac{1}{R_{eq}} = \\sum \\frac{1}{R_i} $$ Repeat until only two nodes remain (the terminals), connected by one edge (the equivalent resistance). Handling Nested Structures Nested combinations are reduced layer by layer: Use DFS or BFS to find: Chains : For series reduction. Cycles : For parallel reduction. After each reduction, update the graph and repeat traversal. Pseudocode function calculate_equivalent_resistance(graph, terminalA, terminalB): while graph has more than two nodes: for each node in graph: if node is not terminal and degree == 2: neighbors = get_neighbors(node) if not is_cycle(neighbors + node): reduce_series(node) for each pair of nodes: if multiple edges exist: reduce_parallel(pair) return weight of edge(terminalA, terminalB) Implementation in Python (Using networkx ) import networkx as nx def reduce_series(G): changed = True while changed: changed = False for node in list(G.nodes()): if G.degree(node) == 2 and node not in ('A', 'B'): u, v = list(G.neighbors(node)) if G.number_of_edges(u, node) == 1 and G.number_of_edges(node, v) == 1: R1 = G[u][node]['resistance'] R2 = G[node][v]['resistance'] G.add_edge(u, v, resistance=R1 + R2) G.remove_node(node) changed = True break def reduce_parallel(G): for u, v in list(G.edges()): parallel_edges = [d['resistance'] for key, d in G.get_edge_data(u, v).items()] if len(parallel_edges) > 1: Req_inv = sum(1/r for r in parallel_edges) G.remove_edges_from(list(G.edges(u, v))) G.add_edge(u, v, resistance=1 / Req_inv) def equivalent_resistance(G, start, end): reduce_series(G) reduce_parallel(G) return G[start][end]['resistance'] Example Inputs 1. Simple Series A\u20141\u03a9\u2014B\u20142\u03a9\u2014C Find resistance between A and C: \\[ R_{eq} = 1 + 2 = 3\\ \\Omega \\] 2. Simple Parallel A\u20141\u03a9\u2014B A\u20142\u03a9\u2014B Parallel: \\[ \\frac{1}{R_{eq}} = \\frac{1}{1} + \\frac{1}{2} = \\frac{3}{2} \\Rightarrow R_{eq} = \\frac{2}{3}\\ \\Omega \\] 3. Nested Combination \u250c\u2500\u2500 3\u03a9 \u2500\u2500\u2510 A \u2500\u2500\u2500\u2524 \u251c\u2500\u2500\u2500 C \u2514\u2500\u2500 6\u03a9 \u2500\u2500\u2518 Parallel branch between A and C: \\[ \\frac{1}{R_{eq}} = \\frac{1}{3} + \\frac{1}{6} = \\frac{1}{2} \\Rightarrow R_{eq} = 2\\ \\Omega \\] Complexity & Efficiency Series and Parallel reductions are linear in the number of nodes and edges. Worst-case: \\( O(n^2) \\) due to repeated traversals and updates. Can be improved using: Union-Find structure for disjoint sets. Smart cycle detection to skip unnecessary checks. Extensions and Applications Works for resistors, conductance, or even capacitors (in frequency domain). Basis for circuit simulators (like SPICE). Extensible to mesh and nodal analysis . --- Conclusion Graph theory offers a powerful and elegant framework for analyzing electrical circuits, especially when dealing with complex or nested resistor networks. By representing circuits as weighted graphs, we can abstract away physical layouts and focus purely on the structural relationships between components. This method enables: Automated simplification of resistor networks. Scalability to large and intricate topologies. Cross-domain applications , blending electrical engineering with computer science and discrete mathematics. While traditional series-parallel reduction is intuitive for small circuits, graph-based approaches generalize the process and open the door for advanced algorithmic techniques. As modern engineering increasingly relies on simulation and automation, such graph-theoretic methods become not just helpful\u2014but essential. In conclusion, viewing circuits through the lens of graph theory enriches both the understanding and capability of circuit analysis, making it a vital tool in the modern electrical engineer\u2019s toolkit.","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#equivalent-resistance-using-graph-theory","text":"","title":"Equivalent Resistance Using Graph Theory"},{"location":"1%20Physics/5%20Circuits/Problem_1/#motivation","text":"Calculating equivalent resistance is fundamental in circuit analysis. Traditional methods rely on identifying series and parallel combinations. However, for complex networks , this approach becomes inefficient and error-prone. Graph theory provides a structured, algorithmic method to analyze circuits: Nodes represent junctions. Edges represent resistors (with weights equal to resistance). Using graph reduction and traversal algorithms, we can compute the total equivalent resistance even for intricate networks.","title":"Motivation"},{"location":"1%20Physics/5%20Circuits/Problem_1/#theoretical-foundation","text":"A resistor network can be modeled as an undirected weighted graph : Each node represents a connection point. Each edge connects two nodes and carries a resistance . We aim to compute the total resistance between two terminals (e.g., node A and B), regardless of how resistors are connected (series, parallel, nested).","title":"Theoretical Foundation"},{"location":"1%20Physics/5%20Circuits/Problem_1/#mathematical-background","text":"","title":"Mathematical Background"},{"location":"1%20Physics/5%20Circuits/Problem_1/#ohms-law","text":"\\[ V = IR \\]","title":"Ohm's Law:"},{"location":"1%20Physics/5%20Circuits/Problem_1/#kirchhoffs-laws","text":"KCL (Node Law) : The sum of currents into a node is zero. KVL (Loop Law) : The sum of voltages in a closed loop is zero. Using these laws, a circuit graph can be converted into a system of equations.","title":"Kirchhoff\u2019s Laws:"},{"location":"1%20Physics/5%20Circuits/Problem_1/#algorithm-description","text":"","title":"Algorithm Description"},{"location":"1%20Physics/5%20Circuits/Problem_1/#goal","text":"Given a resistor network (graph), reduce it to a single equivalent resistance between two nodes.","title":"Goal"},{"location":"1%20Physics/5%20Circuits/Problem_1/#key-steps","text":"Identify simple structures : Series connections Parallel connections Iteratively reduce the graph: Merge series resistors: If nodes A\u2013B\u2013C form a chain: $$ R_{eq} = R_{AB} + R_{BC} $$ Merge parallel resistors: If multiple edges between A and B: $$ \\frac{1}{R_{eq}} = \\sum \\frac{1}{R_i} $$ Repeat until only two nodes remain (the terminals), connected by one edge (the equivalent resistance).","title":"Key Steps"},{"location":"1%20Physics/5%20Circuits/Problem_1/#handling-nested-structures","text":"Nested combinations are reduced layer by layer: Use DFS or BFS to find: Chains : For series reduction. Cycles : For parallel reduction. After each reduction, update the graph and repeat traversal.","title":"Handling Nested Structures"},{"location":"1%20Physics/5%20Circuits/Problem_1/#pseudocode","text":"function calculate_equivalent_resistance(graph, terminalA, terminalB): while graph has more than two nodes: for each node in graph: if node is not terminal and degree == 2: neighbors = get_neighbors(node) if not is_cycle(neighbors + node): reduce_series(node) for each pair of nodes: if multiple edges exist: reduce_parallel(pair) return weight of edge(terminalA, terminalB)","title":"Pseudocode"},{"location":"1%20Physics/5%20Circuits/Problem_1/#implementation-in-python-using-networkx","text":"import networkx as nx def reduce_series(G): changed = True while changed: changed = False for node in list(G.nodes()): if G.degree(node) == 2 and node not in ('A', 'B'): u, v = list(G.neighbors(node)) if G.number_of_edges(u, node) == 1 and G.number_of_edges(node, v) == 1: R1 = G[u][node]['resistance'] R2 = G[node][v]['resistance'] G.add_edge(u, v, resistance=R1 + R2) G.remove_node(node) changed = True break def reduce_parallel(G): for u, v in list(G.edges()): parallel_edges = [d['resistance'] for key, d in G.get_edge_data(u, v).items()] if len(parallel_edges) > 1: Req_inv = sum(1/r for r in parallel_edges) G.remove_edges_from(list(G.edges(u, v))) G.add_edge(u, v, resistance=1 / Req_inv) def equivalent_resistance(G, start, end): reduce_series(G) reduce_parallel(G) return G[start][end]['resistance']","title":"Implementation in Python (Using networkx)"},{"location":"1%20Physics/5%20Circuits/Problem_1/#example-inputs","text":"","title":"Example Inputs"},{"location":"1%20Physics/5%20Circuits/Problem_1/#1-simple-series","text":"A\u20141\u03a9\u2014B\u20142\u03a9\u2014C Find resistance between A and C: \\[ R_{eq} = 1 + 2 = 3\\ \\Omega \\]","title":"1. Simple Series"},{"location":"1%20Physics/5%20Circuits/Problem_1/#2-simple-parallel","text":"A\u20141\u03a9\u2014B A\u20142\u03a9\u2014B Parallel: \\[ \\frac{1}{R_{eq}} = \\frac{1}{1} + \\frac{1}{2} = \\frac{3}{2} \\Rightarrow R_{eq} = \\frac{2}{3}\\ \\Omega \\]","title":"2. Simple Parallel"},{"location":"1%20Physics/5%20Circuits/Problem_1/#3-nested-combination","text":"\u250c\u2500\u2500 3\u03a9 \u2500\u2500\u2510 A \u2500\u2500\u2500\u2524 \u251c\u2500\u2500\u2500 C \u2514\u2500\u2500 6\u03a9 \u2500\u2500\u2518 Parallel branch between A and C: \\[ \\frac{1}{R_{eq}} = \\frac{1}{3} + \\frac{1}{6} = \\frac{1}{2} \\Rightarrow R_{eq} = 2\\ \\Omega \\]","title":"3. Nested Combination"},{"location":"1%20Physics/5%20Circuits/Problem_1/#complexity-efficiency","text":"Series and Parallel reductions are linear in the number of nodes and edges. Worst-case: \\( O(n^2) \\) due to repeated traversals and updates. Can be improved using: Union-Find structure for disjoint sets. Smart cycle detection to skip unnecessary checks.","title":"Complexity &amp; Efficiency"},{"location":"1%20Physics/5%20Circuits/Problem_1/#extensions-and-applications","text":"Works for resistors, conductance, or even capacitors (in frequency domain). Basis for circuit simulators (like SPICE). Extensible to mesh and nodal analysis .","title":"Extensions and Applications"},{"location":"1%20Physics/5%20Circuits/Problem_1/#-","text":"","title":"---"},{"location":"1%20Physics/5%20Circuits/Problem_1/#conclusion","text":"Graph theory offers a powerful and elegant framework for analyzing electrical circuits, especially when dealing with complex or nested resistor networks. By representing circuits as weighted graphs, we can abstract away physical layouts and focus purely on the structural relationships between components. This method enables: Automated simplification of resistor networks. Scalability to large and intricate topologies. Cross-domain applications , blending electrical engineering with computer science and discrete mathematics. While traditional series-parallel reduction is intuitive for small circuits, graph-based approaches generalize the process and open the door for advanced algorithmic techniques. As modern engineering increasingly relies on simulation and automation, such graph-theoretic methods become not just helpful\u2014but essential. In conclusion, viewing circuits through the lens of graph theory enriches both the understanding and capability of circuit analysis, making it a vital tool in the modern electrical engineer\u2019s toolkit.","title":"Conclusion"},{"location":"1%20Physics/6%20Statistics/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_2/","text":"Problem 2","title":"Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/7%20Measurements/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"2%20Mathematics/1%20Linear_algebra/","text":"Linear Algebra","title":"Linear Algebra"},{"location":"2%20Mathematics/1%20Linear_algebra/#linear-algebra","text":"","title":"Linear Algebra"},{"location":"2%20Mathematics/2%20Analytic_geometry/","text":"Analytic geometry","title":"Analytic geometry"},{"location":"2%20Mathematics/2%20Analytic_geometry/#analytic-geometry","text":"","title":"Analytic geometry"},{"location":"2%20Mathematics/3%20Calculus/","text":"Calculus","title":"Calculus"},{"location":"2%20Mathematics/3%20Calculus/#calculus","text":"","title":"Calculus"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/","text":"Set Theory","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/#set-theory","text":"","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/","text":"Relations","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/#relations","text":"","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/","text":"Functions","title":"Functions"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/#functions","text":"","title":"Functions"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/","text":"Combinatorics","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/#combinatorics","text":"","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/","text":"Number Theory","title":"Number Theory"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/#number-theory","text":"","title":"Number Theory"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/","text":"Sequences and Series","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/#sequences-and-series","text":"","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/","text":"Induction","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/#induction","text":"","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/","text":"Recurrence","title":"Recurrence"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/#recurrence","text":"","title":"Recurrence"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/","text":"Graph Theory","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/#graph-theory","text":"","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/","text":"Logic","title":"Logic"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/#logic","text":"","title":"Logic"}]}