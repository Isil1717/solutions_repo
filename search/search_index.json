{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Technical setup Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft) Useful links Python Miniconda Documentation Google Colab How to use this repository Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW Where can I find the problems? Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Introduction"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#technical-setup","text":"Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft)","title":"Technical setup"},{"location":"#useful-links","text":"Python Miniconda Documentation Google Colab","title":"Useful links"},{"location":"#how-to-use-this-repository","text":"Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW","title":"How to use this repository"},{"location":"#where-can-i-find-the-problems","text":"Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Where can I find the problems?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/","text":"\u2699\ufe0f Mechanics \u2013 Problem 1 \ud83c\udfaf Investigating the Range as a Function of the Angle of Projection \ud83e\udde0 Motivation Projectile motion is one of the most fundamental yet insightful topics in classical mechanics. While it may seem simple at first, it offers a rich framework to explore the relationships between velocity, angle, gravity, and trajectory. This task focuses on understanding how the range of a projectile depends on the angle of projection , while considering the influence of other variables such as initial velocity and gravitational acceleration. \ud83d\udcd0 1. Theoretical Foundation Equations of Motion A projectile launched at an angle \\( \\theta \\) with an initial velocity \\( v_0 \\) follows a curved path (parabola) due to the influence of gravity. The motion can be separated into two components: Horizontal motion (constant velocity) Vertical motion (uniform acceleration due to gravity) Velocity Components The initial velocity is split into horizontal and vertical components: \\[ v_{0x} = v_0 \\cos(\\theta), \\quad v_{0y} = v_0 \\sin(\\theta) \\] Time of Flight Assuming the projectile lands at the same vertical level it was launched: \\[ T = \\frac{2 v_0 \\sin(\\theta)}{g} \\] Range Formula The horizontal distance (range) the projectile travels before hitting the ground is: \\[ R = v_{0x} \\cdot T = v_0 \\cos(\\theta) \\cdot \\frac{2 v_0 \\sin(\\theta)}{g} = \\frac{v_0^2 \\sin(2\\theta)}{g} \\] Maximum range is achieved when: \\[ \\theta = 45^\\circ \\] This formula is valid only when the launch and landing heights are the same and air resistance is neglected. \ud83d\udcca 2. Range Analysis with Python Now let's analyze how the range varies with the angle of projection using Python and visualize it with a graph. ```python import numpy as np import matplotlib.pyplot as plt Constants v0 = 30 # initial velocity in m/s g = 9.81 # acceleration due to gravity in m/s^2 Angle values from 0 to 90 degrees angles = np.linspace(0, 90, 500) angles_rad = np.radians(angles) Range formula ranges = (v0 ** 2) * np.sin(2 * angles_rad) / g Plotting plt.figure(figsize=(10, 6)) plt.plot(angles, ranges, color='darkorange', linewidth=2) plt.title('Projectile Range vs. Launch Angle') plt.xlabel('Launch Angle (degrees)') plt.ylabel('Range (meters)') plt.axvline(45, linestyle='--', color='gray', label='Maximum Range at 45\u00b0') plt.grid(True) plt.legend() plt.show()","title":"\u2699\ufe0f Mechanics \u2013 Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#mechanics-problem-1","text":"","title":"\u2699\ufe0f Mechanics \u2013 Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#investigating-the-range-as-a-function-of-the-angle-of-projection","text":"","title":"\ud83c\udfaf Investigating the Range as a Function of the Angle of Projection"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#motivation","text":"Projectile motion is one of the most fundamental yet insightful topics in classical mechanics. While it may seem simple at first, it offers a rich framework to explore the relationships between velocity, angle, gravity, and trajectory. This task focuses on understanding how the range of a projectile depends on the angle of projection , while considering the influence of other variables such as initial velocity and gravitational acceleration.","title":"\ud83e\udde0 Motivation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#1-theoretical-foundation","text":"","title":"\ud83d\udcd0 1. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#equations-of-motion","text":"A projectile launched at an angle \\( \\theta \\) with an initial velocity \\( v_0 \\) follows a curved path (parabola) due to the influence of gravity. The motion can be separated into two components: Horizontal motion (constant velocity) Vertical motion (uniform acceleration due to gravity)","title":"Equations of Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#velocity-components","text":"The initial velocity is split into horizontal and vertical components: \\[ v_{0x} = v_0 \\cos(\\theta), \\quad v_{0y} = v_0 \\sin(\\theta) \\]","title":"Velocity Components"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#time-of-flight","text":"Assuming the projectile lands at the same vertical level it was launched: \\[ T = \\frac{2 v_0 \\sin(\\theta)}{g} \\]","title":"Time of Flight"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#range-formula","text":"The horizontal distance (range) the projectile travels before hitting the ground is: \\[ R = v_{0x} \\cdot T = v_0 \\cos(\\theta) \\cdot \\frac{2 v_0 \\sin(\\theta)}{g} = \\frac{v_0^2 \\sin(2\\theta)}{g} \\] Maximum range is achieved when: \\[ \\theta = 45^\\circ \\] This formula is valid only when the launch and landing heights are the same and air resistance is neglected.","title":"Range Formula"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#2-range-analysis-with-python","text":"Now let's analyze how the range varies with the angle of projection using Python and visualize it with a graph. ```python import numpy as np import matplotlib.pyplot as plt","title":"\ud83d\udcca 2. Range Analysis with Python"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#constants","text":"v0 = 30 # initial velocity in m/s g = 9.81 # acceleration due to gravity in m/s^2","title":"Constants"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#angle-values-from-0-to-90-degrees","text":"angles = np.linspace(0, 90, 500) angles_rad = np.radians(angles)","title":"Angle values from 0 to 90 degrees"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#range-formula_1","text":"ranges = (v0 ** 2) * np.sin(2 * angles_rad) / g","title":"Range formula"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#plotting","text":"plt.figure(figsize=(10, 6)) plt.plot(angles, ranges, color='darkorange', linewidth=2) plt.title('Projectile Range vs. Launch Angle') plt.xlabel('Launch Angle (degrees)') plt.ylabel('Range (meters)') plt.axvline(45, linestyle='--', color='gray', label='Maximum Range at 45\u00b0') plt.grid(True) plt.legend() plt.show()","title":"Plotting"},{"location":"1%20Physics/1%20Mechanics/Problem_2/","text":"Problem 2 \ud83c\udf00 Investigating the Dynamics of a Forced Damped Pendulum \ud83d\udd0d Motivation The forced damped pendulum is a nonlinear system that shows a range of behaviors\u2014resonance, quasiperiodicity, and even chaos. Studying its dynamics reveals how simple equations can lead to complex motion and provides insight into a variety of real-world systems: Driven mechanical structures Energy harvesters Oscillating circuits Climate models and biomechanical rhythms \u2699\ufe0f Governing Equation The equation describing the pendulum's motion is: \\[ \\frac{d^2\\theta}{dt^2} + b \\frac{d\\theta}{dt} + \\frac{g}{L} \\sin(\\theta) = A \\cos(\\omega t) \\] Where: $ \\theta(t) $ \u2014 angular displacement $ b $ \u2014 damping coefficient $ g $ \u2014 gravitational acceleration $ L $ \u2014 pendulum length $ A $ \u2014 driving force amplitude $ \\omega $ \u2014 driving frequency \ud83e\udde0 Theoretical Foundation \ud83d\udd39 Linear Approximation for Small Angles For small angles, we can use the approximation: \\[ \\sin(\\theta) \\approx \\theta \\] This simplifies the equation to: \\[ \\frac{d^2\\theta}{dt^2} + b \\frac{d\\theta}{dt} + \\frac{g}{L} \\theta = A \\cos(\\omega t) \\] This is the driven damped harmonic oscillator , which has the general solution: \\[ \\theta(t) = \\theta_{\\text{hom}}(t) + \\theta_{\\text{part}}(t) \\] Where: $ \\theta_{\\text{hom}}(t) $ \u2014 transient (decaying) solution $ \\theta_{\\text{part}}(t) $ \u2014 steady-state oscillation due to the external force \ud83d\udcbb Numerical Simulation (Nonlinear Case) We now solve the full nonlinear system numerically. import numpy as np from scipy.integrate import solve_ivp import matplotlib.pyplot as plt def pendulum(t, y, b, g, L, A, omega): theta, omega_ = y dtheta_dt = omega_ domega_dt = -b * omega_ - (g / L) * np.sin(theta) + A * np.cos(omega * t) return [dtheta_dt, domega_dt] # Parameters params = dict(b=0.5, g=9.81, L=1.0, A=1.2, omega=2.0) y0 = [0.1, 0.0] t_eval = np.linspace(0, 50, 1000) sol = solve_ivp(pendulum, [0, 50], y0, t_eval=t_eval, args=tuple(params.values())) plt.plot(sol.t, sol.y[0]) plt.title(\"Forced Damped Pendulum: \u03b8(t)\") plt.xlabel(\"Time (s)\") plt.ylabel(\"\u03b8 (rad)\") plt.grid() plt.show()","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#investigating-the-dynamics-of-a-forced-damped-pendulum","text":"","title":"\ud83c\udf00 Investigating the Dynamics of a Forced Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#motivation","text":"The forced damped pendulum is a nonlinear system that shows a range of behaviors\u2014resonance, quasiperiodicity, and even chaos. Studying its dynamics reveals how simple equations can lead to complex motion and provides insight into a variety of real-world systems: Driven mechanical structures Energy harvesters Oscillating circuits Climate models and biomechanical rhythms","title":"\ud83d\udd0d Motivation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#governing-equation","text":"The equation describing the pendulum's motion is: \\[ \\frac{d^2\\theta}{dt^2} + b \\frac{d\\theta}{dt} + \\frac{g}{L} \\sin(\\theta) = A \\cos(\\omega t) \\] Where: $ \\theta(t) $ \u2014 angular displacement $ b $ \u2014 damping coefficient $ g $ \u2014 gravitational acceleration $ L $ \u2014 pendulum length $ A $ \u2014 driving force amplitude $ \\omega $ \u2014 driving frequency","title":"\u2699\ufe0f Governing Equation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#theoretical-foundation","text":"","title":"\ud83e\udde0 Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#linear-approximation-for-small-angles","text":"For small angles, we can use the approximation: \\[ \\sin(\\theta) \\approx \\theta \\] This simplifies the equation to: \\[ \\frac{d^2\\theta}{dt^2} + b \\frac{d\\theta}{dt} + \\frac{g}{L} \\theta = A \\cos(\\omega t) \\] This is the driven damped harmonic oscillator , which has the general solution: \\[ \\theta(t) = \\theta_{\\text{hom}}(t) + \\theta_{\\text{part}}(t) \\] Where: $ \\theta_{\\text{hom}}(t) $ \u2014 transient (decaying) solution $ \\theta_{\\text{part}}(t) $ \u2014 steady-state oscillation due to the external force","title":"\ud83d\udd39 Linear Approximation for Small Angles"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#numerical-simulation-nonlinear-case","text":"We now solve the full nonlinear system numerically. import numpy as np from scipy.integrate import solve_ivp import matplotlib.pyplot as plt def pendulum(t, y, b, g, L, A, omega): theta, omega_ = y dtheta_dt = omega_ domega_dt = -b * omega_ - (g / L) * np.sin(theta) + A * np.cos(omega * t) return [dtheta_dt, domega_dt] # Parameters params = dict(b=0.5, g=9.81, L=1.0, A=1.2, omega=2.0) y0 = [0.1, 0.0] t_eval = np.linspace(0, 50, 1000) sol = solve_ivp(pendulum, [0, 50], y0, t_eval=t_eval, args=tuple(params.values())) plt.plot(sol.t, sol.y[0]) plt.title(\"Forced Damped Pendulum: \u03b8(t)\") plt.xlabel(\"Time (s)\") plt.ylabel(\"\u03b8 (rad)\") plt.grid() plt.show()","title":"\ud83d\udcbb Numerical Simulation (Nonlinear Case)"},{"location":"1%20Physics/2%20Gravity/Problem_1/","text":"\ud83c\udf0c Kepler\u2019s Third Law: Orbital Period and Radius Simulation with Python \ud83d\udcd8 Introduction Johannes Kepler\u2019s Third Law is a fundamental principle in celestial mechanics. It describes the relationship between the orbital period and the radius of a body orbiting a central mass in a circular orbit. Kepler\u2019s Third Law (for circular orbits): \\[ T^2 = \\frac{4 \\pi^2 r^3}{G M} \\] Where: \\( T \\) : Orbital period (seconds) \\( r \\) : Orbital radius (meters) \\( G \\) : Universal gravitational constant \\( (6.67430 \\times 10^{-11} \\, \\text{m}^3 \\text{kg}^{-1} \\text{s}^{-2}) \\) \\( M \\) : Mass of the central body (e.g., Earth) in kilograms This equation shows: \\[ T^2 \\propto r^3 \\] This elegant yet powerful relationship allows us to analyze planetary systems, satellites, star systems, and even galaxies. \ud83c\udfaf Objective Numerically verify Kepler\u2019s Third Law Calculate orbital periods for various radii using Python Visualize the linear relationship between \\( T^2 \\) and \\( r^3 \\) Discuss real-world examples (e.g., Earth-Moon system) \ud83e\udde0 Theoretical Background The gravitational force equals the centripetal force for circular motion: \\[ \\frac{G M m}{r^2} = \\frac{m v^2}{r} \\] Solving for orbital speed \\( v \\) : \\[ v = \\sqrt{\\frac{G M}{r}} \\] Orbital period: \\[ T = \\frac{2\\pi r}{v} \\] Substitute \\( v \\) : \\[ T = 2\\pi \\sqrt{\\frac{r^3}{G M}} \\Rightarrow T^2 = \\frac{4\\pi^2 r^3}{G M} \\] \ud83d\udcbb Python Implementation Let\u2019s verify this relationship numerically. \ud83d\udce6 Required Libraries import numpy as np import matplotlib.pyplot as plt \ud83c\udf0d Physical Constants G = 6.67430e-11 # Gravitational constant (m^3 kg^-1 s^-2) M = 5.972e24 # Mass of Earth (kg) \ud83d\udcd0 Radius and Period Calculations radii = np.linspace(1e7, 5e8, 200) # From 10,000 km to 500,000 km periods = 2 * np.pi * np.sqrt(radii**3 / (G * M)) \ud83d\udcc8 Plot: \ud835\udc47 2 T 2 vs \ud835\udc5f 3 r 3 python plt.figure(figsize=(10, 6)) plt.plot(radii 3, periods 2, label=r\" \\(T^2\\) vs \\(r^3\\) \", color=\"blue\") plt.xlabel(\"Orbital Radius Cubed \\(r^3\\) (m\u00b3)\") plt.ylabel(\"Orbital Period Squared \\(T^2\\) (s\u00b2)\") plt.title(\"Kepler's Third Law Verification\") plt.grid(True) plt.legend() plt.tight_layout() plt.show() \ud83c\udf0d Real-World Example: The Moon\u2019s Orbit Distance from Earth: \ud835\udc5f \u2248 3.84 \u00d7 10 8 \u2009 m r\u22483.84\u00d710 8 m Orbital period: \ud835\udc47 \u2248 27.3 \u2009 days = 2.36 \u00d7 10 6 \u2009 seconds T\u224827.3days=2.36\u00d710 6 seconds This can be used to reverse-calculate the mass of Earth using Kepler\u2019s Law. \ud83d\udccc Extension to Elliptical Orbits Circular orbits are a special case. For elliptical orbits, Kepler\u2019s Third Law generalizes to: \ud835\udc47 2 = 4 \ud835\udf0b 2 \ud835\udc4e 3 \ud835\udc3a ( \ud835\udc40 + \ud835\udc5a ) T 2 = G(M+m) 4\u03c0 2 a 3 \u200b Here, \ud835\udc4e a is the semi-major axis. If the orbiting body is much smaller than the central body, \ud835\udc40 + \ud835\udc5a \u2248 \ud835\udc40 M+m\u2248M. \u2705 Conclusion The relationship \ud835\udc47 2 \u221d \ud835\udc5f 3 T 2 \u221dr 3 has been confirmed numerically The graph shows a clear linear trend between \ud835\udc47 2 T 2 and \ud835\udc5f 3 r 3 Kepler\u2019s Law is critical in mass and distance calculations in astronomy This principle enables accurate modeling of satellites, planetary systems, and galaxies","title":"\ud83c\udf0c Kepler\u2019s Third Law: Orbital Period and Radius Simulation with Python"},{"location":"1%20Physics/2%20Gravity/Problem_1/#keplers-third-law-orbital-period-and-radius-simulation-with-python","text":"","title":"\ud83c\udf0c Kepler\u2019s Third Law: Orbital Period and Radius Simulation with Python"},{"location":"1%20Physics/2%20Gravity/Problem_1/#introduction","text":"Johannes Kepler\u2019s Third Law is a fundamental principle in celestial mechanics. It describes the relationship between the orbital period and the radius of a body orbiting a central mass in a circular orbit. Kepler\u2019s Third Law (for circular orbits): \\[ T^2 = \\frac{4 \\pi^2 r^3}{G M} \\] Where: \\( T \\) : Orbital period (seconds) \\( r \\) : Orbital radius (meters) \\( G \\) : Universal gravitational constant \\( (6.67430 \\times 10^{-11} \\, \\text{m}^3 \\text{kg}^{-1} \\text{s}^{-2}) \\) \\( M \\) : Mass of the central body (e.g., Earth) in kilograms This equation shows: \\[ T^2 \\propto r^3 \\] This elegant yet powerful relationship allows us to analyze planetary systems, satellites, star systems, and even galaxies.","title":"\ud83d\udcd8 Introduction"},{"location":"1%20Physics/2%20Gravity/Problem_1/#objective","text":"Numerically verify Kepler\u2019s Third Law Calculate orbital periods for various radii using Python Visualize the linear relationship between \\( T^2 \\) and \\( r^3 \\) Discuss real-world examples (e.g., Earth-Moon system)","title":"\ud83c\udfaf Objective"},{"location":"1%20Physics/2%20Gravity/Problem_1/#theoretical-background","text":"The gravitational force equals the centripetal force for circular motion: \\[ \\frac{G M m}{r^2} = \\frac{m v^2}{r} \\] Solving for orbital speed \\( v \\) : \\[ v = \\sqrt{\\frac{G M}{r}} \\] Orbital period: \\[ T = \\frac{2\\pi r}{v} \\] Substitute \\( v \\) : \\[ T = 2\\pi \\sqrt{\\frac{r^3}{G M}} \\Rightarrow T^2 = \\frac{4\\pi^2 r^3}{G M} \\]","title":"\ud83e\udde0 Theoretical Background"},{"location":"1%20Physics/2%20Gravity/Problem_1/#python-implementation","text":"Let\u2019s verify this relationship numerically.","title":"\ud83d\udcbb Python Implementation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#required-libraries","text":"import numpy as np import matplotlib.pyplot as plt \ud83c\udf0d Physical Constants G = 6.67430e-11 # Gravitational constant (m^3 kg^-1 s^-2) M = 5.972e24 # Mass of Earth (kg) \ud83d\udcd0 Radius and Period Calculations radii = np.linspace(1e7, 5e8, 200) # From 10,000 km to 500,000 km periods = 2 * np.pi * np.sqrt(radii**3 / (G * M)) \ud83d\udcc8 Plot: \ud835\udc47 2 T 2 vs \ud835\udc5f 3 r 3 python plt.figure(figsize=(10, 6)) plt.plot(radii 3, periods 2, label=r\" \\(T^2\\) vs \\(r^3\\) \", color=\"blue\") plt.xlabel(\"Orbital Radius Cubed \\(r^3\\) (m\u00b3)\") plt.ylabel(\"Orbital Period Squared \\(T^2\\) (s\u00b2)\") plt.title(\"Kepler's Third Law Verification\") plt.grid(True) plt.legend() plt.tight_layout() plt.show() \ud83c\udf0d Real-World Example: The Moon\u2019s Orbit Distance from Earth: \ud835\udc5f \u2248 3.84 \u00d7 10 8 \u2009 m r\u22483.84\u00d710 8 m Orbital period: \ud835\udc47 \u2248 27.3 \u2009 days = 2.36 \u00d7 10 6 \u2009 seconds T\u224827.3days=2.36\u00d710 6 seconds This can be used to reverse-calculate the mass of Earth using Kepler\u2019s Law. \ud83d\udccc Extension to Elliptical Orbits Circular orbits are a special case. For elliptical orbits, Kepler\u2019s Third Law generalizes to: \ud835\udc47 2 = 4 \ud835\udf0b 2 \ud835\udc4e 3 \ud835\udc3a ( \ud835\udc40 + \ud835\udc5a ) T 2 = G(M+m) 4\u03c0 2 a 3 \u200b Here, \ud835\udc4e a is the semi-major axis. If the orbiting body is much smaller than the central body, \ud835\udc40 + \ud835\udc5a \u2248 \ud835\udc40 M+m\u2248M. \u2705 Conclusion The relationship \ud835\udc47 2 \u221d \ud835\udc5f 3 T 2 \u221dr 3 has been confirmed numerically The graph shows a clear linear trend between \ud835\udc47 2 T 2 and \ud835\udc5f 3 r 3 Kepler\u2019s Law is critical in mass and distance calculations in astronomy This principle enables accurate modeling of satellites, planetary systems, and galaxies","title":"\ud83d\udce6 Required Libraries"},{"location":"1%20Physics/2%20Gravity/Problem_2/","text":"Problem 2 Cosmic Velocities: Theory, Implementation & Visualizations This project calculates the first , second , and third cosmic velocities for Earth , Mars , and Jupiter , including mathematical derivations , Python code , and visualizations . Table of Contents Theoretical Background First Cosmic Velocity Second Cosmic Velocity Third Cosmic Velocity Constants and Parameters Python Code Implementation Results Visualization Applications in Space Exploration Conclusions 1. \ud83c\udf0c Theoretical Background 1.1 First Cosmic Velocity The first cosmic velocity is the minimum speed required to enter orbit around a celestial body. This is based on the balance between centripetal force and gravitational force . Mathematically, it is derived from the following relation: \\[ F_{\\text{centripetal}} = F_{\\text{gravitational}} \\] Where: \\[ \\frac{m v_1^2}{R} = \\frac{G M m}{R^2} \\] Simplifying for \\( v_1 \\) , we get the first cosmic velocity : \\[ v_1 = \\sqrt{\\frac{GM}{R}} \\] Where: - \\( G \\) = Gravitational constant \\( 6.67430 \\times 10^{-11} \\ \\text{m}^3 \\text{kg}^{-1} \\text{s}^{-2} \\) - \\( M \\) = Mass of the celestial body (kg) - \\( R \\) = Radius of the celestial body (m) 1.2 Second Cosmic Velocity The second cosmic velocity is the escape velocity , the speed needed to escape the gravitational pull of the celestial body. This can be derived from the energy conservation between kinetic energy and gravitational potential energy: \\[ E_{\\text{total}} = E_{\\text{kinetic}} + E_{\\text{potential}} \\] Where: \\[ E_{\\text{kinetic}} = \\frac{1}{2} m v^2 \\quad \\text{and} \\quad E_{\\text{potential}} = - \\frac{G M m}{R} \\] Setting total energy to zero for escape: \\[ \\frac{1}{2} m v_2^2 = \\frac{G M m}{R} \\] Simplifying, we find the second cosmic velocity : \\[ v_2 = \\sqrt{\\frac{2GM}{R}} = \\sqrt{2} \\times v_1 \\] 1.3 Third Cosmic Velocity The third cosmic velocity is the speed required to escape the gravitational influence of the solar system , i.e., to escape the Sun\u2019s gravitational pull. This can be determined using the escape velocity from the Sun at a given distance \\( r \\) from the Sun: \\[ v_3 = \\sqrt{v_2^2 + v_{\\text{solar escape}}^2} \\] Where \\( v_{\\text{solar escape}} \\) is the escape velocity from the Sun at the object\u2019s distance: \\[ v_{\\text{solar escape}} = \\sqrt{\\frac{2 G M_{\\text{Sun}}}{r_{\\text{sun}}}} \\] Where: - \\( r_{\\text{sun}} \\) is the distance from the Sun in meters. 2. \ud83d\udcda Constants and Parameters 2.1 Gravitational and Astronomical Constants Parameter Value Description \\( G \\) \\( 6.67430 \\times 10^{-11} \\ \\text{m}^3 \\text{kg}^{-1} \\text{s}^{-2} \\) Gravitational constant \\( M_{\\text{Sun}} \\) \\( 1.989 \\times 10^{30} \\ \\text{kg} \\) Mass of the Sun 1 AU \\( 1.496 \\times 10^{11} \\ \\text{m} \\) Astronomical unit 2.2 Planetary Data Planet Mass \\( M \\) (kg) Radius \\( R \\) (m) Distance to Sun (AU) Earth \\( 5.972 \\times 10^{24} \\) \\( 6.371 \\times 10^6 \\) 1.0 Mars \\( 6.39 \\times 10^{23} \\) \\( 3.3895 \\times 10^6 \\) 1.524 Jupiter \\( 1.898 \\times 10^{27} \\) \\( 6.9911 \\times 10^7 \\) 5.204 3. \ud83e\udde0 Python Code Implementation import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # Gravitational constant (m^3 kg^-1 s^-2) sun_mass = 1.989e30 # Mass of the Sun (kg) AU = 1.496e11 # Astronomical Unit (m) # Planetary data (Mass, Radius, Distance to Sun in AU) bodies = { \"Earth\": (5.972e24, 6.371e6, 1.0), \"Mars\": (6.39e23, 3.3895e6, 1.524), \"Jupiter\": (1.898e27, 6.9911e7, 5.204) } # Function to calculate velocities (v1, v2, v3) def calculate_velocities(mass, radius, distance_to_sun_AU): v1 = np.sqrt(G * mass / radius) v2 = np.sqrt(2) * v1 distance_to_sun = distance_to_sun_AU * AU v_sun_escape = np.sqrt(2 * G * sun_mass / distance_to_sun) v3 = np.sqrt(v2**2 + v_sun_escape**2) return v1, v2, v3 # Results results = {body: calculate_velocities(mass, radius, distance) for body, (mass, radius, distance) in bodies.items()} # Output Results for body, (v1, v2, v3) in results.items(): print(f\"{body}: v1 = {v1/1000:.2f} km/s, v2 = {v2/1000:.2f} km/s, v3 = {v3/1000:.2f} km/s\") # Visualization labels = list(results.keys()) v1_vals = [results[b][0] / 1000 for b in labels] v2_vals = [results[b][1] / 1000 for b in labels] v3_vals = [results[b][2] / 1000 for b in labels] x = np.arange(len(labels)) width = 0.25 fig, ax = plt.subplots(figsize=(8,5)) ax.bar(x - width, v1_vals, width, label='First Cosmic Velocity (v1)') ax.bar(x, v2_vals, width, label='Second Cosmic Velocity (v2)') ax.bar(x + width, v3_vals, width, label='Third Cosmic Velocity (v3)') ax.set_ylabel('Velocity (km/s)') ax.set_title('Cosmic Velocities for Planets') ax.set_xticks(x) ax.set_xticklabels(labels) ax.legend() ax.grid(True) plt.tight_layout() plt.show() Planet First Cosmic Velocity (v1) [km/s] Second Cosmic Velocity (v2) [km/s] Third Cosmic Velocity (v3) [km/s] Earth 7.91 11.18 42.13 Mars 5.03 7.11 34.38 Jupiter 42.12 59.55 66.69","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#cosmic-velocities-theory-implementation-visualizations","text":"This project calculates the first , second , and third cosmic velocities for Earth , Mars , and Jupiter , including mathematical derivations , Python code , and visualizations .","title":"Cosmic Velocities: Theory, Implementation &amp; Visualizations"},{"location":"1%20Physics/2%20Gravity/Problem_2/#table-of-contents","text":"Theoretical Background First Cosmic Velocity Second Cosmic Velocity Third Cosmic Velocity Constants and Parameters Python Code Implementation Results Visualization Applications in Space Exploration Conclusions","title":"Table of Contents"},{"location":"1%20Physics/2%20Gravity/Problem_2/#1-theoretical-background","text":"","title":"1. \ud83c\udf0c Theoretical Background"},{"location":"1%20Physics/2%20Gravity/Problem_2/#11-first-cosmic-velocity","text":"The first cosmic velocity is the minimum speed required to enter orbit around a celestial body. This is based on the balance between centripetal force and gravitational force . Mathematically, it is derived from the following relation: \\[ F_{\\text{centripetal}} = F_{\\text{gravitational}} \\] Where: \\[ \\frac{m v_1^2}{R} = \\frac{G M m}{R^2} \\] Simplifying for \\( v_1 \\) , we get the first cosmic velocity : \\[ v_1 = \\sqrt{\\frac{GM}{R}} \\] Where: - \\( G \\) = Gravitational constant \\( 6.67430 \\times 10^{-11} \\ \\text{m}^3 \\text{kg}^{-1} \\text{s}^{-2} \\) - \\( M \\) = Mass of the celestial body (kg) - \\( R \\) = Radius of the celestial body (m)","title":"1.1 First Cosmic Velocity"},{"location":"1%20Physics/2%20Gravity/Problem_2/#12-second-cosmic-velocity","text":"The second cosmic velocity is the escape velocity , the speed needed to escape the gravitational pull of the celestial body. This can be derived from the energy conservation between kinetic energy and gravitational potential energy: \\[ E_{\\text{total}} = E_{\\text{kinetic}} + E_{\\text{potential}} \\] Where: \\[ E_{\\text{kinetic}} = \\frac{1}{2} m v^2 \\quad \\text{and} \\quad E_{\\text{potential}} = - \\frac{G M m}{R} \\] Setting total energy to zero for escape: \\[ \\frac{1}{2} m v_2^2 = \\frac{G M m}{R} \\] Simplifying, we find the second cosmic velocity : \\[ v_2 = \\sqrt{\\frac{2GM}{R}} = \\sqrt{2} \\times v_1 \\]","title":"1.2 Second Cosmic Velocity"},{"location":"1%20Physics/2%20Gravity/Problem_2/#13-third-cosmic-velocity","text":"The third cosmic velocity is the speed required to escape the gravitational influence of the solar system , i.e., to escape the Sun\u2019s gravitational pull. This can be determined using the escape velocity from the Sun at a given distance \\( r \\) from the Sun: \\[ v_3 = \\sqrt{v_2^2 + v_{\\text{solar escape}}^2} \\] Where \\( v_{\\text{solar escape}} \\) is the escape velocity from the Sun at the object\u2019s distance: \\[ v_{\\text{solar escape}} = \\sqrt{\\frac{2 G M_{\\text{Sun}}}{r_{\\text{sun}}}} \\] Where: - \\( r_{\\text{sun}} \\) is the distance from the Sun in meters.","title":"1.3 Third Cosmic Velocity"},{"location":"1%20Physics/2%20Gravity/Problem_2/#2-constants-and-parameters","text":"","title":"2. \ud83d\udcda Constants and Parameters"},{"location":"1%20Physics/2%20Gravity/Problem_2/#21-gravitational-and-astronomical-constants","text":"Parameter Value Description \\( G \\) \\( 6.67430 \\times 10^{-11} \\ \\text{m}^3 \\text{kg}^{-1} \\text{s}^{-2} \\) Gravitational constant \\( M_{\\text{Sun}} \\) \\( 1.989 \\times 10^{30} \\ \\text{kg} \\) Mass of the Sun 1 AU \\( 1.496 \\times 10^{11} \\ \\text{m} \\) Astronomical unit","title":"2.1 Gravitational and Astronomical Constants"},{"location":"1%20Physics/2%20Gravity/Problem_2/#22-planetary-data","text":"Planet Mass \\( M \\) (kg) Radius \\( R \\) (m) Distance to Sun (AU) Earth \\( 5.972 \\times 10^{24} \\) \\( 6.371 \\times 10^6 \\) 1.0 Mars \\( 6.39 \\times 10^{23} \\) \\( 3.3895 \\times 10^6 \\) 1.524 Jupiter \\( 1.898 \\times 10^{27} \\) \\( 6.9911 \\times 10^7 \\) 5.204","title":"2.2 Planetary Data"},{"location":"1%20Physics/2%20Gravity/Problem_2/#3-python-code-implementation","text":"import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # Gravitational constant (m^3 kg^-1 s^-2) sun_mass = 1.989e30 # Mass of the Sun (kg) AU = 1.496e11 # Astronomical Unit (m) # Planetary data (Mass, Radius, Distance to Sun in AU) bodies = { \"Earth\": (5.972e24, 6.371e6, 1.0), \"Mars\": (6.39e23, 3.3895e6, 1.524), \"Jupiter\": (1.898e27, 6.9911e7, 5.204) } # Function to calculate velocities (v1, v2, v3) def calculate_velocities(mass, radius, distance_to_sun_AU): v1 = np.sqrt(G * mass / radius) v2 = np.sqrt(2) * v1 distance_to_sun = distance_to_sun_AU * AU v_sun_escape = np.sqrt(2 * G * sun_mass / distance_to_sun) v3 = np.sqrt(v2**2 + v_sun_escape**2) return v1, v2, v3 # Results results = {body: calculate_velocities(mass, radius, distance) for body, (mass, radius, distance) in bodies.items()} # Output Results for body, (v1, v2, v3) in results.items(): print(f\"{body}: v1 = {v1/1000:.2f} km/s, v2 = {v2/1000:.2f} km/s, v3 = {v3/1000:.2f} km/s\") # Visualization labels = list(results.keys()) v1_vals = [results[b][0] / 1000 for b in labels] v2_vals = [results[b][1] / 1000 for b in labels] v3_vals = [results[b][2] / 1000 for b in labels] x = np.arange(len(labels)) width = 0.25 fig, ax = plt.subplots(figsize=(8,5)) ax.bar(x - width, v1_vals, width, label='First Cosmic Velocity (v1)') ax.bar(x, v2_vals, width, label='Second Cosmic Velocity (v2)') ax.bar(x + width, v3_vals, width, label='Third Cosmic Velocity (v3)') ax.set_ylabel('Velocity (km/s)') ax.set_title('Cosmic Velocities for Planets') ax.set_xticks(x) ax.set_xticklabels(labels) ax.legend() ax.grid(True) plt.tight_layout() plt.show() Planet First Cosmic Velocity (v1) [km/s] Second Cosmic Velocity (v2) [km/s] Third Cosmic Velocity (v3) [km/s] Earth 7.91 11.18 42.13 Mars 5.03 7.11 34.38 Jupiter 42.12 59.55 66.69","title":"3. \ud83e\udde0 Python Code Implementation"},{"location":"1%20Physics/2%20Gravity/Problem_3/","text":"Problem 3","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#problem-3","text":"","title":"Problem 3"},{"location":"1%20Physics/3%20Waves/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_2/","text":"Problem 2","title":"Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/7%20Measurements/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"2%20Mathematics/1%20Linear_algebra/","text":"Linear Algebra","title":"Linear Algebra"},{"location":"2%20Mathematics/1%20Linear_algebra/#linear-algebra","text":"","title":"Linear Algebra"},{"location":"2%20Mathematics/2%20Analytic_geometry/","text":"Analytic geometry","title":"Analytic geometry"},{"location":"2%20Mathematics/2%20Analytic_geometry/#analytic-geometry","text":"","title":"Analytic geometry"},{"location":"2%20Mathematics/3%20Calculus/","text":"Calculus","title":"Calculus"},{"location":"2%20Mathematics/3%20Calculus/#calculus","text":"","title":"Calculus"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/","text":"Set Theory","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/#set-theory","text":"","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/","text":"Relations","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/#relations","text":"","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/","text":"Functions","title":"Functions"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/#functions","text":"","title":"Functions"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/","text":"Combinatorics","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/#combinatorics","text":"","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/","text":"Number Theory","title":"Number Theory"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/#number-theory","text":"","title":"Number Theory"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/","text":"Sequences and Series","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/#sequences-and-series","text":"","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/","text":"Induction","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/#induction","text":"","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/","text":"Recurrence","title":"Recurrence"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/#recurrence","text":"","title":"Recurrence"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/","text":"Graph Theory","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/#graph-theory","text":"","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/","text":"Logic","title":"Logic"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/#logic","text":"","title":"Logic"}]}